{"i": "5699796522762240", "t": "Given a string\u00a0S\u00a0of length\u00a0N. Now, you need to cut the string\u00a0S\u00a0into\u00a0K+1\u00a0non-empty substrings by performing\u00a0K\u00a0cuts. \rThere are lots of ways of performing the cuts in the string\u00a0S. For every way of performing the cuts, you need to count how many substrings will be a palindrome in that way of cut. You need to sum this count over all possible ways of cutting the string\u00a0S.\u2028\u2028Input Format\rThe first line contains two integers\u00a0N\u00a0and\u00a0K\u00a0as input.\u2028The second line contains the string\u00a0S\u00a0as input.\u2028\u2028Output Format\rIn the output, you need to print the sum modulo\u00a0\r10^9+7.\u2028\u2028Constraints\r2\u2264N\u22645000\r 1\u2264K\u2264N\u22121\r\u2028String\u00a0S\u00a0contains only lowercase english alphabets\r  Sample Input\r 5 2\raabbc\rSample Output\r 12\r  Explanation\rIn the given test case there are\u00a0\r6\u00a0ways to perform the cuts. All the ways are described below.\r a |\u00a0a |\u00a0bbc\u00a0=\u00a02\u00a0substrings are palindrome\ra |\u00a0ab | bc =\u00a01\u00a0substring is palindrome\ra | abb | c =\u00a02\u00a0substrings are palindrome\raa | b | bc =\u00a02\u00a0substrings are palindrome\raa | bb | c =\u00a03\u00a0substrings are palindrome\raab | b | c =\u00a02\u00a0substrings are palindrome\rSo, the output is\u00a0\r2+1+2+2+3+2=12", "k": ["string", "substrings", "palindrome", "cuts", "input"]}
{"i": "5661535477694464", "t": "There are N nodes in a graph connected by exactly N-1 edges. There is exactly 1 shortest path from one node to any other node. The nodes are numbered from 1 to N. Given Q queries which tell source node and the destination nodes. Find the most visited node after traveling those Q paths. For example, say Q=3\rand 3 queries are \r1 5\r2 4\r3 1\r So travel from node 1 to node 5, then from node 2 to node 4, then from node 3 to node 1. Finally, find what is the most visited node after the Q queries.\rFinding every path and incrementing every visited node count is a naive solution. The interviewer asked me to optimize it.", "k": ["node", "graph connected", "visited node", "nodes", "visited"]}
{"i": "5674827931713536", "t": "Guys,\r I have an interview in Google exactly after 2 weeks for software engineer position. I recently have done my MS in Information Science and I applied in google. They shortlisted my profile and sent me sample code exam which I have passed. Now it's my technical interview and I am very beginner into programming. Can please anyone help me what type of questions do they ask and how to tackle those questions. I am not good in data structures and algorithm. I self-taught programming online classes. I am so scared to face the interview. Please suggest me  something", "k": ["software engineer position", "weeks for software", "engineer position", "software engineer", "information science"]}
{"i": "5766635969839104", "t": "Int minSemsToFinishAllCourses(Map<string, list<string>)Given a map containing courses and the list of prerequisites for that course in no particular order,  determine the least number of semesters to finish all the courses. \rYou have to take all prerequisites before you take a given course. \r Eg. \rCalculus : English, math2 \rMath2: math 1, Arabic, english \rMath1: english \rEnglish: <>\rArabic:<> \r Give an algorithm for the above and code using java", "k": ["int minsemstofinishallcourses", "string", "number of semesters", "semesters to finish", "map"]}
{"i": "5724291887267840", "t": "Roulette -Gamblers Fallacy. start with $50, bet opposite  color every time same color 4 in a row. loop 100 time or until $0. Suggest create roulette wheel object with history, a gambler object with maybe gamblingplan object. (you can find more detailed suggestions elsewhere)", "k": ["gamblers fallacy", "fallacy", "object", "color", "roulette"]}
{"i": "5684991594332160", "t": "Given a tree with n nodes. Each node has k coins, where 0 <= k <= n . There are total n coins on the tree. \rThe goal is to move the coins such that each node has exactly one coin. What's the minimum moves required?\rEach move can only move one coin to an adjacent node.", "k": ["node", "coins", "tree", "move", "coin"]}
{"i": "5723406763294720", "t": "Add two numbers represented as LinkedList (not LeetCode 445 which uses ListNode)\re.g \rinputs: '5'->'6'->'3'\r            '8'->'4'->'2'\routput: '1'->'4'->'0'->'5'\rmethod signature:  \r\tLinkedList<Integer> sumList(LinkedList<Integer> l1, LinkedList<Integer> l2)", "k": ["integer", "method signature", "add two numbers", "numbers represented", "linkedlist"]}
{"i": "5697271283318784", "t": "You have two sorted arrays, where each element is an interval. Now, merge the two array, overlapping intervals can be merged as a single one.\r I/P : \rList 1 [1,2] , [3,9]\rList 2 [4,5], [8, 10], [11,12]\r O/P [1,2], [3,10], [11,12]", "k": ["list", "sorted arrays", "sorted", "element", "overlapping intervals"]}
{"i": "5767007794888704", "t": "I/P [8, 3, 2, [5, 6, [9]], 6]\r O/P 8+3+2+2*(5+6+3*(9))+6 => 95", "k": []}
{"i": "5769621685141504", "t": "We woild like to encourage passegers to experience the joy of travel using our transit system, therefore we would like to determine the longest path available to advertise the public. Specifically we would like to determine the longest possible trip on the transit sytem that will involve TWO tickets. The destinations must be connected, and all destinations must be unique.\r You will be provided input in the format of CHI:NYC:719 where CHI is one location, NYC is a connected locatoion and 719 is the distance between the locations.\r one line of output should be provided per line of input in the format of 3167:CHI:NYC:LA where 3167 is the distance of the trip, CHI is the starting, NYC is the intermediary location and LA is the final location.\r sequence-------input---------------------------output\r1------------------CHI:NYC:719----------------NONE\t\r2------------------NYC:LA:2414----------------3133:CHI:NYC:LA\r3------------------NYC:SEATTLE:2448------4862:LA:NYC:SEATTLE\r4------------------NYC:HAWAII:4924---------7372:HAWAII:NYC:SEATTLE\r Note: the start and end cities are lexicographical sorted.", "k": ["nyc", "determine the longest", "chi", "advertise the public", "encourage passegers"]}
{"i": "5650168846745600", "t": "Design and implement following . Suppose have 10 resources and 5 threads how do you design so that threads asking for \rResources should be done in order. Eg t1  asks for 3 resources, t2 asks for 4 resources\u2026", "k": ["suppose", "resources", "design and implement", "design", "threads"]}
{"i": "5654613936570368", "t": "Given k,n,m. where k is no. of coconuts you initially have. n is the some no. such that if you have >=n coconuts, you becomes stressed otherwise you become normal. m is the no. of shops.You go from 1st shop to m-th shop without skipping any shop. At i-th shop, either you buy Si coconuts or sell Si coconuts. If you are stressed then you must become normal at next shop. If you have less than Si coconuts and you want to sell then you must sell all the coconuts you have. The task is to calculate maximum possible changes of your mood from stressed to normal or vice-versa.\r ie: shop ={100,200,100,1,1} , k=1900 , n=2100 then answer should be 3 as initially mood is happy at first shop we buy 100 coco and total are 2000<n so still happy, at shop 2 coco 2200,now mood is stressed and so", "k": ["coconuts", "shop", "stressed", "normal", "sell"]}
{"i": "5703421944922112", "t": "find all numbers the sum of cube of each digits is the number itself\rex:153=1^3+5^3+3^3", "k": ["sum of cube", "find all numbers", "numbers the sum", "find", "sum"]}
{"i": "5706918551617536", "t": "what is default pakg in java", "k": ["pakg in java", "default pakg", "java", "default", "pakg"]}
{"i": "5683281064886272", "t": "any one can tell what is special modifers in java.", "k": ["modifers in java", "special modifers", "java", "special", "modifers"]}
{"i": "5178777026428928", "t": "#include <iostream>\r#define INF 99999\r using namespace std;\r int calculate(int x,int y)\r   {\r      if(x == 1) return y-1;\r       if(x == y||x == 0||y == 0) \r           return INF;\r          return y/x  + calculate(y%x,x);\r}\rint minimum(int N)\r{\r    int minmoves = N-1;\r\tfor(int i=2;i<N;i++)\r    minmoves = min(minmoves,calculate(i,N));\r\tcout<<minmoves<<endl;\r}\rint main()\r{\r   int N = 1;\r  cout <<minimum(N);\r   return 0;\r}\rWhy my code showing correct output with some big integer \rLike: 0\r        1009665443", "k": ["code showing correct", "showing correct output", "int calculate", "int minimum", "int main"]}
{"i": "5650055197884416", "t": "Given a number N, Assume a lexicographical ordered 1 to N numbers.\rGiven array consisting of indices, return the array with numbers at that positions in the lexicographically sorted array of [1 to N].\rfollow up: Do not use Extra memory.\r Expected Runtime = O( N * log k) or O(N)\rN = total numbers, (1 to N)\rk = Number of queries\r  Example:\rN = 12\rlexicographical ordered array = [1,10,11,12,2,3,4,5,6,7,8,9]\rQuery = [1 , 4]\r return = [10, 2]", "k": ["assume a lexicographical", "assume", "lexicographical ordered", "lexicographical ordered array", "numbers"]}
{"i": "5743112610119680", "t": "There are A cities numbered from 1 to A.\rYou have already visited M cities, the indices of which are given in an array B of M integers. If a city with index i is visited, you can visit either the city with index i-1 (i >= 2) or the city with index i+1 (i < A) if they are not already visited. Eg: if N = 5 and array M consists of [3, 4], then in the first level of moves, you can either visit 2 or 5. You keep visiting cities in this fashion until all the cities are not visited. \rFind the number of ways in which you can visit all the cities modulo 10^9+7\r N = 5\rVisited = [2, 5]\rNumber of ways = 6\r1 -> 3 -> 4\r1 -> 4 -> 3\r3 -> 4 -> 1\r4 -> 3-> 1\r3 -> 1 -> 4\r4 -> 1 -> 3", "k": ["city with index", "visited", "cities", "cities numbered", "index"]}
{"i": "5693496577490944", "t": "Program to find the rank student", "k": ["program to find", "rank student", "find the rank", "program", "student"]}
{"i": "5750184709980160", "t": "1. Input string s. Check if string s is a valid string with valid brackets\rFor example:\r(({{}})) is a valid s\r{[]} is a valid s\r[{[}]] is not valid\r 2. What kind of tests would you conduct to your program to minimize bugs in your program.\r 3. On the previous example there is only \"()\", \"{}\", and \"[]\" combination of brackets. If other developers want to add a new kind of brackets such as \"<>\". What kind of changes would change in your previous program.", "k": ["valid", "string", "kind", "brackets", "program"]}
{"i": "5715298301247488", "t": "You have N toffee packets, each containing different number of toffees. The number of toffees contained in the ith packet is denoted by ci. You need to put these toffee packets in 5 boxes such that each box contains at least one toffee packet, and the maximum number of toffees in a box is minimum.\r You can only choose consecutive toffee packets to put in a box.", "k": ["toffee packets", "toffee", "number", "number of toffees", "packets"]}
{"i": "5076378496532480", "t": "The difference between move and forward in C++", "k": ["difference between move", "move and forward", "difference", "move", "forward"]}
{"i": "5759350673506304", "t": "We need to declare variable types in C++. \rHow does this type declaration change the structure of the code comparing to other languages without type declaration like Python?", "k": ["declare variable types", "declare variable", "variable types", "type declaration", "type declaration change"]}
{"i": "5699718944915456", "t": "Given a matrix of 0's and 1's find the smallest number of groups made of 1's, where one group can cover up to two 1's at the same time vertically or horizontally.\r 01111\r11011\r00100\r The matrix above has 5 of such groups. I've seen similar questions but there the question was about groups of adjacent 1's. Here the groups are limited.\rAnother question how it would change, if the group wasn't limited to two but to given k - number of 1's vertically or horizontally. The time complexity should be the most efficient. \rMy idea here i to iterate through rows and when we find a 1, check it's bottom and right neighbour. If it has a right but no bottom, a group is made and we skip the right neighbour as it is already in a group. When the checked 1 has a bottom but no right, we make a group of them and we can skip checking the right as well i think.", "k": ["group", "groups", "vertically or horizontally", "smallest number", "matrix"]}
{"i": "5127956389691392", "t": "Puzzle:\rThere are 4 similar bottles ,all bottles are filled with milk. In one of the bottle  is poisoned. There are 4 rats with you .how many rats are required to find out poisoned bottle?", "k": ["filled with milk", "similar bottles", "puzzle", "similar", "milk"]}
{"i": "5728345304596480", "t": "There are 4 similar bottles ,all bottles are filled with milk. In one of the bottle  is poisoned. There are 4 rats with you .how many rats are required to find out poisoned bottle?", "k": ["filled with milk", "similar bottles", "similar", "milk", "filled"]}
{"i": "5744279733927936", "t": "how can i apend two array in C#   like this\r     a1 = [1, 2, 3, 4];\r    a2 = [\"a\", \"b\", \"c\"];\r    result a3 = [a1, b2, c3, d4];", "k": ["apend two array", "result", "apend", "array"]}
{"i": "5741030054297600", "t": "You have two files in hdfs one having date range with two columns start date and end date and another having two column with date and visitors field. You have to write a spark code which gives date range having maximum no. of visitors using that two files.", "k": ["columns start date", "columns start", "visitors field", "date range", "start date"]}
{"i": "5736150434578432", "t": "You are given an array A of size N and  Q queries. For each query, you are given two indices of the array L and R. The subarray generated from L to R is reversed. Your task is to determine the maximum sum of the subarrays.\r Note: After each query is solved, the array comes to its initial states.\r Input format\r First line: Two space-separated integers N and Q\rNext line: N space-separated integers denoting the array elements.\rNext \rQ lines: Two space-separated integers in every line denoting the values of Li and Ri\rOutput format\r For each query, print the required answer in a new line.\r   5 2\r3 -1 4 2 -1\r3 4\r1 2\r //output\r8\r9", "k": ["array", "space-separated integers", "line", "query", "space-separated"]}
{"i": "5636163595927552", "t": "Convert infix to postfix and evaluate postfix expression.\r For example: 4 // number of variables\rg = 2\rp = 3\rt = 1\rw = 2\r 3 // number of equations\rg + p x t - w x p\rt - g + t - w\re + t x t - m\r Output:  -1 //for first equation\r-2 //for second equation\rCompilation Error // for third equation", "k": ["evaluate postfix expression", "convert infix", "equation compilation error", "postfix expression", "evaluate postfix"]}
