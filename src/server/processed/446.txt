{"i": "9322597", "t": "We have been given a deck of cards and each combination has a rating eg 3 As is higher than 2 As 1K etc.\r Write an algorithm such that the probability of picking 3 or 5 or 7 cards from the deck results in high rating", "k": ["deck", "cards", "rating", "combination", "higher"]}
{"i": "9324402", "t": "where would you see yourself 5 years from now?", "k": ["years"]}
{"i": "9321471", "t": "Why do you want to join BOA?", "k": ["join boa", "boa", "join"]}
{"i": "9320333", "t": "I had a phone interview at Amazon yesterday and i was asked one question which i think i did not answer satisfactorily.\r the question goes like this:\rIs having a lot of branches (if conditions) in a code bad?\r my answer was that for an if condition a jump statement is introduced in the assembly code and thus the program has to jump from one memory address to another which eats up a lot of cpu cycle. However, the interview didn't seem impressed and end the interview just after 2 mins\rWHY???????????", "k": ["amazon yesterday", "answer satisfactorily", "amazon", "phone interview", "interview at amazon"]}
{"i": "9321845", "t": "given an array of integers S[], visualize it as a bar graph, with the index i as x coordinate and the S[i] as the y coordinate. and that the bars are shaded. find the largest rectangle, in the shaded bars.", "k": ["array of integers", "bar graph", "shaded bars", "visualize", "graph"]}
{"i": "9322815", "t": "given two arrays A and B.\rA has integers unsorted.\rB has the same length as A and its values are in the set {-1,0,1}\r you have to return an array C with the following processing on A.\rif B[i] has 0 then C[i] must have A[i]\rif B[i] has -1 then A[i] must be in C within the sub array C[0] - C[i-1] ie. left subarray\rif B[i] has 1  then A[i] must be in C within the sub array C[i+1] - C[length(A)] ie right subarray.\rif no such solution exists then printf(\"no solution\");", "k": ["array", "integers unsorted", "length", "subarray", "solution"]}
{"i": "9320958", "t": "Give an algorithm that determines the number of inversions in any permutation of n elements (stored as an array) in o(n lg n)", "k": ["give an algorithm", "algorithm that determines", "determines the number", "number of inversions", "give"]}
{"i": "9324703", "t": "what improvements you want to make to google map? how will u make it?", "k": ["google map", "map", "make", "improvements", "google"]}
{"i": "9323762", "t": "There is an array and the distance between any two consequent elements is one(+1 or -1) and given a number. You have to check whether the number is in array or not with minimum complexity.", "k": ["consequent elements", "array", "number", "minimum complexity", "distance"]}
{"i": "9313648", "t": "how would u find the amount of dynamically allocated memory??\r Its good if u write the code..!!!!", "k": ["dynamically allocated memory", "allocated memory", "find the amount", "amount of dynamically", "dynamically allocated"]}
{"i": "9317876", "t": "How vector has been implemented in STL ?", "k": ["implemented in stl", "stl", "vector", "implemented"]}
{"i": "9314487", "t": "What is faster normal variable or pointer?", "k": ["faster normal variable", "variable or pointer", "faster normal", "normal variable", "pointer"]}
{"i": "9313581", "t": "What is the difference between an error and exception?", "k": ["error and exception", "exception", "difference", "error"]}
{"i": "9312654", "t": "How vector has been implemented in STL ?", "k": ["implemented in stl", "stl", "vector", "implemented"]}
{"i": "9317381", "t": "What is faster normal variable or pointer?", "k": ["faster normal variable", "variable or pointer", "faster normal", "normal variable", "pointer"]}
{"i": "9312653", "t": "What is the difference between an error and exception?", "k": ["error and exception", "exception", "difference", "error"]}
{"i": "9314280", "t": "(2^i * 5^j), increment i and j to ensure the output is sorted\reg. 1 2 4 8 10 16 20 25 32 64 100 125 128", "k": ["ensure the output", "output is sorted", "increment", "ensure", "output"]}
{"i": "9308395", "t": "If you have a dictionary (sorted list of words) of unknown size and given a function which returns the word in the dictionary at a specified 'i'th location. Suggest an algorithm for finding a word.\r I could think of finding the size of dictionary by exponentially getting (2^i)th element (incrementing i each time till the word is lexicographically higher than the given word) and then simply applying binary search from 0 to 2^i.", "k": ["i'th location", "sorted list", "function which returns", "unknown size", "word"]}
{"i": "9307474", "t": "given an array and find two numbers in the array having difference equal to given number.i am also given that arr is sorted", "k": ["arr is sorted", "find two numbers", "difference equal", "array and find", "array having difference"]}
{"i": "9304600", "t": "You have 5 sorted linked lists. Merge them retaining the ascending order.", "k": ["sorted linked lists", "sorted linked", "linked lists", "sorted", "lists"]}
{"i": "9305547", "t": "There is a straight roads with 'n' number of milestones. You are given an array with the distance between all the pairs of milestones in some random order. Find the position of milestones.\r Example:\r Consider a road with 4 milestones(a,b,c,d) :\r a <--- 3Km --->b<--- 5Km --->c<--- 2Km --->d\rDistance between a and b = 3\rDistance between a and c = 8\rDistance between a and d = 10\rDistance between b and c = 5\rDistance between b and d = 7\rDistance between c and d = 2\r All the above values are given in a random order say 7, 10, 5, 2, 8, 3.\r The output must be 3,5,2 or 2,5,3 \r We can begin by subtracting the second largest number from the largest number. But still when the number of milestones is high, it gets a bit complex", "k": ["distance", "milestones", "straight roads", "number", "random order"]}
{"i": "9307282", "t": "Given a Sorted array S. You've to return an index i where s[i]=i or -1 if there is no index such.", "k": ["sorted array", "sorted", "array", "index", "return"]}
{"i": "9309736", "t": "You've given a stack with the basic operations - push and pop. You've to modify it so that a new operation \"getMin\" can be supported at O(1) complexity. There is no constraints on memory.", "k": ["push and pop", "basic operations", "push", "pop", "getmin"]}
{"i": "9305312", "t": "Design a Flight take-off control system\r There are two type of flights - Passenger and Cargo\rEach type of flight can be SMALL or LARGE.\rProblem is to design a take-off control system such that the following precedence is maintained.\r1. Passenger > Cargo.\r2. If both flights are same type then LARGE > SMALL\r3. If both types and sizes are same then flight with longer GroundDuration(i.e ground stay time)  has precedence over other flights.\rThe design and the implementation should be such that the take-off of all flights happen according to the above conditions.", "k": ["take-off control system", "control system", "take-off control", "passenger", "flight take-off control"]}
{"i": "9307689", "t": "You can concatenate A to A, and search B in the resulted string using an O(n) algorithm, KMP, Boyer Moore.", "k": ["boyer moore", "resulted string", "kmp", "algorithm", "boyer"]}
{"i": "9301931", "t": "write a function which takes two parameter as numerator and denominator and returns the string form of (numerator/denominator)..if the fraction is repeating then the repeating no. should be in bracket.\rFor ex- input: num=13, den=11 \routput: 1.[18]", "k": ["write a function", "returns the string", "string form", "parameter as numerator", "denominator and returns"]}
{"i": "9304677", "t": "Assume always the input will be between integer value 1-1000. Implement a data structure in which \rvoid Insert(int), void Delete(int), boolean IsTher(int), int FindAny()(returns any no. from previous input)..all are of O(1)..may use extra space if required.", "k": ["integer value 1-1000", "int", "void insert", "void delete", "assume"]}
{"i": "9304676", "t": "There is a linked list whose node has 3 fields, val, next pointer & random pointer...next pointer points to next node in the list and random pointer can point to any node in the list.Write an efficient function which takes such list and returns the copy/clone of that list.", "k": ["returns the copy", "random pointer", "list.write an efficient", "efficient function", "pointer points"]}
{"i": "9286520", "t": "Given two unsigned integers, write an efficient function which returns the no. of bits needs to be flipped of one to generate the other.", "k": ["unsigned integers", "write an efficient", "efficient function", "function which returns", "integers"]}
{"i": "9208580", "t": "There are 'n' sorted linked list with avg. 'k' length, write an efficient function which return the head pointer of a single list which is the combination of all 'n' list and in sorted order.(Avoid using extra space)", "k": ["sorted linked list", "sorted linked", "linked list", "avoid using extra", "avg"]}
