{"i": "5094533572329472", "t": "Write a function that will operate on a C-string and convert all instances of \"AB\" to \"C\" without using a second string for temporary storage. Use the following function signature: \r       void translate(char *str) \r    So for example: \r    char astring[] = \"helloABworld\"; \r    translate(astring); \r    // Now astring holds \"helloCworld\"; \r    Your function should handle strings of arbitrary length.", "k": ["c-string and convert", "temporary storage", "convert all instances", "c-string", "write"]}
{"i": "5181695705743360", "t": "Assume that garbage collector is not there in place or you are implementing a garbage collector for C++. Write the design and sample code for garbage collector implementation \rWe have 3 classed and Class A, B, C. object of A uses object B and Object of B uses Object of C. How can we track the object existence and clear memory ?\rAnswer which I suggested : Write a tree (or Graph?)data structure (Garbage collector is a container class holds this data structure)  where each node has multiple paths to reach. If any of the node is not having a path to reach then we can clean that memory. This way the garbage collection will work. Please suggest your design as well.", "k": ["garbage collector", "object", "garbage", "collector", "garbage collector implementation"]}
{"i": "5646646585065472", "t": "Given an array, find the first element that appears an even number of times.", "k": ["number of times", "array", "find", "times", "element"]}
{"i": "5105829336317952", "t": "Given a circular linked list. Find the longest sequence of numbers, where a sequence starts with any number, for example 3,  and ends when you see that number again,another 3.  \r Imagine the circular linked list \r3 8 9 7 2 1 3 4 6  [3] same as first element .i.e three. \rThe longest sequence would be 3 8 9 7 2 1 , the other candidate being 3 4 6  \r Finding for instance,starting at 8 and getting to  the same 8 wouldn't count as a valid sequence.", "k": ["circular linked list", "linked list", "circular linked", "longest sequence", "sequence"]}
{"i": "5750033964072960", "t": "Given a 8 by 8 matrix, find all possible paths , moving one cell downwards or on cell to the right,(one cell per movement ) from cell 0,0 , to cell 7,7", "k": ["cell", "moving one cell", "matrix", "cell per movement", "find"]}
{"i": "5668779289739264", "t": "Find the first non-repeated element in an unsorted array.", "k": ["unsorted array", "non-repeated element", "find", "array", "non-repeated"]}
{"i": "5716100769644544", "t": "Given a squared matrix, shift all elements 1 place to the right in circular fashion.", "k": ["shift all elements", "squared matrix", "circular fashion", "matrix", "shift"]}
{"i": "5068651629641728", "t": "What is the maximum leads that can be generated from ad budget of 30k. Below is the table provided:\r Budget\t10000\t20000\t30000\t40000\t50000\rDisplay Leads\t500\t1000\t1200\t1500\t1700\rSEO Leads\t1000\t1500\t1700\t1900\t2500", "k": ["display leads", "seo leads", "maximum leads", "leads", "budget"]}
{"i": "5729149350051840", "t": "Assume that const_cast is not in place for C++, can you please write the code to do such casting?", "k": ["assume that const", "write the code", "assume", "const", "cast"]}
{"i": "5639326081744896", "t": "Build a simple binary tree and run a search using C#", "k": ["simple binary tree", "build a simple", "simple binary", "binary tree", "tree and run"]}
{"i": "5713469296869376", "t": "In C#, Given a list of numbers [4,8,20,11,12,18,50,10,11] and divided in sections of 3. Reverse each section without using a another array.", "k": ["list of numbers", "numbers", "list", "divided", "divided in sections"]}
{"i": "5723399261257728", "t": "Given integer k and a subset S of set {0, 1, 2, ..., 2^k - 1}\rReturn the count of pairs (a, b) where a and b are from S and (a < b) and (a & b == a)\r& here is bit-wise and.\rDo it faster than O((2^k)^2), assume k <= 16\r Example:\r0b111\r0b101\r0b010\rAnswer: 2\r 0b110\r0b011\r0b101\rAnswer: 0", "k": ["return the count", "count of pairs", "answer", "return", "set"]}
{"i": "5113734827606016", "t": "Given an array of words (i.e. [\"ABCW\", \"BAZ\", \"FOO\", \"BAR\", \"XTFN\", \"ABCDEF\"]), find the max value of length(s) * length(t), where s and t are words from the array. The catch here is that the two words cannot share any characters.\r Assume that there are many words in the array (N words) and average length of word is M.\r Answer for the example above is \"ABCW\" and \"XTFN\" as the result is 4 * 4 = 12. \r \"ABCW\" and \"ABCDEF\" do not work since they share similar characters.", "k": ["find the max", "abcw", "baz", "foo", "bar"]}
{"i": "6115468303663104", "t": "For anyone who's using C++ in interviews - \r How do you handle questions which require the use of HashMaps? Do you use std::unordered_map? It's API, especially the use of iterators, can get rather lengthy to write out on a whiteboard. What's your advice?", "k": ["handle questions", "questions which require", "interviews", "hashmaps", "handle"]}
{"i": "5666335453347840", "t": "You have a BST and you need to assign an appropriate value to neighbor of all nodes (Explained in below example)\r           Node Structurenode {\r\n                     node leftChild,\r\n                     node rightChild,\r\n                     T data,\r\n                      node neighbor\r\n                     }A\r         /     \\\r       B       C\r     /    \\         \\\r   D     E       F\r Based on above tree, \r Node: Neighbor\rA: NULL\rB: C\rD: E\rE: F", "k": ["node structurenode", "node leftchild", "node rightchild", "node neighbor", "node"]}
{"i": "5089913462587392", "t": "Given an array of stock values of a company. Find out the time when a user would have bought the stock and sold the sock. Basically find the maximum positive difference of any two given elements in an array?", "k": ["company", "stock", "array", "sold the sock", "find"]}
{"i": "5708890861731840", "t": "Problem Statement\r A group of scientists have broken down species DNA into sequences of integers. They determine that two species with the respective DNA sequences A and B are considered to be related if a non-decreasing sequence C of the same length can be found, such that Ci=Ai or Ci=Bi.\r Given the DNA sequences for two species, help the scientists determine if they are related.\r Input Format\r The first line contains an integer, T, the number of test cases.\r For each test case: \rThe first line contains an integer, N, the length of the DNA sequence. \rThe second line contains a sequence of space-separated integers describing species A. \rThe third line contains a sequence of space-separated integers describing species B.\r Constraints: \r1\u2264T\u22645 \r1\u2264N\u2264105 \r0\u2264Ai, Bi\u22641010\rOutput Format\r On a new line for each test case, print YES if a non-decreasing sequence of the same length can be found (i.e.: species are related) or NO if it cannot.\r  3\r3\r1 2 3\r4 4 4\r3\r3 2 1\r6 5 4\r2\r1 0\r10 2\r  Test Case 1: We could have C=1 2 4 \rTest Case 2: No increasing sequence C is possible. \rTest Case 3: We could have C=1 2.", "k": ["test case", "problem statement", "statement a group", "dna sequences", "dna"]}
{"i": "5686055997014016", "t": "Find the n-th smallest multiple given a set of numbers. For example, set = {4, 6},  n = 6:\r The sequence is:\r 4, 6, 8, 12, 16, 18, etc...\r Answer is 18", "k": ["n-th smallest multiple", "find the n-th", "n-th smallest", "smallest multiple", "set of numbers"]}
{"i": "5758112529121280", "t": "We have a long string. We label some substrings with tags. \r - A tag entry is [startIndex, endIndex, tag].\r- Query: 1 or more tags\r- Output: all blocks/ranges with all queried tags.\r Example tag entries:\r     [23, 72, 0]\t// label [23, 72) with tag 0\r    [34, 53, 1]\t// label [34, 53) with tag 1\r    [100, 128, 0]\r Query and Output:\r     0 => [23, 72], [100, 128]\r    0,1 => [34,53]\t// [34, 53) matches both tag 0 and 1\r Give an efficient algorithm. Please describe your algorithm before posting code.\r **Edit**: To add some difficulties, partial overlap is treated the same as full overlap, ONLY the overlapped part matches both tags. E.g. if we have entries:\r     [23, 72, 0]\t// label [23, 72) with tag 0\r    [10, 53, 1]\t// label [34, 53) with tag 1\r Query and Output:\r    0,1 => [23,53]\t// [23, 53) matches both tag 0 and 1\r Minor detials: Note in the comments we used open range on the right, i.e. if the string named \"str\", [23, 72, 0] includes str[23] but NOT str[72]; and there's no overlap between the following entries:\r[23, 72, 0]\r[10, 23, 0]", "k": ["tag", "query and output", "query", "output", "label"]}
{"i": "5667376647372800", "t": "Design  Interprocess Singleton class in C++\r When multiple instance of  singleton.exe is running, same memory(singleton instance) should be shared among all the process", "k": ["design interprocess singleton", "interprocess singleton class", "design interprocess", "interprocess singleton", "singleton.exe is running"]}
{"i": "5734157349027840", "t": "How to find middle element in a linked list without knowing the length of the linked list", "k": ["find middle element", "linked list", "find middle", "middle element", "knowing the length"]}
{"i": "5720376006934528", "t": "Write  a program to display 1st, 2nd and 4th multiples of 7which also gives the remainder 0 (ZERO) when it divided by 2,3,4,5 and 6.", "k": ["write a program", "program to display", "write", "display", "multiples"]}
{"i": "5744076173344768", "t": "Write a program to display the series 1,2,6,15,31,56,......,N", "k": ["write a program", "display the series", "program to display", "write", "series"]}
{"i": "5749172554694656", "t": "Given a binary tree print it in inward spiral order i.e first print level 1, then level n, then level 2, then n-1 and so on.\r For Ex - \r             \t\t\t\t1\r      \t\t\t\t2\t\t           3\r\t\t\t4           5               6         7\r                8          9   10   11     12   13   14 15\r Print-  1 15 14 13 12 11 10 9 8 2 3 7 6 5 4\r Follow up question - Extend the algorithm to n-ary tree.", "k": ["binary tree print", "spiral order", "follow up question", "level", "binary tree"]}
{"i": "5096064795279360", "t": "build BST from sorted array of integers", "k": ["build bst", "bst from sorted", "array of integers", "sorted array", "bst"]}
{"i": "5684077627703296", "t": "Write 2 functions to serialize and deserialize an array of strings. strings can contain any unicode character. Do not worry about string overflow.", "k": ["functions to serialize", "serialize and deserialize", "deserialize an array", "write", "functions"]}
{"i": "5195491543351296", "t": "Two  files are there file1.txt, file2.txt - both have some random names.\r Like,\rfile1.txt         file2.txt\r----------        -----------\rRaja              Uthaya\rAntony          Karthi\rChristopher   Raja\rManickam     Antony\rVeeramani\r Assume  file1.txt can have more names(whole database of names), file2.txt has some selected names\r You have to display what are all the mismatching items from file1.txt\r Need efficient algorithm to do this", "k": ["antony veeramani assume", "uthaya antony karthi", "antony karthi christopher", "christopher raja manickam", "manickam antony veeramani"]}
{"i": "5682825644736512", "t": "Given string say ABCGRETCABCG and substring length let us take length as 3, find the count of possible substrings, for example in above string ABC => 2  and BCG => 2 , where CGR and other 3 word length substrings has a count of 1.", "k": ["word length substrings", "string abc", "word length", "string say abcgretcabcg", "find the count"]}
{"i": "5745534851612672", "t": "Given a set of numbers find if a triplet can form a triangle a+b > c , b+c > a and c+a > b. The result to display all possible combinations of triplets.  [ 10 5 3 4 7 1]  [5,3,4 ] is one possible triplet and there can be many more.", "k": ["set of numbers", "numbers find", "form a triangle", "triplet can form", "set"]}
{"i": "5767854722908160", "t": "Given a 2d array (say n*m), visit all elements faster than linear time (i.e. faster than m*n). (Assume not too big array. i.e. fits in memory etc.etc)\rI gave a solution: 4 pointers that start from 4 ends ((0,0), (0,n), (m,0), (m,n)) and walk the edges. Once done next inner rows and columns (i.e. (1,1), (1,n-1), (m-1,1), (m-1,n-1)). Easier to implement with just the indices and we can say 4 times faster. Another solution I gave was to use multithreading. He said no multithreading. But the interviewer was not convinced and he gave me a hint to use recursion (?). Couldn't get the solution that he wanted.", "k": ["visit all elements", "array", "elements faster", "linear time", "faster"]}
