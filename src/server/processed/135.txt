{"i": "5688309264154624", "t": "If I am designing a media player and I want to store songs and play them in random order\ra) what data structure will you use to store songs?\rb) how will select the next song to play in a way which prevents the same song being played in consecutive turn", "k": ["store songs", "designing a media", "media player", "random order", "data structure"]}
{"i": "5731367452147712", "t": "Given a string S, print the longest substring P such that P > S lexicographically.\rYou may assume that such substring exists.", "k": ["print the longest", "longest substring", "print", "lexicographically", "substring exists"]}
{"i": "5652404478410752", "t": "GIven a string \"str\" and pair of \"N\" swapping indices, generate a lexicographically largest string. Swapping indices can be reused any number times.\r Eg 1)\r String = \"abdc\"\r Indices:\r (1,4)\r (3,4)\r Answer:\r cdba, cbad, dbac,dbca\r \u200byou should print only \"dbca\" which is lexicographically largest.", "k": ["swapping indices", "lexicographically largest string", "swapping", "string", "str"]}
{"i": "5752417288192000", "t": "Algorithm to minimize number of trassaction.\rEg:\rA->B = Rs. 5\rB->C = Rs. 8\rC->D = Rs. 9\rA->D = Rs. 10\rD->B = Rs. 11\rC->A = Rs. 12\r Minimize transactions.", "k": ["number of trassaction", "minimize number", "algorithm to minimize", "algorithm", "trassaction"]}
{"i": "5674523761311744", "t": "Algorithm to minimize number of trassaction.\rEg:\rA->B = Rs. 5\rB->C = Rs. 8\rC->D = Rs. 9\rA->D = Rs. 10\rD->B = Rs. 11\rC->A = Rs. 12\r Minimize transactions.", "k": ["number of trassaction", "minimize number", "algorithm to minimize", "algorithm", "trassaction"]}
{"i": "5165056955252736", "t": "With input as a integer, write an algorithm to convert that to string without using any built in functions. It is a signed number. \r Equivalent to String.valueOf(-123); //java", "k": ["write an algorithm", "built in functions", "algorithm to convert", "integer", "write"]}
{"i": "5647443522748416", "t": "Given a number print the number of combinations you can derive from the number. 1=A, 2=B, 26=Z, 0=+.\r For example: 1123 can be represented by  1,1,2,3 which would stand for AABC. \rAnother representation - 11,23 - JW\rAnother representation - 1,1,23 - AAW\rAnother representation - 11,2,3 - JBC\r For number 1123, there will be 5 combinations.", "k": ["representation", "aaw another representation", "number", "number print", "stand for aabc"]}
{"i": "5693438059085824", "t": "In a binary tree, find and print the path with smallest weight.\r Criteria: the tree contains integer values in the nodes. It may not be balanced tree. Weight is calculated by sum of values in the nodes in that path. Write code that returns the path as well as the minweight.", "k": ["find and print", "binary tree", "smallest weight", "tree", "find"]}
{"i": "5192961626210304", "t": "what are the sequence of creation of files with extension;.h,.cpp,.asm,.obj,.a? what are each phase called and explain them", "k": ["files with extension", "sequence of creation", "creation of files", "cpp", "asm"]}
{"i": "5766741004124160", "t": "what is the use of dynamic_cast in c++", "k": ["dynamic", "cast"]}
{"i": "5642850860531712", "t": "what are the resources created newly when a new process is created in linux", "k": ["resources created newly", "resources created", "created newly", "created in linux", "linux"]}
{"i": "5629520355786752", "t": "Given a circular array of images, in LandScape and Portrait mode. Bidirectional movement in array is allowed.\re.g. \rLPPPLPPP\rL-> Landscape\rP-> Portrait\rCost of Viewing a Portrait image is Vp\rCost of Viewing a Landscape is (Rp(rotate) + Vp).\rCost of movement is -> m\ronce you visited the image viewing cost is zero if you revisit the image. Only movement cost is considered.\rJumps in array is not allowed. \rCalculate the maximum number of images you can see with cost X.", "k": ["portrait mode", "cost", "portrait", "landscape", "viewing"]}
{"i": "5739568692199424", "t": "Given a string e.g. ABCDAABCD. Shuffle he string so that no two smilar letters together.\rE.g. AABC can be shuffled as ABAC.", "k": ["abcdaabcd", "shuffled as abac", "string", "aabc", "abac"]}
{"i": "5695920550182912", "t": "Given a DNA sequence e.g. AAAGTAAGTAAGTGGG.....\rFind all the duplicates with length 10.", "k": ["dna sequence", "aaagtaagtaagtggg", "dna", "sequence", "duplicates with length"]}
{"i": "5757640303968256", "t": "Jack love playing games, Gluttonous snake( an old game in Nokia era) is one of his favorite. However, after playing gluttonous snake so many times, he finally got bored with the game, so he changed the rules:\r Rule 1: Write a code to find the Max sum path in a grid (2-D array), with dimension with n rows and m column (1<=n,m<=500)\r Rule 2: In the 2D Array, each cell (elements) contains a value v in the array is from (-1<=v<=99999)\r Rule 3. You can start from any position of the leftest column (border) of the array to the rightest(border) column of the array to calculate the Max Sum path.\r Rule 4. You can move up, right, down, and CAN'T move left, and can visit each element only one time.\r Rule 5.If the element is -1, it means the path is blocked, and you can't go through the path (calculate it in the sum), you have to choose other path to calculate the sum. \r For example, if a 4*4 array grid\r{{-1,3,2,1}\r               {2,-1,2,4}\r               {2,2,-1,3}\r               {4,2,1,2}};\rThe max sum path is : (from grid[4][0])\r4-->up-->2-->left-->2-->down-->2-->left-->\r1-->left-->2-->up-->3-->up-->4-->up-->1\r and the sum is 4+2+2+2+1+2+3+4+1 =21\r Thank you\r Here is my code, I am new in Java and there is still lots of improvements\rimport java.util.*;\rpublic class MainClass {\r public static void main(String[] args) {\r @SuppressWarnings(\"resource\")\rScanner rowDimension = new Scanner(System.in);\rSystem.out.print(\"Enter the number of rows: \");\rint firstInput = rowDimension.nextInt();\r @SuppressWarnings(\"resource\")\rScanner columnDimension = new Scanner(System.in);\rSystem.out.print(\"Enter the number of columns: \");\rint secondInput = columnDimension.nextInt();\r //Input two number to generate 2D Array\rInteger [][] array = new Integer[firstInput][secondInput]; \r//The purpose of the array is check the wall (cell value = -1)\rboolean [][] visited = new boolean[firstInput][secondInput];\r //Use Math.random() to generate the cell of the array\rint[][] randomTable = new int[firstInput][secondInput];\rfor (int row = 0; row < firstInput; row++) {\rfor (int column = 0; column < secondInput; column++) {\r// multiply by 1000000 to get a number between 0 and 99999\rrandomTable[row][column] = (int)(Math.random() * 1000000 -1);\rSystem.out.print(randomTable[row][column] + \" \");\r}\rSystem.out.println();\r}\r //Start form the left-down location of grid\rint i = firstInput-1, j = 0;\rvisited[i][j] = true;\rdouble sum = array[i][j];\rwhile(true)\r{\rint max = -1;\rint maxi = 0, maxj = 0;\r //Case1 : choose path: UP\rif(i-1 >= 0 && i-1<= firstInput-1 && j>=0 && j<= secondInput-1 && array[i-1][j] != null && array[i-1][j]>max && !visited[i-1][j])\r{\rmax = array[i-1][j];\rmaxi = i-1;\rmaxj = j;\r}\r //Case2 : choose path: Down\rif(i+1 >= 0 && i+1<= firstInput-1 && j>=0 && j<= secondInput-1 &&array[i+1][j] != null && array[i+1][j]>max && !visited[i+1][j])\r{\rmax = array[i+1][j];\rmaxi = i+1;\rmaxj = j;\r}\r //Case3 : choose path: Right\rif(i >= 0 && i<= firstInput-1 && j+1>=0 && j+1<= secondInput-1 && array[i][j+1] != null && array[i][j+1]>max && !visited[i][j+1])\r{\rmax = array[i][j+1];\rmaxi = i;\rmaxj = j+1;\r}\r i = maxi;\rj = maxj;\rvisited[i][j] = true;\rsum += max;\r //To the destination : Right-Up location of the grid\rif(i == 0 && j == secondInput-1)\rbreak;\r}\rSystem.out.println(sum);\r }\r}", "k": ["max sum path", "array", "nokia era", "max", "playing gluttonous snake"]}
{"i": "5761051581743104", "t": "Write a code to reverse the words in a sentence.", "k": ["write a code", "code to reverse", "reverse the words", "write", "sentence"]}
{"i": "5719882709598208", "t": "what is the best sorting algorithm in terms of complexity and why?", "k": ["sorting algorithm", "algorithm in terms", "terms of complexity", "sorting", "algorithm"]}
{"i": "5674377262661632", "t": "So i have this code :#include <stdio.h>\r\nint main()\r\n{\r\nint i, j;\r\nint * p, * q;\r\nint ** x;\r\n\r\ni = 100;\r\nj = 200;\r\np = &i;\r\nq = &j;\r\nx = &p;\r\n\r\n*p = *p + *q;\r\n*q = **x / 2;\r\n**x = *p + j;\r\n\r\nprintf(\" i = %d\\n\", i);\r\nprintf(\"&i = %p\\n\", &i);\r\nprintf(\" j = %d\\n\", j);\r\nprintf(\"&j = %p\\n\", &j);\r\n\r\nprintf(\" p = %p\\n\", p);\r\nprintf(\"&p = %p\\n\", &p);\r\nprintf(\"*p = %d\\n\", *p);\r\nprintf(\" q = %p\\n\", q);\r\nprintf(\"&q = %p\\n\", &q);\r\nprintf(\"*q = %d\\n\", *q);\r\n\r\nprintf(\" x = %p\\n\", x);\r\nprintf(\"&x = %p\\n\", &x);\r\nprintf(\"*x = %p\\n\", *x);\r\nprintf(\"**x= %d\\n\", **x);\r\n\r\nreturn 0;\r\n}I need to modify the program by adding a new variable that stores the address of x. Then use your variable to update (indirectly) the value of i and then print out the new value to demonstrate that your modification has worked.\r Can anyone help?", "k": ["printf", "int main", "int", "modify the program", "program by adding"]}
{"i": "5650292965113856", "t": "Given a series of number form a binary tree find the minimum weight binary tree. The weight of the node is depth * value of the element + weight of the left tree + weight of the right tree.\r Weight of the root node is the weight of the tree . Find the minimum weight binary tree out of all possible binary trees that are possible.", "k": ["minimum weight binary", "weight binary tree", "binary tree find", "weight", "find the minimum"]}
{"i": "5711718782074880", "t": "What is the best way to merge unsorted list and generate a single sorted list ? \r I was giving an option of inserting into Binary tree from both list and retrieve it.what is the best solution", "k": ["merge unsorted list", "single sorted list", "inserting into binary", "binary tree", "merge unsorted"]}
{"i": "5632091162148864", "t": "Can someone please help me with this? I just started C and i want to know how can i solve this, please help.\r#include <stdio.h>\rint main()\r{\r    int i = 200, *p, *q;\r    p = &i;  q = p;\r    *q = *q + 1;\r    printf(\"*p = %d\\n\", *p); \r    return 0;\r}\rModify the program by adding another integer pointer variable r which is also an alias for variable i. Add print statements to output the dereferenced values of q and r.", "k": ["modify the program", "int main", "int", "integer pointer variable", "variable"]}
{"i": "5644043787698176", "t": "Design an Algorithm for Amazon Advertisement Page", "k": ["amazon advertisement page", "advertisement page", "algorithm for amazon", "amazon advertisement", "design an algorithm"]}
{"i": "5689514874896384", "t": "https://gist.github.com/acegreen/e16a2259a93dab880a7f", "k": []}
{"i": "5718720652509184", "t": "https://gist.github.com/acegreen/1a9a63f27729278b0fa5", "k": []}
{"i": "5766232922914816", "t": "Given n dice each with m faces, numbered from 1 to m, find the number of ways to get sum X. X is the summation of values on each face when all the dice are thrown. 4+3 and 3+4 should be treated same. dont consider different permutations.", "k": ["find the number", "numbered", "find", "dice", "number"]}
{"i": "5691211923849216", "t": "Given an arbitrary tree starting at \u201croot\u201d where each node contains a pair of values (x, y), write a boolean function find(Node root, int x, int y) that returns true iff\r* x is equal to a value \"x\" of any node n1 in the tree\r* and y is equal to a value \"y\" of any node n2 in the tree\r* and both n1 and n2 are at the same level in the tree\r boolean find(Node root, int x, int y)\r Example:\r                  (1,120)\r          /        |        \\\r       /           |            \\\r    /              |                \\\r(5,15)          (30,70)         (80,110)\r               /   |  \\              |\r            /      |    \\            |\r         /         |      \\          |\r   (35, 40)    (45,50) (55, 65)   (90, 100)\r boo == true\rfind(root, 45, 100) == true\rfind(root, 30, 100) == false\rfind(root, 30, 70) == true\rfind(root, 70, 30) == false", "k": ["boolean function find", "returns true iff", "tree boolean find", "arbitrary tree starting", "node root"]}
{"i": "5650516169195520", "t": "Given a histogram chart with values say {5,4,3,6,0,1}. Get the total count required to completely melt the histogram. A column with value 5 has 5 blocks in it. Any block which has air on any of its side gets melted.\r Sample 1\r {5,4,3,6,0,1} - > {0,3,2,0,0,0}->{0,0,0,0,0,0} => count=2\r Sample 2\r {0,1,1,1,1,0} - > {0,0,0,0,0,0} => count=1", "k": ["sample", "histogram chart", "histogram", "count", "chart"]}
{"i": "5695660973096960", "t": "Write a recursive function:\rint sum( int x, int max )\r{\r  /* complete the code */\r}\rthat calculates the sum of the numbers from\u00a0x\u00a0to\u00a0max\u00a0(inclusive). For example,\u00a0sum (4, 7)\u00a0would compute\u00a04 + 5 + 6 + 7\u00a0and return the value\u00a022. The function must be\u00a0recursive\u00a0so you are not allowed to use any conventional loop constructs", "k": ["int max", "complete the code", "int", "int sum", "max"]}
{"i": "5706362689421312", "t": "Write a program fact.c that asks the user to enter an integer number N. The program then prints out the first N factorial numbers. Remember thatfac(1)=1, fac(n)=n*fac(n-1). You should use a function fac that is written recursively.\r   I cannot figure it out, please help me.", "k": ["user to enter", "enter an integer", "program fact.c", "integer number", "write a program"]}
{"i": "5694850432237568", "t": "#include <stdio.h>\r float add (float x, float y)\r{\r    return x + y;\r}\r int main()\r{\r    float a, b, r;\r    char op;\r    do {\r       printf(\"number  op  number?  \");\r       scanf(\" %f %c %f\", &a, &op, &b);\r       switch (op)\r       {\r           case '+' : r = add(a,b);\r                      break;\r           case 'q' : break;\r           default  : op='?';\r       }\r       if (op=='?')\r          printf(\"Unknown operator\\n\");\r       else if (op=='q')\r          printf(\"Bye\\n\");\r       else\r          printf(\"%f %c %f = %f\\n\", a, op, b, r);\r    }\r    while (op != 'q');\r     return 0;\r}\rThe program behaves like a calculator asking the user to type in binary expressions (like 2.5 + 3.7) and printing out the results. If the user enters 'q' for the operator (e.g. 0 q 0) then this is taken as a signal to stop the program.\rAdd a new function to the program that multiplies its two arguments together and returns their product. Then modify the switch statement so that the operator '*' causes this new product function to be called. Test the program by using a mixture of '+' and '*' calculations.\rAdd operators for subtraction ('-') and division ('/') and test your program again.\rWe introduce some special operators. Write functions to implement each of these (adding one at a time and testing after each new operator is incorporated into your calculator).\r Symbol       Description       Example       \rm    Minimum    2.3 m 1.7 = 1.7       \rM    Maximum    2.3 M 1.7 = 2.3", "k": ["float", "int main", "float add", "printf", "number"]}
