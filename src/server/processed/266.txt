{"i": "5007980722388992", "t": "Implement an algorithm to print all possible valid combinations of braces when n pairs of paranthesis are given.\r I tried this code executing. I checked with System.out.println statements too. But I couldn't understand how this prints ( ( ) ). I have two questions. \r 1) If we give count as 2, this code should generate only ( )( ). But how does it go for another execution of whole addParen to generate (( ))\r 2) The second if block(that is, if(rightRem > leftRem) within the else block of allParen is always after if(leftRem > 0), then how come this is able to generate \r( ( ) )\r public static void addParen(ArrayList<String> list, int leftRem, int rightRem, char[] str, int count) {\r    \tif (leftRem < 0 || rightRem < leftRem) return; // invalid state\r \t\tif (leftRem == 0 && rightRem == 0) { /* all out of left and right parentheses */\r\t\t\tString s = String.copyValueOf(str);\r         //    System.out.println(str);\r\t\t\tlist.add(s);\r\t\t} else {\r\t\t\tif (leftRem > 0) { // try a left paren, if there are some available\r\t\t\t\tstr[count] = '(';\r \t\t\t\taddParen(list, leftRem - 1, rightRem, str, count + 1);\r\t\t\t}\r\t\t\tif (rightRem > leftRem) { // try a right paren, if there\u2019s a matching left\r\t\t\t\tstr[count] = ')';\r               // System.out.println(str);\r\t\t\t\taddParen(list, leftRem, rightRem - 1, str, count + 1);\r\t\t\t}\r\t\t}\r\t}\r \tpublic static ArrayList<String> generateParens(int count) {\r\t\tchar[] str = new char[count*2];\r\t\tArrayList<String> list = new ArrayList<String>();\r\t\taddParen(list, count, count, str, 0);\r \t\treturn list;\r\t}\r public static void main(String args[]) {\r ArrayList<String> list = generateParens(2);\r        for (String s : list) {\r            System.out.println(s);\r        }\r        System.out.println(list.size());\r }\r}", "k": ["string", "leftrem", "str", "count", "list"]}
{"i": "5181772279054336", "t": "What should be strategy to minimise the impact on external system which is using our table's data for processing?", "k": ["data for processing", "strategy to minimise", "minimise the impact", "impact on external", "external system"]}
{"i": "5612093642375168", "t": "You are given an array whose each element represents the height of the tower. The width of every tower is 1. It starts raining. How much water is collected between the towers?\rEg. [1,5,3,7,2] \u2013 then answer is 2 units between towers 5 and 7.", "k": ["element represents", "represents the height", "array", "element", "represents"]}
{"i": "5049143688953856", "t": "Can you predict the output of the following code?for (int i = 0; i < 101; i++) {\r\n\t\t\tif (i % 2 == 0) {\r\n\t\t\t\tSystem.err.print(i);\r\n\t\t\t} else\r\n\t\t\t\tSystem.out.print(i);\r\n\t\t}", "k": ["predict the output", "code", "int", "predict", "output"]}
{"i": "4949947124285440", "t": "a word is valid if the letters follow their natural order in it. abcd is valid, acde is valid aaaa is valid, acb is not valid. condition for valid: char1<=char2<=char3<=\u2026 given a length n find all valid words of length n.", "k": ["letters follow", "follow their natural", "natural order", "valid", "valid aaaa"]}
{"i": "6730434406776832", "t": "There are n items and v[i] is the value of i-th item. Now we want to convert value of i-th item to d[i],for each i from 0 to n-1 inclusive.\r For this conversion, at each step for particular i, we can decrease value of i-th item by 1 and value of j-th item is increased by 1 for each j not equal to i.\r It is possible for some of items to have negative value, but after all transformations all item should have positive value.\r Find minimum number of steps required for changing current values to one that is required. If it's impossible, print -1.\r Input:\r First line contains single integer n - the number of items. Second line contains n integers separated by single space - value of item. Next line contains n integers - value of item required.\r Constraints:\r 1 <= n <= 50\r 1 <= v[i], d[i] <= 50\r Example:\r input:\r 1\r 1\r 2\r output:\r -1\r input:\r 3\r 3 2 2\r 4 5 3\r output:\r 5", "k": ["i-th item", "item", "i-th", "input", "items"]}
{"i": "5388755342983168", "t": "What is spring Initialization Bean interface?", "k": ["initialization bean interface", "spring initialization bean", "initialization bean", "bean interface", "spring initialization"]}
{"i": "6660065662599168", "t": "suppose we have\r parent class \r   add( int , int)\r child class\r add(double, double )\r if we call child_instance.add( int, int), is it correct syntax?", "k": ["parent class add", "child class add", "class add", "int", "correct syntax"]}
{"i": "5502451717242880", "t": "what is generic Eraser in java?", "k": ["eraser in java", "generic eraser", "eraser", "java", "generic"]}
{"i": "6065401670664192", "t": "decide collection in java where you can store this range based search?\r age range :  group id\r0-25           :  1\r26: 50        :  2\r> 51            : 3\r best way to store this DS and In search input is age and we should get group id?", "k": ["decide collection", "collection in java", "range based search", "range based", "based search"]}
{"i": "6203218581258240", "t": "when to use serialization vs externalizable interface?", "k": ["externalizable interface", "serialization vs externalizable", "interface", "serialization", "externalizable"]}
{"i": "6097115709177856", "t": "If new object is created by thread then where object's attributes are going to be created? stack or heap?\r class Myclass{\r String data;\rMyObject object;\r public void mehtod(){\r   data = new String(\"ddd\");\r  object = new MyObject();\r  int i = 10;\r}\r Suppose now thread A creates object of this class and calls method() then where data, object and i will be created? heap or stack of thread?", "k": ["object", "object attributes", "created", "data", "string"]}
{"i": "5192526877163520", "t": "Given that logs are being generated by may web servers, design your logs processor, to optimize for the query \"get the count of the logs generated in the last 5 minutes\".", "k": ["web servers", "logs processor", "logs generated", "design your logs", "minutes"]}
{"i": "5885777548410880", "t": "You have been given a series of 'n' numbers and the series is in a random order. Write a program to find the median of the series with minimum complexity.", "k": ["random order", "series", "numbers", "order", "write a program"]}
{"i": "6461990360842240", "t": "Find the word in the given sentence.\ri)Check whether it exists\rii)If exist means return count and index.\r Ex:\rstring=\"CSK lost to RR\"\rsubstr=\"CSK\"\r CSK exist in above string.The substr CSK is presented  at the index of 0-2 in string.\r The count is 1.", "k": ["find the word", "csk", "find", "sentence", "check"]}
{"i": "5520035313352704", "t": "Remove the word in a Sentence with the given word\r Ex:\ri love you\ri)remove the word \"love\" in above\rii)insert the word \" hate\" in above\r op:\ri hate you\r[do this step by step]", "k": ["remove the word", "insert the word", "remove", "word", "sentence"]}
{"i": "6266328830705664", "t": "Finding the minimum in a BST. \r The known solution is\rpublic Node minimum(){\r\tNode current, last;\r\tcurrent = root;\r\twhile(current != null){\r\t\tlast = current;\r\t\tcurrent = current.left;\r\t}\t\r return last;\r}\r The above code doesn't find 0.5 as the minimum.\r 1 and 3 are children of 2, 0.5 is left child of 3 and 3.5 is right child of 3\r                                  2\r                               /    \\\r                           1          3\r                                     /    \\\r                                  0.5   3.5", "k": ["public node minimum", "bst", "current", "node minimum", "finding the minimum"]}
{"i": "5140428923863040", "t": "You have two arrays of integers, where the integers do not repeat and the two arrays have no common integers. \r Let x be any integer in the first array, y any integer in the second. Find min(Abs(x-y)). That is, find the smallest difference between any of the integers in the two arrays. \r Assumptions: Assume both arrays are sorted in ascending order.", "k": ["integers", "common integers", "arrays", "integer", "find"]}
{"i": "6639269430951936", "t": "Check if a binary tree is BST.\r I know the solution but I want to know will this code work\r public boolean IsBST(Node root){\r        if(root.left <= root && root.right > root){\r        IsBST(root.left);\r         IsBST(root.right);\r    }else{\r        return false;\r    }\r     return true;\r}", "k": ["tree is bst", "binary tree", "bst", "node root", "root.left"]}
{"i": "5579404646285312", "t": "Question 1 / 1 (Path Explosion EASY)\rYou were given a Binary Tree (not necessarily a Binary Search Tree) to play with, say T. T had some special properties\r Each internal node in T had exactly 2 children\rEach internal node in T was represented by an uppercase English alphabet (A-Z)\rEach leaf node in T was represented by a lowercase English alphabet (a-z)\rYou were told remember T as long as you could. Hence, you memorised the string formed by traversing T in post-order. You used something similar to the pseudocode below\r toPostOrderString (node)\r    if node is leaf\r        return node.value\r    else\r        T = \"\"\r        T = T + toPostOrderString(node.left)\r        T = T + toPostOrderString(node.right)\r        T = T + node.value\r        return T\rNow, time has come to use that string again. The Eye has contacted you. Yes, the secret organisation mentioned in \"Now you see me\" ( don't tell anyone they are real !! )\r You remember the string you memorised back then. You must reconstruct the binary tree T. You are also given a string A. All the characters of A are uppercase English alphabets. Let us assume that T has L leaves. Then, there will be exactly L paths from the root to the leaves - 1 unique path to each leaf.\r You have to tell The Eye the number of paths out of L, on which, A exists as a sub-sequence. Look at the explanation for the Sample Case 1 for clarity.\r You have to implement the method explodePaths in the code. explodePaths is passed the following parameters, respectively\r N, the number of nodes in T\rS, the string representation of the post-order traversal of T. Of course, the length of S will be equal to N.\rK, the length of the string A\rA, the string you must find in the paths from the root of T, to the leaves in T.\rNote\r It is not necessary that T is balanced. But, each internal node always has exactly 2 children. It is possible that both those children are internal nodes also. It is possible that only one of those children is an internal node.\rFor the given string S, because of the constraint that each internal node has exactly 2 children, you will always be able to determine the tree T, uniquely.\rIt is not necessary that all characters in T are unique. There may be several nodes with the same value.\rIn this problem statement, by sub-sequence we mean not necessarily contiguous. This is different from a sub-string.\rDo not print the answer in explodePaths. Just return the value. The code-template interviewstreet provides does the input and output itself.\rConsider the following tree\r    A\r  / \\\r t   B\r    / \\\r   /   \\\r  B     A\r / \\   / \\\rx   y a   b\rThis tree is given in Sample Case 1 as\r N = 9\rS = \"txyBabABA\"\rK = 2\rA = \"AA\"\rNow, there are 5 leaf nodes, and hence, 5 paths from the root to leaves - 1 for each leaf.\r - A-t\r- A-B-B-x\r- A-B-B-y\r- A-B-A-a\r- A-B-A-b\rOut of these 5 paths, you have to find the number of paths, on which \"AA\" exists as a sub-sequence. Of course, there are only 2 such paths\r - A-B-A-a\r- A-B-A-b\rHence the expected answer is 2.\r In the same T above\r The answer for A = \"BB\", is 2\rThe answer for A = \"BA\", is 2\rThe answer for A = \"AB\", is 4\rThe answer for K = 1 and A = \"A\", is 5\rThe answer for K = 1 and A = \"B\", is 4\rThe Sample Case 2 has a little more complicated T. The string S in Sample Case 2 is yeBgeuCBxAB.\r Constraints\r N \u2264 10000\rK \u2264 100\r\u200bThe expected time complexity of the algorithm is O(N).", "k": ["path explosion easy", "explosion easy", "binary search tree", "binary search", "search tree"]}
{"i": "6185570560638976", "t": "Given an integer N, print numbers from 1 to N in lexicographic order. \r Details: To be implemented without using character conversion (or Strings).\r Example: \rN = 25\r Print:\r1\r10\r11\r..\r19\r2\r20\r21\r..\r25\r3\r4\r5\r6\r7\r8\r9\r A simple solution using Strings (may not be acceptable):System.out.print(\"\\n\\tLexicographic Order\\n\\nEnter an integer: \");\r\n   Scanner input = new Scanner(System.in);\r\n   Integer n = input.nextInt();\r\n   List<String> list = new ArrayList<String>();\r\n       \r\n   for (int i = 1;i<n;i++){\r\n     list.add(\"\"+i);\r\n   }\r\n        \r\n  Collections.sort(list);\r\n        \r\n  for (String j: list){\r\n    System.out.println(j);\r\n  }", "k": ["print numbers", "list", "lexicographic order", "integer", "string"]}
{"i": "5221986057846784", "t": "arrange books in box, if box carry weight == books\rweight then take another box..... find the no of box required.", "k": ["box carry weight", "arrange books", "carry weight", "books weight", "box carry"]}
{"i": "5161719076749312", "t": "Given set of N threads generate sum of all numbers in an array of known size M", "k": ["threads generate sum", "threads generate", "generate sum", "set", "threads"]}
{"i": "6358834910068736", "t": "What is high dynamic range rendering and why is it important for realistic rendering?", "k": ["high dynamic range", "dynamic range rendering", "high dynamic", "dynamic range", "important for realistic"]}
{"i": "5764526326677504", "t": "Write a function to generate a second array of numbers containing running average of N elements from the original array\r So for instance if the original array is,\r2,6,4,2,3 and N=3\r result = 2,4,3,4,3\ryou can assume the corner elements can be filled with original elements where there are not enough elements to take avg of N elements", "k": ["original array", "write a function", "function to generate", "numbers containing running", "running average"]}
{"i": "5671617594130432", "t": "You have written a memory manager and after using it your coworker complains that he is facing severe issues of fragmentation. What could be the reason(s) and how can you fix it", "k": ["facing severe issues", "issues of fragmentation", "written a memory", "memory manager", "coworker complains"]}
{"i": "5858156613730304", "t": "Input - array of integers size N, integer Threshold.  Output - the number of pairs (x, y) of distinct elements with condition x + y <= Threshold. Is that possible to implement it with O(n) ?", "k": ["integer threshold", "integers size", "threshold", "array of integers", "input"]}
{"i": "4728339696713728", "t": "How do you check if a binary tree is balanced or not? Please traverse through this code and explain how the complexity is O(N).\r public boolean isBalanced(Node root){\r\tif(checkHeight(root) == -1){\r\t\treturn false;\r\t}else{\r\t\treturn true;\r\t}\r}\r private int checkHeight(Node root){\r if(root == null){\r\treturn 0;\r}\r int leftHeight = checkHeight(root.left);\rif(leftHeight  = -1   ){\r\treturn -1;\r}\r int rightHeight = checkheight(root.right);\rif(rightHeight = -1){\r\treturn -1;\r}\r int heightDiff = leftHeight  - rightHeight;\rif(Math.abs(heightDiff) > 1){\r\treturn -1;\r}else{\r\treturn Math.max(leftHeight, rightHeight) + 1;\r}\r }\r Please traverse for the following tree.\r \t\t\t\tA\r                              /       \\\r                            B         C\r                         /    \\       /    \\  \r                      D      E     F    G\r                                              \\\r                                              H", "k": ["node root", "return", "root", "binary tree", "checkheight"]}
{"i": "5399897561890816", "t": "Initially there is a number n written on board. Two players start playing a game turn by turn. Each player has to replace the number n written on the board by n-2^k (for some k >= 0 such that 2^k < n)?\r Also the number n-2^k has to be as beautiful as n (The beauty of a  number depends on the number of one's in its binary representation). The  player loses the game when he can't select any such k.\rGiven the initial number n, determine which player will win the game if both players play optimally. n > 0 and n <= 10^9.", "k": ["number", "number n written", "written", "game", "player"]}
{"i": "5782278500253696", "t": "Two numbers min and max age give. Generate all numbers between them without repeated digits.\r Example input:\r98 and 103\r output:\r98,102,103", "k": ["max age give", "age give", "min and max", "max age", "numbers min"]}
