{"i": "6203588688740352", "t": "What data structures will you use to implement a text editor. Size of editor can be changed and you also need to save the styling information for all the text like italic, bold etc.", "k": ["data structures", "text", "editor", "data", "structures"]}
{"i": "5194719929827328", "t": "finds a domino pattern for a \"double-N\" domino set that forms a loop / a ring using all available tiles.\rfor example,In a double-two domino set, with six tiles, (0 , 0) (0 , 1) (1 , 1) (1 , 2) (2 , 2) (2 , 0). So if parameter is 2, the function should return true. if no loop found, should return false.\r Dominoes are small rectangular game tiles divided into two squares and embossed with dots on the top surface of the tile. You can think of dots as integers. A double-N domino set consists of (N+1)(N+2)/2 tiles, e.g. a standard double-six domino set has 28 tiles (T): one for each possible pair of values from (0.0) to (6.6) - no pair of numbers occurs more than once.", "k": ["domino set", "domino", "set", "domino pattern", "double-two domino set"]}
{"i": "5728188153987072", "t": "You are given an array of non-negative integers (0, 1, 2 etc). The value in each element represents the number of hops you may take to the next destination. Write a function that determines when you start from the first element whether you will be able to reach the last element of the array. \r if a value is 3, you can take either 0, 1, 2 or 3 hops. \r For eg: for the array with elements 1, 2, 0, 1, 0, 1, any route you take from the first element, you will not be able to reach the last element.", "k": ["non-negative integers", "element", "array", "integers", "non-negative"]}
{"i": "5639820376276992", "t": "you have 2 lists of points\r- for one point in the first list, you have to find all the points in the second list that are in a certain radius with a fast algorithm", "k": ["fast algorithm", "points", "algorithm", "list", "find"]}
{"i": "5647972224204800", "t": "Input a matrics, print the elements one by one:right->left down->left->up. The 1st line is the matrics size, then follows the matrics elements. Ex:\r 5 3\r1 2 3 4 5\r6 7 8 9 10\r11 12 13 14 15\r First loop:\rstarts from the top left '1';\r1: to right, print 1,2,3,4,5\r2: to left down, print 9,13\r3: to left, print 12,11\r4: to up, print 6 ('1' has been print, ignore)\r Second round:\r1: to right, print 7,8\r2: no more elements to print\r So the elements should be:\r1,2,3,4,5,9,13,12,11,6,7,8", "k": ["print", "left", "elements", "matrics", "matrics elements"]}
{"i": "4922725080498176", "t": "We have a class as follows:public class People{\r\n   String name;\r\n   String position;\r\n   String sex;\r\n   ...\t\t\r\n   ...\r\n\t\t\t\r\n  public String getAttribute(String attrName){\r\n  /**\r\n  * This is a generic getter method that will give you   \r\n  *  any attribute value based on the passed attribute  \r\n  *  Name;\r\n   * for eg: getAttribute(\"name\") => will return the \r\n   * attriute(Name) value of the current object.\r\n   */\r\n    }\r\n}I now give you two List: \r   list1<People> friends;\r   list2<String> attributes;\r Using the generic getter method, we have to group \"friends\" on \"attributes\". Think of this as an implementation of GROUP BY function to be implemented on objects in list1 and to be grouped on entries in list2.\r eg: list2 = {sex, occupation}\r So objects in list1 will be grouped such that all Male-doctors together, Female-cops together, male-cops together, etc.", "k": ["public class people", "class people", "string", "string position", "public string getattribute"]}
{"i": "5646487138598912", "t": "you have numbers between 1 to n. a set of number i.e. (4,5) means that person number 4 is connected to person number 5. find all the ways the a group of n pepole can be connected. i.e. for 0 and 1 there is the empty set, for 2 there is 2 ways, empty set and {1,2} only for 3 there are 4 ways: {}, {(1,2)} {(2,3)}, {(3,1)} for 4 there are 10 ways ({},{(1,2)}, {(1,2),(3,4)},.......\r you can do it by factorial and cobination but there is another way that state that:\r T(n)=T(n-1) + (n-1)*T(n-2)\r(while T(n) is the function that computes the number of ways..\r Can someone explain why this equation is true?", "k": ["person number", "person", "number", "empty set", "set"]}
{"i": "5401343961333760", "t": "you have a numbers between 1 to n. a set of number i.e. (4,5) means that person number 4 is connected to person number 5. find all the ways the a group of n pepole can be connected. i.e. for 0 and 1 there is the empty set, for 2 there is 2 ways, empty set and {1,2} only  for 3 there are 4 ways: {}, {(1,2)} {(2,3)}, {(3,1)}\rfor 4 there are 10 ways ({},{(1,2)}, {(1,2),(3,4)},.......\r you can do it by factorial and cobination but there is another way that state that:\rT(n)=T(n-1) + (n-1)*T(n-2)\r(while T(n) is the function that computes the number of ways..\rcan someone explain why this equation is true?\rThanks...", "k": ["person number", "person", "number", "set", "empty set"]}
{"i": "5667340815433728", "t": "Chinese chess has 8*8=64 cells.And the point is (1,1),\uff081\uff0c2\uff09,..............(8,8\uff09.And the horse walks by diagonal line of  two cells from where point it is.Calculate the shortest step(s)  between two points for  the horse to walk. Eg. (1,1)  to (4,4). Horse  go like this (1,1)>(2,3)>(4,4)", "k": ["chinese chess", "shortest step", "diagonal line", "is.calculate the shortest", "horse walks"]}
{"i": "5664803295068160", "t": "Chinese chess has 8*8=64 cells.And the point is (1,1),\uff081\uff0c2\uff09,..............(8,8\uff09.And the horse walks by diagonal line of  two cells.Calculate the shortest step(s)  between two points for  the horse to walk. Eg. (1,1)  to (4,4). Horse  go like this (1,1)>(2,3)>(4,4)", "k": ["chinese chess", "shortest step", "diagonal line", "cells.calculate the shortest", "cells.and the point"]}
{"i": "5765078433398784", "t": "Jumper Game: A NxN grid which contains either of 0-empty, 1 - player 1, 2 - player 2. Given a position in the grid, find the longest jump path. For jump path, you can jump only diagonally, you can jump on opponent cell and also the landing cell should be empty. No opponent cell can be jumped more than once. Write a function which takes grid and a specific position in the grid, and returns the longest possible number of jumps in the grid. For Example:\r\nif grid = {\r\n\t\t\t{ 0,0,0,0,0,0 },\r\n\t\t\t{ 0,1,0,0,0,0 },\r\n\t\t\t{ 2,0,2,0,2,0 },\r\n\t\t\t{ 0,0,0,0,0,0 },\r\n\t\t\t{ 0,0,0,0,0,0 },\r\n\t\t\t{ 0,0,0,0,0,0 },\t\t\t\t\r\n\t};\r\nAnswer should be 2 - (1,1) -> (3,3) -> (1,5)", "k": ["jumper game", "player", "game", "grid", "jump path"]}
{"i": "5668212962230272", "t": "Given an array of integers.\r Move all non-zero elements to the left of all zero elements.", "k": ["array of integers", "integers", "array", "move all non-zero", "elements"]}
{"i": "5715650070708224", "t": "There's a new language which uses the latin alphabet. However, you don't know the order among letters.\r It could be:\ra b c d ...\r as it could also be:\r b e z a m i ...\r You receive a list of words lexicographically sorted by the rules of this new language. From this list, derive one valid particular ordering of letters in this language.", "k": ["latin alphabet", "alphabet", "language", "latin", "letters"]}
{"i": "5178432541425664", "t": "There are different buildings standing close to each other. These are of same width but different height.\rSuppose if rainfall happens, what will be the volume of  water that get trapped on top of all these buildings together. ?\r INPUT (Example)\r No: of buildings : 4\rheights of the buildings(in any units): 3 4 3 4", "k": ["buildings standing close", "standing close", "buildings standing", "buildings", "standing"]}
{"i": "5724853648752640", "t": "Design Maps: You have set of [lat, long] for all famous locations. Given your position [lat, long] return all famous locations within r radius of your position.", "k": ["design maps", "lat", "long", "famous locations", "maps"]}
{"i": "5705890831269888", "t": "You have set of [lat, long] of all famous locations. Given your position [lat, long] return all famous locations within radius r of your position", "k": ["famous locations", "lat", "long", "return all famous", "famous"]}
{"i": "6396093820567552", "t": "-How to mitigate that your software is the real one and not the stolen one.", "k": ["mitigate", "software", "real", "stolen"]}
{"i": "5097920225345536", "t": "How to steal a password when i have both public key and know the algorithm?", "k": ["steal a password", "public key", "algorithm", "steal", "password"]}
{"i": "6245147530493952", "t": "If i record the traffic when i write the username and password and redirect my page?", "k": ["redirect my page", "record the traffic", "write the username", "username and password", "password and redirect"]}
{"i": "5116202827382784", "t": "Given a number,print it in words.\r19621 -> One lakh ninety six thousand and twenty one.", "k": ["words", "number,print", "lakh ninety", "ninety six thousand", "thousand and twenty"]}
{"i": "5863307617501184", "t": "Given a array of positive integers, find all possible triangle triplets that can be formed from this array. \reg: 9 8 10 7 \rans: 9 8 10, 9 8 7, 9 10 7, 7 8 10\rNote : array not sorted, there is no limit on the array length", "k": ["positive integers", "triangle triplets", "array", "integers", "find"]}
{"i": "5631469919666176", "t": "Given an array of type:-\r1. Increasing\r2. Decreasing.\r3. Increase-Decrease\r4. Decrease-Increase\r Find:- 1. Type of array in minimum steps ?\r2. Maximum element from array in min steps?", "k": ["decreasing", "decrease-increase find", "array", "steps", "find"]}
{"i": "5164018295635968", "t": "Question was \"Given a pattern and a string input - find if the string follows the same pattern and return 0 or 1.\rExamples:\r1) Pattern : \"abba\", input: \"redbluebluered\" should return 1.\r2) Pattern: \"aaaa\", input: \"asdasdasdasd\" should return 1.\r3) Pattern: \"aabb\", input: \"xyzabcxzyabc\" should return 0.\r  I can think of a brute-force solution for this question where we add the character in the pattern and n length of the string to a hashmap and recurse over the pattern array and string. But is there anything more efficient? This was a pretty difficult question in my opinion.", "k": ["pattern", "return", "input", "string", "string input"]}
{"i": "5722969366069248", "t": "Given an array of integers when the difference between every two neighbored elements is either -1 or +1 or 0. \rWrite an efficient search algorithm to find a given number of x in the array.", "k": ["neighbored elements", "array", "array of integers", "integers", "difference"]}
{"i": "5686894862008320", "t": "Implement algo for ls command in unix. You have n ordered file names with you. You have to print file names in column then in rows. \r e.g. I have 5 files\rF1 F3 F5\rF2 F4\r Minimize on number of rows\rMaximize on number of columns\r Max Page Width possible P\rPage width of any row = max width of all files in first column + max width of all files in second column + ... +max width of all files in last column", "k": ["implement algo", "command in unix", "width", "page width", "max width"]}
{"i": "5701708741083136", "t": "You are given an mxn grid, where (0,0) refers top most left position and (m-1,n-1) the bottom most right. The grid is filled with ones. All positions in the grid that are blocked are filled with zeros. You are given this grid and are assured that there exists atleast one path from (0,0) to (m-1, n-1). Find the minimum distance of the path from (0,0) to (m-1, n-1) given that you are allowed to move only vertically, horizontally and diagonally", "k": ["refers top", "top most left", "left position", "mxn grid", "grid"]}
{"i": "6393228808945664", "t": "You have a set of N objects. Each of these objects have certain properties associated with them. A property is represented by a (key, value) pair. For example, assume you have the following two objects.\rTower:\r{\r\t(height, 100), (weight, 50),\r\t(xposition, 25), (yposition, 36)\r}\rTree:\r{\r\t(area, 100), (noofleaves, 500),\r\t(height, 25), (yposition, 36)\r}\rEach object you have, will have at most 4 properties. An object will have at least 1 property. Note, from the two objects above, that it is not necessary for key in the properties to be same for all the objects. Also, it is not necessary for the key to be different.\rNow, given N such objects, you wish to answer M queries. Each query is represented by a set of properties (again, at most 4 properties, and at least 1 property). The answer for the query is the number of objects in the set, that have all the given properties. Two properties are considered equal iff both the key and the value match.\rFor example, if you have the above two objects, then the answer for the following queries is\rQuery:\r{ (height, 100), (yposition, 36) }\rAnswer:\r1 // matches Tower, but not Tree\rQuery:\r{ (yposition, 36) }\rAnswer:\r2 // matches both Tower and Tree\rQuery:\r{ (height, 100), (noofleaves, 500) }\rAnswer:\r0 // neither Tower, not Tree satisfy both properties\rInput\rThe first line of input contains N and M. This is followed by the description of the N objects. The description of the i-th object will start by a number k, which is the number of properties associated with the object. The next k lines contain two space separated strings - the property key and the property value. Note that the property value is not necessarily an integer (although this is so for the example above).\rThis is followed by the description of M queries. The format of a query will be exactly same to that of the objects. Check the Sample Input for clarification.\rOne test file will contain only one test case. A single test case may contain several queries.\rOutput\rPrint M lines. Each line must be the answer of the respective query.\rConstraints\r1 \u2264 N \u2264 10000\r 1 \u2264 M \u2264 100000\r 1 \u2264 k \u2264 4\rSample Input\r2 3\r4\rheight 100a\rweight 50b\rxposition 25a\ryposition 36b\r4\rarea 100a\rnoofleaves 500\rheight 25\ryposition 36b\r3\rweight 80\rxposition 25a\ryposition 36b\r1\ryposition 36b\r2\rxposition 25a\ryposition 36b\rSample Output\r0\r2\r1", "k": ["yposition", "objects", "answer", "query", "properties"]}
{"i": "5682818938044416", "t": "You are given a rectangular grid with 2 rows and N columns. The top row is labeled 1 and the bottom row is labeled 2. The columns are labeled from 1 to N in increasing order. Each cell in the grid contains a single character.\rConsider a hamiltonian walk in this grid. Meaning, pick a starting cell, say (i,j), and consider a path that starts from (i,j) and goes through every cell in the grid exactly once. Note that you can only walk to adjacent cells, or cells that you share a common edge with. There may be several such paths. Let us concatenate the characters in the order in which the cells are visited during a walk. The string formed can be called the string for the walk.\rAmong all the possible walks, and their respective strings, find out the lexicographically smallest string. We know that the length of the strings are all the same - to be precise, 2N. Thus, the lexicographically smallest string is simply the alphabetically smallest string if you compare the characters from left to right.\rInput\r The first line of input contains a number T, the number of test cases. Then follow T test cases. Each test case contains 3 lines. The first line contains the number N, the number of columns in the grid. It is well known of course that the grid contains 2 rows. The next two lines contain the description of the grid in the form of two strings; the string of N characters in row 1 from left to right and the string of N characters in row 2 from left to right, respectively. Each character will be a lowercase engish letter.\rOutput\r Output a single line for each test case. The line must contain a string with 2N characters. This string should be the lexicographically smallest string for some hamiltonian walk in the grid.\rConstraints\r 1 = T = 100\r1 = N = 10\r Sample Input\r 2\r3\rabc\rdef\r10\rababaaabab\rbababababa\r Sample Output\r abcfed\raaababababababababab\r Explanation\r In the first test the possible strings are { abcfed, adebcf, adefcb, badefc, bcfeda, cbadef, cfedab, cfebad, dabcfe, dabefc, defcba, edabcf, efcbad, fedabc, fcbade, fcbeda }. The smallest string is abcfed.", "k": ["string", "smallest string", "grid", "lexicographically smallest string", "walk"]}
{"i": "5145121580384256", "t": "You have 81 balls. 80 balls have the same weight. 1 ball is the lightest one. What would be the minimum possible way to find the lightest ball ?\r(Use Dynamic Programming)", "k": ["dynamic programming", "lightest", "balls", "ball", "programming"]}
{"i": "5649261284818944", "t": "There are multiple rooms in a floor. There are one or more fire exits. Each door can be designed with an option of pull or push. For fire safety, a door should be designed so as to open (push) towards the fire exit.\r\nDesign a data structure to represent the floor and door design.  A person could start from any room and moves towards fire exit. Write an algorithm to check if all the doors are designed to be pushed towards fire exit.", "k": ["fire exit", "exit", "fire", "designed", "multiple rooms"]}
