{"i": "5101786763362304", "t": "The third question is a brain teaser: if 1000 couples are to give birth to male and female babies(50% change each), and they would keep giving birth until they have a girl, what's the boy to girl ratio in 20 years", "k": ["brain teaser", "female babies", "male and female", "give birth", "giving birth"]}
{"i": "5721204665090048", "t": "A parent array P is given where P[i] denotes the parent of the ith node in the tree(the tree is generic). Parent of root is indicated with -1. I need to find the height/depth of tree.            (Best sol in O(n))", "k": ["ith node", "parent array", "parent", "tree", "denotes the parent"]}
{"i": "5731557415321600", "t": "Given an array of object A, and an array of object B. All A's have \rdifferent sizes, and all B's have different sizes. Any object A is of the \rsame size as exactly one object B. We have a function f(A, B) to compare the\rsize of one A and one B. But we cannot compare between two A's or two B's. \rGive an algorithm to match each A with each B.", "k": ["array of object", "array", "object", "sizes", "size"]}
{"i": "5094190039957504", "t": "2.\r    String encode(List<String> input);\r    List<String> decode(String input);", "k": ["string", "list", "string encode", "string input", "input"]}
{"i": "5147519440912384", "t": "This is two questions I got from a google interview. Not very sure how to solve it. Any comments would be appreciated.\r     1.\r    interface RateLimit {\r        /** Sets the rate, from 1 to 1000000 queries per second */\r        void setQPS(int qps);\r         /** accept or reject a request, called when request is received */\r        boolean allowThisRequest();\r    }\r     brief example:\r    server instantiates your object, calls setQPS(1)\r    at at time t, user1 makes a request, allowThisRequest() returns true\r    at time t+0.01 sec, user2 makes a request, allowThisRequest() returns false\r    at at time t+1, user4 makes a request, allowThisRequest() returns true\r    at time t+5 sec, user3 makes a request, allowThisRequest() returns true", "k": ["google interview", "makes a request", "returns true", "makes", "request"]}
{"i": "5100378148306944", "t": "We have two strings A and B with the same super set of characters. We need to change these strings to obtain two equal strings. In each move we can perform one of the following operations:\r 1. swap two consecutive characters of a string  \r2. swap the first and the last characters of a string\r A move can be performed on either string.\rWhat is the minimum number of moves that we need in order to obtain two equal strings?", "k": ["super set", "strings", "obtain two equal", "characters", "string"]}
{"i": "5636152769904640", "t": "given n > 0 fair dice with m > 0 \"sides\", write an function that returns a histogram of the frequency of the result of dice rolls. For example, for two dice, each with three sides, the results are:\r (1, 1) -> 2\r(1, 2) -> 3\r(1, 3) -> 4\r(2, 1) -> 3\r(2, 2) -> 4\r(2, 3) -> 5\r(3, 1) -> 4\r(3, 2) -> 5\r(3, 3) -> 6\r And the function should return:\r 2: 1\r3: 2\r4: 3\r5: 2\r6: 1", "k": ["fair dice", "dice rolls", "write an function", "returns a histogram", "dice"]}
{"i": "5641959733460992", "t": "Given n rows of integers, such that the ith row (1 <= i <= n) contains i integers, find the path having the maximum weight.\rPath traversal rules:\r1. A valid path sequence would be top-down i.e. begins with the integer in the first row, and traverses all rows selecting only one integer in each row.\r2. From any jth integer in the ith row i.e row[i][j], traversal can happen either downward (i.e to row[i+1][j]) or diagonally downward to the right (i.e to row[i+1][j+1])\rThe weight of a Path is the sum of values of integers in the Path sequence.\rSample Input:\rNo. of Rows: 5\r4\r2 9\r15 1 3\r16 92 41 44\r8 142 6 4 8\r Expected Output: 4, 2, 15, 92, 142 (Max weight is 255)", "k": ["path", "row", "path sequence", "path traversal rules", "ith row"]}
{"i": "5141005317701632", "t": "Given two integer arrays. Find the Largest Common sub array. For example,\rarr1 = {1,2,3,2,3,2} arr2={2,2,3,3,4,5}, the largest common sub array is {2,2,3,3}", "k": ["largest common", "integer arrays", "common sub array", "find the largest", "largest"]}
{"i": "5717136156655616", "t": "int fun()\r\n{\r\n\t/*write code here.*/\r\n}\r\nint main()\r\n{\r\n\tint i=10;\r\n\tfun();\r\n\tprintf(\"%d\",i);\r\n}change the value of the i without changing code of the main function, assign 20 to i ?", "k": ["write code here.", "int fun", "write code", "code here.", "main function"]}
{"i": "5707979286380544", "t": "Question: Two players A and B are playing a game. Pots of gold, each with\rvarying number of coins are placed in a single line. The rules of the game are:\r1) Players play turn by turn.\r2) On each turn a player can pick a pot of gold from either end of the line. He\rgets all the gold in that pot. The next pot of gold on that end is now available\rfor picking.\rWhat is the maximum number of gold can the first player get ?", "k": ["gold", "question", "pot", "turn", "line"]}
{"i": "5633261887815680", "t": "a left grow binary tree. Describe as below. (Transform from A to B)\r A:                          B:\r       1                    1\r      / \\                  /\r     2   3                2 - 3\r    / \\                  /\r   4   5                4 - 5\r  / \\                  /\r 6   7                6 - 7\ra left grow binary tree. Describe as below. (Transform from A to B)\r A:                          B:\r       1                    1\r      / \\                  /\r     2   3                2 - 3\r    / \\                  /\r   4   5                4 - 5\r  / \\                  /\r 6   7                6 - 7", "k": ["grow binary tree", "left grow binary", "binary tree", "left grow", "grow binary"]}
{"i": "None", "t": "Given ~300k words with an average length of 7 in a file.\rAll words are dictionary correct words. \rPrint all the anagrams that are present in this list of words without repeating them. \r E.g. if the list has:\rACT\rBAT\rCAT\rTAB\rTAC\r print:\rACT, CAT, TAC\rBAT, TAB", "k": ["average length", "act bat cat", "bat cat tab", "cat tab tac", "words"]}
{"i": "5737398201745408", "t": "Design the algorithm and the system for a WebCrawler.\rThe webcralwler will be provided millions of URLs. The webpage will be downloaded and then parsed for more URLs. If more URLs are found then they should also be downloaded and parsed.\r He was interested in:\r1. Scale to handle millions of URLs\r2. What are the bottle necks in the system? How will you resolve them", "k": ["design the algorithm", "urls", "design", "webcrawler", "algorithm"]}
{"i": "5672363806949376", "t": "Design a vending machine", "k": ["design a vending", "vending machine", "design", "machine", "vending"]}
{"i": "5701363426131968", "t": "Given a sorted array with some sequenced numbers and some non-sequenced numbers. Write an algorithm that takes this array as an input and returns a list of {start, end} of all consecutive numbers. Consecutive numbers have difference of 1 only. \rE.g. of array:\r[4, 5, 6, 7, 8, 9, 12, 15, 16, 17, 18, 20, 22, 23, 24, 27]public class Range\r\n{\r\n\tprivate int begin;\r\n\tprivate int end;\r\n\tpublic int begin { get; set; }\r\n\tpublic int end { get; set; }\r\n}", "k": ["end", "numbers", "int end", "int", "sorted array"]}
{"i": "6261373407330304", "t": "1. Consider an ordinary binary min- heap data structure with n elements supporting the instructions INSERT and EXTRACT-MIN in O(lg n) worst case time.  Give a potential  function f such that the amortized cost of INSERT is  O(lg n) and the amortized cost of EXTRACT-MIN is O(1) , and show that it works.", "k": ["worst case time", "amortized cost", "ordinary binary min", "heap data structure", "insert"]}
{"i": "5704440333991936", "t": "Implementing Deque using 3 Stacks (Amortized time O(1))  , I can't solve this problem ??? \rAmortized time O(1) what is Amortized time O(1)) ????", "k": ["implementing deque", "amortized time", "solve this problem", "stacks", "amortized"]}
{"i": "5731622108266496", "t": "There are two coins that make 55 cents. If one of them is not nickle then what are the two coins?", "k": ["cents", "coins that make", "make", "coins", "nickle"]}
{"i": "5642792520908800", "t": "A bear have to climb a 60.5 feet long hill. It climbs 3 feet in every minute before it fall down for 2 feet. How long it will take to climb the hill?", "k": ["feet", "feet long hill", "hill", "feet long", "climb"]}
{"i": "5754885161091072", "t": "Create a random number generator within the given range? what if no range given?  it should not repeat the sequence of random numbers generator before and after JVM is re-booted?", "k": ["create", "create a random", "random number generator", "range", "random"]}
{"i": "5974850233434112", "t": "Create a random number generator within the given range or without range, it should repeat the sequence of random numbers generator before and after JVM is re-booted", "k": ["random number generator", "jvm is re-booted", "random number", "number generator", "repeat the sequence"]}
{"i": "4863869499473920", "t": "Colorful Number:\rA number can be broken into different sub-sequence parts. Suppose, a number 3245 can be broken into parts like 3 2 4 5 32 24 45 324 245. And this number is a colorful number, since product of every digit of a sub-sequence are different. That is, 3 2 4 5 (3*2)=6 (2*4)=8 (4*5)=20 (3*2*4)= 24 (2*4*5)= 40\rBut 326 is not a colorful number as it generates 3 2 6 (3*2)=6 (2*6)=12.\rYou have to write a function that tells if the given number is a colorful number or not.", "k": ["colorful number", "number", "colorful", "broken", "sub-sequence parts"]}
{"i": "6284835370827776", "t": "A string \"aBIY\" is said to be a well-ordered word as each of the letters are in sequential manner regardless of case. So, \"AbLe\"  is not a well-ordered word.\rYou are a anti-hacker. you have a number of character sequences. Your task is to generate all possible well-ordered word that can be generated by those numbers of given character sequences.", "k": ["well-ordered word", "sequential manner", "well-ordered", "word", "abiy"]}
{"i": "4825220967825408", "t": "Edge Detection:\rTwo-dimensional array representation of an image can also be represented by a one-dimensional array of W*H size, where W represent row and H represent column size and each cell represent pixel value of that image. you are also given a threshold X. For edge detection, you have to compute difference of a pixel value with each of it's adjacent pixel and find maximum of all differences. And finally compare if that maximum difference is greater than threshold X. if so, then that pixel is a edge pixel and have to display it.", "k": ["two-dimensional array representation", "represent column size", "two-dimensional array", "cell represent pixel", "array representation"]}
{"i": "5705581721550848", "t": "You're given a dictionary of strings, and a key. Check if the key is composed of an arbitrary number of concatenations of strings from the dictionary. For example:\r dictionary: \"world\", \"hello\", \"super\", \"hell\"\rkey: \"helloworld\" --> return true\rkey: \"superman\" --> return false\rkey: \"hellohello\" --> return true", "k": ["key", "return", "return true", "dictionary", "strings"]}
{"i": "5724955245281280", "t": "Given a set of equalities and inequalities like A=B,B=C,F=J and A!=C, etc in two separate arrays (equalities[] and inequalities[]) and a method, separate that returns the two objects, e.g. separate(A=B) will return A and B, write an algorithm to find whether the entire set is consistent in constant time.", "k": ["write an algorithm", "constant time", "algorithm to find", "consistent in constant", "separate arrays"]}
{"i": "5190004888305664", "t": "By saying that an algorithm runs in O(n) time in the worst case, what does we really mean?", "k": ["worst case", "algorithm runs", "time", "case", "algorithm"]}
{"i": "5106806204399616", "t": "Use the shorest unique prefix to represent each word in the array\rinput: [\"zebra\", \"dog\", \"duck\",\u201ddot\u201d]\routput: {zebra: z, dog: do, duck: du}\r [zebra, dog, duck, dove]\r{zebra:z, dog: dog, duck: du, dove: dov}\r [bearcat, bear]\r{bearcat: bearc, bear: \"\"}", "k": ["shorest unique prefix", "dog", "zebra", "duck", "array input"]}
{"i": "5680831603408896", "t": "Java: You're given a very large array of char's. Write a method to remove duplicates in the array, in place. Optimize for space complexity, not time complexity.", "k": ["java", "large array", "char", "array of char", "array"]}
