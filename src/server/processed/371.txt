{"i": "13548681", "t": "Question 1 / 1\rThere are K pegs. Each peg can hold discs in decreasing order of radius when looked from bottom to top of the peg. There are N discs which have radius 1 to N; Given the initial configuration of the pegs and the final configuration of the pegs, output the moves required to transform from the initial to final configuration. You are required to do the transformations in minimal number of moves.\r     A move consists of picking the topmost disc of any one of the pegs and placing it on top of anyother peg.\r    At anypoint of time, the decreasing radius property of all the pegs must be maintained.\r  Constraints:\r1<= N<=8\r3<= K<=5\r  Input Format:\rN K\r2nd line contains N integers.\rEach integer in the second line is in the range 1 to K where the i-th integer denotes the peg to which disc of radius i is present in the initial configuration.\r3rd line denotes the final configuration in a format similar to the initial configuration.\r  Output Format:\rThe first line contains M - The minimal number of moves required to complete the transformation.\rThe following M lines describe a move, by a peg number to pick from and a peg number to place on.\rIf there are more than one solutions, it's sufficient to output any one of them. You can assume, there is always a solution with less than 7 moves and the initial confirguration will not be same as the final one.\r Sample Input #00:\r  2 3\r1 1\r2 2\r Sample Output #00:\r  3\r1 3\r1 2\r3 2\r   Sample Input #01:\r 6 4\r4 2 4 3 1 1\r1 1 1 1 1 1\r Sample Output #01:\r 5\r3 1\r4 3\r4 1\r2 1\r3 1\r NOTE: You need to write the full code taking all inputs are from stdin and outputs to stdout\rIf you are using \"Java\", the classname is \"Solution\"", "k": ["peg", "pegs", "sample input", "configuration", "initial configuration"]}
{"i": "13597689", "t": "Hi all genius minds.\r I have a small algorithm question. Any help will be appreciated.\r Suppose there is a lake (some height lh) and then there are hills/mountains (with height from 0 to 9).\rAnd finally there is Dam. All the hills and the lake and the dam are on a n*m matrix.\r given the height of all points on matrix (lake and dam are also on one such point). find the minimum cost required to create a path from lake to dam so that dam can be filled with water.\rNow height of each point can be increased or decreased except the lake.\rwater can flow only along the adjacent points not along the diagonals. Water can flow from point A to adjacent point B iff heightA >=heightB\r -----------------------------------------------------------------------------------------\rIf we could only decrease the heights, this was a very easy question. but in current case heights can be decreased as well.\r How do we solve this.?\rPlease revert for any clearifiactions", "k": ["genius minds", "dam", "lake", "height", "point"]}
{"i": "13639665", "t": "Two sorted array. Find kth smallest element\rO(logK)", "k": ["sorted array", "logk", "array", "sorted", "find kth"]}
{"i": "13600676", "t": "out of N 2D points, Find k nearest points to origin\rI gave O(kLog(k)) solution", "k": ["find k nearest", "origin i gave", "nearest points", "klog", "solution"]}
{"i": "13639664", "t": "Given a matrix. Generate another matrix where each item M[i,j] is the sum of all elements in the matrix starting from origin and ending at i,j", "k": ["matrix", "matrix starting", "starting from origin", "origin and ending", "generate"]}
{"i": "13576701", "t": "Generate A to power B\rI gave O(Log(B)) solution", "k": ["log", "solution", "generate", "power", "gave"]}
{"i": "13603671", "t": "You have an API to predict stock values of a particular share,\rThe API is\rStockPrediction predict(int stockid);\rwhere \rclass StockPrediction{\rDate time:\rfloat value;\r}\r using this API develop another API which will suggest the best selling time and buying time of a share (you have to call the predict API N number of times and from the StockPredictions provide the best buy time and sell time for the stock)\r Your API can be BestTiming getBestTiming(int stockid);\rwhere\rclass BestTiming{\rStockPrediction bestselltime:\rStockPrediction bestbuytime:\r}\reg\r values -->  10     12         7          8          24          35          1              9\rtime ----->   9am  9.30    9.45    10am   11am   12am      3am        4am\r out put : buy the stock at 7 rs at 9.45 and sell it for 35 rupees at 12am\r (hint: go for the best solution which uses only three variable to get this result)", "k": ["int stockid", "api develop", "date time", "predict api", "besttiming getbesttiming"]}
{"i": "13630670", "t": "Integer Array A of size N. Your job is to fill integer array B of size N where B[i] = products of all elements in A except the one at index i.\r Simple solution prod = product of all elements in A\r B[i] = prod/A[i]\r Now to make it an interesting problem, can you solve it without using division operation?", "k": ["integer array", "fill integer array", "array", "size", "integer"]}
{"i": "13633667", "t": "Write a java program to do the breadth first search of a graph.", "k": ["write a java", "java program", "breadth first search", "write", "graph"]}
{"i": "13597683", "t": "unsorted integer array with values 1 to N-1 has one duplicate element in it.\r(N is the size of the array. max value is N-1 because of the duplicate element.)\rBest way to find the duplicate element? If possible O(log n)", "k": ["unsorted integer array", "unsorted integer", "duplicate element", "integer array", "duplicate"]}
{"i": "13625665", "t": "a cirle has points + and -  and sigma of all ponits >0 we have to find the point where if we start journey always gives + tive partial sum at any point on the circle", "k": ["tive partial sum", "tive partial", "start journey", "partial sum", "ponits"]}
{"i": "13561671", "t": "Given two BST print the element in sorted form\r complexity O(n) time maxm alloted space will be O(height of bigger tree)\r eg ;\r T13\r\n1       5T24\r\n2       6o/p 1 2 3 4 5 6", "k": ["time maxm alloted", "sorted form complexity", "maxm alloted space", "bst print", "time maxm"]}
{"i": "13618661", "t": "Design a File system for windows or linux machine. Use OO concepts.", "k": ["design a file", "file system", "linux machine", "system for windows", "windows or linux"]}
{"i": "13602674", "t": "Q1: Reverse a linked list without using recursion.\r1->2->3->4->5->6\rshould become \r6->5->4->3->2->1\r Q2: Then reverse every K elements of a linked list.\r1->2->3->4->5->6\rshould become\r3->2->1->6->5->4 \rfor k=3\r Ans1: I used this method, but when i try and run this back home, I am not able to print the reverse of the linked list even though the function looks good.\rIt goes on to print the linked list in the same way as it did earlier. (Now Solved)\r Can someone help me understand what is wrong here.\r//Figured out the error, look at the correction in comments below//\r Ans 2:  Working on it (Not Solved)//Reverse a linked list without recursion.\r\nclass link\r\n{\r\n\tint data;\r\n\tpublic link nextlink;\r\n\t\r\n\tlink(int d1)\r\n\t{\r\n\t\tdata = d1;\r\n\t}\r\n}\r\n\r\nclass List{\r\n\t\r\n\tlink head;\r\n\tlink revhead;\r\n\tList(){\r\n\thead = null;\r\n\t}\r\n\t\r\n\tboolean isEmpty(link head)\r\n\t{\r\n\t\treturn head==null;\r\n\t}\r\n\t\r\n\tvoid insert(int d1)\r\n\t{\r\n\t\tlink templink = new link(d1);\r\n\t\ttemplink.nextlink = head;\r\n\t\thead = templink;\r\n\t}\r\n\t\r\n\tvoid printlist(){\r\n\t\tlink head1 = head;\r\n\t\twhile(!isEmpty(head1))\r\n\t\t\t{\r\n\t\t\tSystem.out.print(head1.data + \" \");\r\n\t\t\thead1 = head1.nextlink;\r\n\t\t\t}\r\n\t\tSystem.out.println();\r\n\t\t\t}\r\n\t\r\n\tvoid reverse()\r\n\t{\r\n\t\tlink previous=null,temp=null;\r\n\t\twhile(isEmpty(head))\r\n\t\t{\r\n\t\t\ttemp = head.nextlink;\r\n\t\t\thead.nextlink = previous;\r\n\t\t\tprevious = head;\r\n\t\t\thead = temp;\r\n\t\t}\r\n\t\r\n\t\t}\r\n\r\n}\r\n\r\n\r\n\r\npublic class LinkedList {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t\r\n\t\tList list1 = new List();\r\n\t\t\r\n\t\tlist1.insert(10);\r\n\t\tlist1.insert(20);\r\n\t\tlist1.insert(30);\r\n\t\tlist1.insert(40);\r\n\t\tlist1.insert(50);\r\n\t\tlist1.printlist();\r\n\t\tlist1.reverse();\r\n\t\tlist1.printlist();\r\n\t\t}\r\n\r\n}", "k": ["linked list", "list", "head", "linked", "reverse"]}
{"i": "13604675", "t": "2.)  There is a paragraph of infinite length. WAP to find the length of words having maximum length of prefix.\r     Find out the complexity of the algorithm.", "k": ["length", "wap", "find", "infinite length", "paragraph of infinite"]}
{"i": "13576694", "t": "Amazon telliphonic 17 May, 2012\r 1.)  There is a sequence where aphabets are written like this..\r     a,b,c,d,.......,x,y,z,aa,ab,ac........,az,ba,bb,bc,bd......bz,ca,cb.........cz........,aaa,aab,aac.....aaz,............zzz,aaaa...........zzzz..... and so on..\r     WAP to find out the string value at kth position.\r      like if k= 28 the string on 28 will be \"ab\".", "k": ["amazon telliphonic", "amazon", "telliphonic", "wap to find", "written like this."]}
{"i": "13605668", "t": "What type of responsibilities are you seeking in a new role?  What is your career objective? Why PayPal/Ebay ?", "k": ["type of responsibilities", "role", "ebay", "career objective", "type"]}
{"i": "13602663", "t": "We have\rchar *p = \"abc\";\r I know we cant do p[0] = 'a'. What is the reason behind it?", "k": ["abc", "char", "reason"]}
{"i": "13597662", "t": "Given a set of numbers from 1 to n^2, generate subsets consisting of n numbers such that each subset has one and only one matching number from any other subset\r The max number of sub-sets is n squared + n\r An example is as follows:\rn = 3\rn squared set = 1, 2, 3, 4, 5, 6, 7, 8, 9\r sub-set 1 = 1, 2, 3\rsub-set 2 = 1, 4, 7\rsub-set 3 = 1, 5, 9\rsub-set 4 = 1, 6, 8\rsub-set 5 = 2, 5, 8\rsub-set 6 = 2, 4, 9\rsub-set 7 = 2, 6, 7\rsub-set 8 = 3, 6, 9\rsub-set 9 = 3, 5, 7\rsub-set 10 = 3. 4, 8\rsub-set 11 = 4, 5, 6\rsub-set 12 = 7, 8, 9", "k": ["generate subsets consisting", "generate subsets", "squared set", "subsets consisting", "matching number"]}
{"i": "13594680", "t": "given 2 unsorted integer arrays a and b of equal size. Determine if b is a permutation of a. Can this be done in O(n) time and O(1) space ?", "k": ["unsorted integer arrays", "unsorted integer", "equal size", "integer arrays", "unsorted"]}
{"i": "13584698", "t": "write a program to print the increasing order given the input :12/mar/2011..15/jan 1990,12/april/1985,23/dec/1960,11/sept/2004\rthe output will be", "k": ["write a program", "program to print", "print the increasing", "increasing order", "mar"]}
{"i": "13586687", "t": "swap every two bits in an unsigned char .. eg swap bits at 0 and 1st position, swap 2nd and 3rd position, swap 4th and 5th position etc ..", "k": ["unsigned char", "swap", "position", "char", "bits"]}
{"i": "13588688", "t": "Given two numbers \"a\" and \"b\" and an average formula (a+b)/2. Find one condition where it wont work. Also, give solution to it", "k": ["average formula", "numbers", "formula", "find one condition", "wont work"]}
{"i": "13584696", "t": "You have an array containing n integers. Find a triplet a,b,c st a < b < c and a appears before b and b before c in the array. Suggest a solution with complexity less than O(n2)", "k": ["find a triplet", "integers", "array", "suggest a solution", "find"]}
{"i": "13587680", "t": "How would you merge  two binary search tree's ?\r O(n) solution \r Gave them a soln to do inorder traversal for both trees and merge the two sorted lists and create a tree out of the new list", "k": ["binary search tree", "solution gave", "binary search", "inorder traversal", "sorted lists"]}
{"i": "13588681", "t": "How will you divide 100 such that you can make any number between 1 to 100 using them.\rAns 1,2,4,8,16,32,37 .How to prove this or get this GP any logic using proper mathematical proof...", "k": ["make any number", "divide", "proper mathematical proof", "ans", "make"]}
{"i": "13582682", "t": "We are given a binary search tree; we need to find out its border.\r So, if the binary tree is10\r\n       /         \\\r\n     50           150\r\n    /  \\            /    \\\r\n  25    75     200    20\r\n / \\           /            / \\\r\n15 35    120      155 250It should print out 50 25 15 35 120 155 250 20 150 10.\r If the binary tree is10\r\n           /         \\\r\n         50           150\r\n        /    \\         /\r\n      25     75     200\r\n     / \\       / \\\r\n    15 35  65 30It should be like 50 25 15 35 65 30 200 150 10.\r How can this be done? ?", "k": ["binary search tree", "binary tree", "search tree", "tree", "binary search"]}
{"i": "13544679", "t": "given an array find the set of  consecutive numbers which gives the maximum sum\r I/P 1 3 -5 15 1 11 -15 18\ro/p : 15+1+11 gives the maximum sum\r          the code should return 15,1,11\r   can u tell me the logic??\r Thanks in advance", "k": ["maximum sum", "code should return", "array find", "find the set", "set of consecutive"]}
{"i": "13544678", "t": "This was asked at Innovation labs (ILabs) Bangalore (24/7 Group Company.)\rThere is a river with N number of stones at different distance from the shore and you are on the shore. You need to cross the river by moving on each stone. Constraint here is, your next jump should be  of {N, N-1, N+1 } any 1 from this 3.  Sample input given is {1,2,3,5 ,8} These are the stone distances from the shore. So lets say if he jumps to 1, the next jump has to be, N+1=2, N-1=0 or N. Write a algorithm to find all the possible ways to cross the river and best among that.\rI know that this needs to done with Dynamic programming using recursion. Can somebody write ?", "k": ["group company", "innovation labs", "asked at innovation", "bangalore", "group"]}
{"i": "13491687", "t": "You are given a function getInorderSuccessor which takes a BST (Binary Search Tree) as it's parameter. Every node has an extra pointer \"next\" , which is intialized to null, fill next with node pointers which represent Inorder Successor.\r  In a binary tree, inorder successor of a node is the next node in inorder traversal of the binary tree. Inorder successor is NULL for the last node in inorder traversal.\r  In BST, inorder successor of an input node can also be defined as the node with the smallest key greater than the key of input node. So, it is sometimes important to find next node in sorted order.\r   Sample Input : \r Sample output. \r The value of the node pointed by the next pointer is marked in { }\r  NOTE: The preorder of the tree you return would be printed to help you in debugging", "k": ["binary search tree", "binary search", "inorder successor", "search tree", "node"]}
