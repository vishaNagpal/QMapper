{"i": "14087830", "t": "How would you implement Singleton pattern in a multi-threaded environment?", "k": ["implement singleton pattern", "implement singleton", "singleton pattern", "multi-threaded environment", "singleton"]}
{"i": "14384707", "t": "A link list is given with two pointer, 1st is pointing to next node and another is random pointer. Random pointer is  pointing to any node of LL. WAP to create a copy of LL, without changing original list and in O(n).", "k": ["random pointer", "link list", "pointer", "pointing", "random"]}
{"i": "14204716", "t": "WAP to implement ftoa function.", "k": ["implement ftoa function", "wap to implement", "ftoa function", "wap", "implement ftoa"]}
{"i": "14378696", "t": "In how many ways,  8 black and 8 white coins can be placed in 8x8 chess board.", "k": ["chess board", "white coins", "black", "white", "chess"]}
{"i": "14384697", "t": "write a function/procedure, it should detect and report all UN-USED FUNCTIONS (i.e functions are defined but not called) in a C++ class(i.e suppose you are developing  a c++ editor for code compilation) -- MS bing", "k": ["editor for code", "code compilation", "detect and report", "report all un-used", "un-used functions"]}
{"i": "14113732", "t": "You are given a tree with N nodes. Every node in the tree has a given weight. Your goal is to divide the given tree in two trees by removing exactly one edge such that the difference of sum of weights in the new trees is minimum.\rInput\r First line contains integer T, the number of test cases. First line of each test case contains integer N, the number of nodes. Next line contains the N integers, weight of node 0, 1 .. N - 1. The next N - 1 line contain two space separated integers x and y, describing an edge, where x and y are 0 based indices for nodes in the tree.\rConstraints\r T <= 100, N <= 1000\rOutput\r Output a single line for each test case, which contains the min absolute difference between the sum of the nodes of the two trees.\rExample\r Input:\r2\r3\r8 7 8 \r1 0\r2 1\r9\r5 5 4 1 8 8 3 5 2 \r1 0\r2 0\r3 1\r4 1\r5 3\r6 0\r7 5\r8 1\r Output:\r7\r13\r Author: \txyler\rDate Added: \t15-07-2012\rTime Limit: \t10 sec\rSource Limit: \t50000 Bytes\rLanguages: \tADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.0.0-8, CPP 4.3.2, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAR, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYTH, PYTH 3.1.2, RUBY, SCALA, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC", "k": ["line", "tree", "nodes", "test case", "trees"]}
{"i": "14366778", "t": "Two numbers are called friendly if they share a digit. For example 1239 and 9760 are friendly where as 1234 and 9876 are not. You are given N numbers and you have to calculate the count of pairs of numbers that are friendly.\rInput\r First line of input contains an integer T, the number of test cases. For each test case, the first line contains N, the number of integers given. The next N lines contain N integers.\rConstraint\r T <= 10, N <= 10 ** 4, Each given number is between 1 and 10 ** 18\rOutput\r For each test case, print a line containing the count of pairs of number that are friendly.\rExample\r Input:\r2\r5\r2837 2818 654 35 931\r5 \r183 665 908 774 362\r Output:\r6\r3\r Author: \txyler\rDate Added: \t15-07-2012\rTime Limit: \t1 sec\rSource Limit: \t50000 Bytes\rLanguages: \tADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.0.0-8, CPP 4.3.2, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAR, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYTH, PYTH 3.1.2, RUBY, SCALA, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC", "k": ["share a digit", "test case", "called friendly", "friendly", "number"]}
{"i": "14381708", "t": "WAP to reverse the bits in integer (inplace)!!!\re.g i/p: 1011  o/p 1101", "k": ["wap to reverse", "bits in integer", "reverse the bits", "inplace", "wap"]}
{"i": "14382698", "t": "WAP which print its source code as its output!!!:)", "k": ["wap which print", "print its source", "source code", "wap", "output"]}
{"i": "14108696", "t": "devise an algorithm to color the graph in such a way that no two adjacent vertices have same color.You have to color them with any of the two colors say red or green?what will the time and space complexity of the solution.", "k": ["devise an algorithm", "red or green", "adjacent vertices", "time and space", "space complexity"]}
{"i": "14380687", "t": "find a number a matrix a[m][n] where all the rows and columns are sorted non-decreasingly.What will be the complexity of the solution.", "k": ["find a number", "columns are sorted", "number a matrix", "rows and columns", "find"]}
{"i": "14204704", "t": "find the balance index of an array where balanced index i is defined as the one whose left sum is equal to the right sum of the index . \ri.e \rsummation (1 to i-1) = summation (i+1 to length of an array) firdt I gave o(n2) solution , but then before i could give O(n) solution it was time up for me, \rO(n) solution will be we have to loop through i = 1 to N and find if ( sum of array - sum of array (1 to i-1 ) =   ( sum of array - sum of array (1 to i+1 )  the return i.\rYour thoughts?", "k": ["sum of array", "firdt i gave", "array", "sum", "left sum"]}
{"i": "14383694", "t": "there are N people in a room one of them is a celebrity .At least one person knows other but all knows celebrity.Celebrity doesnt know any one.There is an api isKnown(a,b) which returns true if a knows b.y.\rI gave the O(n2) answer.\rBut I think this can be done in O(n) .We have to compare call isKnown(a[i],a[i+1]) && iskNown(a[i+1],a[i]) returns true remove both frmo the array else remove that a[i] which return true, this will reduce the array to the celebrity. order will be O(n) then.Your thoughts ??", "k": ["celebrity.celebrity doesnt", "returns true", "returns true remove", "api isknown", "isknown"]}
{"i": "14366760", "t": "Print list ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'] in 3 columns.\rExample output:\ra e i \rb f  j\rc g \rd h", "k": ["print list", "columns", "print", "list", "output"]}
{"i": "14366758", "t": "User inputs a series of numbers and terminates the series by a zero. Your program should find the first three maximum values in the series and exclude them from the series and compute the average of the remaining numbers. (excluding zero as well)\rEx - 3, 7, 12, 2, 25, 8, 9, 13, 10, 0\rFirst three maximum numbers = 25, 13, 12\rAverage of the rest = (3 + 7 + 2 + 8 + 9 + 10) / 6 = 6.5", "k": ["user inputs", "series", "terminates the series", "numbers", "average"]}
{"i": "14106706", "t": "User inputs a sequence of digits. Every digit is a keystroke, that is equivalent to some character out of a sequence of characters. Digit zero and five mean NULL. The table is given below\r0 - NULL             \r1 - v, t, f, r, q        \r2 - f, t, k               \r3 - w, z, b, g            \r4 - r, s                  \r 5 - NULL\r 6 - f, i, r\r7 - p\r8 - l, o\r9 - p\r Generate all possible character sequence for a given sequence of digits.\rEx - If the user input 9801, your program should generate\r{plv, plt, plf, plr, plq, pov, pot, pof, por, poq} (not necessarily in this order).\r This problem is somewhat similar to the SMS problem. It basically boils down to generating a cartesian product of the character sets corresponding to keys.", "k": ["null", "sequence", "character", "generate", "digits"]}
{"i": "14382680", "t": "There is an interesting game named one person game. It is played via a m*n grids. There is an non-negative integer in each grid. At first your score is 0. You cannot enter a grid with integer 0. You can start and end the game at any grid you want (of course the number in the grid cannot be 0). At each step you can go up, down,left and right to the adjacent grid. The score you can get at last is the sum of the grids on your path. But you can enter each grid at most once.\r The aim of the game is to get your score as high as possible.\r Input:\rThe first line of input is an integer T the number of test cases. The first line of each test case is a single line containing 2 integers m and n which is the number of rows and columns of the grids.  Each of next the m lines contains n space-separated integers D indicating the number in the correspoding grid\r Output:\rFor each test case output an integer in a single line which is maximum score you can get at last.\r Constraints:\rT is less than 7.\rD is less than 60001.\rm and n are less than 8.\r Sample Input:\r4\r1 1\r5911\r1 2\r10832 0\r1 1\r0\r4 1\r0\r8955\r0\r11493\r Sample Output:\r5911\r10832\r0\r11493", "k": ["interesting game named", "grid", "named one person", "number", "game"]}
{"i": "14366746", "t": "A set of integer values are being received (1 per day). Store these values and at any given time, retrieve the min and max value over the last k days. What structures would you use for storing and retrieving ?", "k": ["set of integer", "received", "retrieve the min", "set", "integer"]}
{"i": "14108676", "t": "Given Preorder and postorder traversals of a tree. Device an algorithm to constuct a fully binary tree from these traversals.", "k": ["preorder and postorder", "preorder", "postorder traversals", "traversals", "tree"]}
{"i": "14108668", "t": "How to find the path to a node of a non-binary tree? It's easy if it's a binary but here it's non-binary.", "k": ["find the path", "non-binary tree", "tree", "non-binary", "find"]}
{"i": "14232667", "t": "c", "k": []}
{"i": "14370736", "t": "#include <iostream>\r\nusing namespace std;\r\n\r\nclass base{\r\npublic:\r\nvirtual void func(int i,int j=10)\r\n{\r\ncout<<\"base func\"<<endl;\r\n}\r\n};\r\n\r\n\r\nclass der:public base\r\n{\r\npublic:\r\nvoid func(int i,int j)\r\n{\r\ncout<<\"der \"<<j<<\" func\"<<endl;\r\n}\r\n};\r\n\r\n\r\nint main()\r\n{\r\nder dd;\r\nbase *bb = new der();\r\nbb->func(10);\r\ndd.func(10,1);\r\n}What is the output of this.", "k": ["virtual void func", "int i,int", "void func", "int main", "namespace std"]}
{"i": "14372746", "t": "Remove duplicates from min-heap.", "k": ["remove duplicates", "duplicates from min-heap", "remove", "min-heap", "duplicates"]}
{"i": "14188720", "t": "Given positive integers from 1 to n, find out the number of ways of selecting k numbers that\radd up to n, where k itself can range from 1 to n.", "k": ["positive integers", "numbers that add", "selecting k numbers", "find", "positive"]}
{"i": "14085859", "t": "Find the kth smallest element in an array. How can we do it without sorting the array.", "k": ["kth smallest element", "find the kth", "kth smallest", "smallest element", "array"]}
{"i": "14369707", "t": "Given a String, write a routine that converts the string to an long, without using the built in Java functions that would do this.  Describe what (if any) limitations the code has.  For example:\rlong StringToLong(String s)\r{\r        /* code goes here to convert a string to a long */\r}\rvoid Test()\r{\r   long i = StringToLong(\"123\");\r   if (i == 123)\r       ... success ...\r   else\r       ... failure ...\r}", "k": ["built in java", "java functions", "write a routine", "string", "java"]}
{"i": "14371713", "t": "Implement insert and delete in a tri-nary tree.  Much like a binary-tree but with 3 child nodes for each parent instead of two -- with the left node being values < parent, the right node values > parent, and the middle node values == parent.  For example, if I added the following nodes to the tree in this", "k": ["implement insert", "insert and delete", "tri-nary tree", "parent", "implement"]}
{"i": "14182784", "t": "Find all unique pairs of element in an array that sum to S. For ex. If array = {2,4,6,4,6} and S = 8 then answer is {(2,6), (4,4)}", "k": ["find all unique", "unique pairs", "pairs of element", "find", "unique"]}
{"i": "14371708", "t": "Given a dictionary of words, two APIs\rIs_word(string)\rIs_prefix(string)\rAnd a NxN matrix with each postion consisting of a character. If from any position (i,j) you can move \rin any of the four directions, find out the all the valid words that can be formed in the matrix.\r(looping is not allowed, i.e. for forming a word position if you start from (i,j) and move to (i-1,j) then \rfrom this position you cannot go back to (i,j))", "k": ["string", "postion consisting", "nxn matrix", "prefix", "character"]}
{"i": "14098832", "t": "Given a newspaper and a set of \u2018l\u2019 words, give an efficient\ralgorithm to find the \u2018l\u2019 words in the newspaper.", "k": ["give an efficient", "efficient algorithm", "algorithm to find", "words", "give"]}
