{"i": "12217186", "t": "The glasses are arranged in the following order1\r\n    2     3\r\n  4    5     6\r\n7    8     9    10\r\n....................\r\n....................When you pour liquid into the 1st glass if it's full, then the extra liquid would be flown into the glasses 2 and 3 in equal quantities. When glass 2 is full, the extra liquid would be flown into 4 and 5 and so on.\rGiven an N liters of liquid and capacity of each glass is C and the number of levels of glasses is L. Give the amount of liquid present in each glass if you empty N liters of liquid by pouring into glass 1.", "k": ["liquid", "glass", "extra liquid", "glasses", "full"]}
{"i": "12217041", "t": "Given an inorder traversal only for a binary tree (not necessarily a\rBST), give a pseudo code to generate all possible binary trees for\rthis traversal sequence.\r Firstly, how many binary trees can be generated given an in-order\rtraversal? I know that given 'n' nodes, number of BTs possible is\r(2^n)-n. But if we are given a specific in-order sequence, can we cut\rdown on this number?", "k": ["necessarily a bst", "give a pseudo", "pseudo code", "code to generate", "binary trees"]}
{"i": "12267020", "t": "You are given two numbers in the form of linked list.Add them without reversing the linked lists. linked lists can be of any length.\rEx:123 1->2->3\r10234 1->0->2->3->4\rans: 10357  1->0->3->5->7", "k": ["linked lists", "linked list.add", "linked", "lists", "numbers"]}
{"i": "12267019", "t": "You have n strings with their lengths. You are given an add(string s1,string s2) which would concatenate the string s2 with s1 and return s3. Optimize the cost of concatenation of all these strings into one big string.\rEx: 1,3,2 are the lengths of given strings.\r1+3=4\r4+2=6\rtotal cost=10\rOptimize this total cost?", "k": ["optimize", "strings", "string", "cost", "lengths"]}
{"i": "12270917", "t": "Given: Suppose balanced binary tree(T) is given.\rDef'n: sum of the tree is defined as sum of the values of all it's nodes.\rQuestion: Write a method which returns sub-tree whose sum is maximum.", "k": ["suppose balanced binary", "suppose balanced", "balanced binary tree", "balanced binary", "suppose"]}
{"i": "12150672", "t": "You have a room-full of balances and weights. Each balance weighs ten pounds and is\r considered perfectly balanced when the sum of weights on its left and right sides are \r exactly the same. You have placed some weights on some of the balances, and you have placed \r some of the balances on other balances. Given a description of how the balances are arranged\r  and how much additional weight is on each balance, determine how to add weight to the balances \rso that they are all perfectly balanced.\r There may be more than one way to balance everything, but always choose the way that places additional weight on the lowest balances.\r The input file will begin with a single integer, N, specifying how many balances there are.\rBalance 0 is specified by lines 1 and 2, balance 1 is specified by lines 3 and 4, etc...\rEach pair of lines is formatted as follows:\r WL <balances>\rWR <balances>\r WL and WR indicate the weight added to the left and right sides, respectively.\r <balances> is a space-delimited list of the other balance that are on that side of this balance.\r  <balances> may contain zero or more elements.\r Consider the following input:\r 4\r0 1\r0 2\r0\r0 3\r3\r0\r0\r0\r Balance 0 has balance 1 on its left side and balance 2 on its right side\rBalance 1 has balance 3 on its right side\rBalance 2 has three pounds on its left side\rBalance 3 has nothing on it\r Since balance 3 has nothing on it it is already perfectly balanced, and weighs a total of 10 pounds.\rBalance 2 has no other balance on it, so all we need to do is balance it by putting three pounds on its right side. Now it weighs a total of 16 pounds.\rBalance 1 has balance three on its right side, which weighs 10 pounds, so we just put 10 pounds on its left side. Balance 1 weighs a total of 30 pounds.\rBalance 0 has balance 1 on its left side (30 pounds), and balance 2 on its right side (16 pounds), we can balance it by adding 14 pounds to the right side.\r The output should be N lines long, with the nth line listing the weight added to the nth balance, formatted as follows:\r <index>: <weight added to left side> <weight added to right side>\r So the output for this problem would be:\r 0: 0 14\r1: 10 0\r2: 0 3\r3: 0 0", "k": ["balance", "balances", "side", "pounds", "weight"]}
{"i": "12174302", "t": "Rotate a n*n (square) matrix by 90 degrees.", "k": ["square", "degrees", "rotate", "matrix"]}
{"i": "12266664", "t": "You are given a list of points in the plane, write a program that \routputs each point along with the three other points that are closest \rto it. These three points ordered by distance. \rThe order is less then O(n^2) . \r For example, given a set of points where each line is of the form: ID \rx-coordinate y-coordinate \r  1  0.0      0.0 \r2  10.1     -10.1 \r3  -12.2    12.2 \r4  38.3     38.3 \r5  79.99    179.99 \r  Your program should output: \r  1 2,3,4 \r2 1,3,4 \r3 1,2,4 \r4 1,2,3 \r5 4,3,1", "k": ["points", "write a program", "plane", "write", "list"]}
{"i": "12209675", "t": "Implement a single-word division:\ri.e., you are given a long integer X having 'n' limbs (32-bit words) and you need to divide X by another 32-bit int 'b'\r optimize your solution for time. Can you do this better if you know that 'b' divides 'X' exactly ?\r what if 32-bit division on the target architecture is expensive ? try to minimize the # of integer '/' and '%' ops (e.g., using floating-point tricks)", "k": ["implement a single-word", "optimize your solution", "solution for time", "single-word division", "long integer"]}
{"i": "12120026", "t": "Ph.Intvw 2\rcoding: find a given value/node in a BST\rnode find(node *n, int x)\rfollow up : \rfind a value that is closest (arithmetically) from a given value/node, same signature as above", "k": ["bst node find", "bst node", "node find", "find", "node"]}
{"i": "12208945", "t": "Ph.Intvw 2\rwrite code to calculate number of words in a large text file\rfile i/o language specific implementation details not required\rwhat are the corner cases? cover all the corner cases like beginning/ending with space, multiple spaces etc", "k": ["language specific implementation", "specific implementation details", "large text file", "text file file", "write code"]}
{"i": "12120025", "t": "Ph.Intvw 2\rModify the Stack DS to implement constant time Min lookup", "k": ["time min lookup", "modify the stack", "constant time min", "min lookup", "implement constant time"]}
{"i": "12238917", "t": "Ph.Intvw 2\rOODesign: Design a parking lot", "k": ["design a parking", "ph.intvw", "oodesign", "parking lot", "design"]}
{"i": "12208944", "t": "Ph.Intvw 1\rWrite code to print all the paths in a binary tree, whose values sum up to the value given\rroot and the sum given\rsignature: void sum (Node *node, int sum)\rfollow up question: now change the algo to the same thing for any arbitrary path\rarbitrary path: can start from anywhere (not necessarily root) - can end anywhere (not necessarily leaf)", "k": ["arbitrary path arbitrary", "path arbitrary path", "write code", "follow up question", "arbitrary path"]}
{"i": "12244910", "t": "Ph.Intvw 1\rWhat data structure will you use to design a phonebook\rWhat is its time complexity for retrieving, adding etc\rright answer: a hashtable with key contactname and value being the head pointer to a list of contacts with that contact name [multiple contacts with same name]", "k": ["complexity for retrieving", "multiple contacts", "data structure", "design a phonebook", "time complexity"]}
{"i": "12208943", "t": "Ph.Intvw 1\rWhat happens when  you do www.amazon.com\rwhat exactly happens at the dns server, etc etc, details of the protocol used \u2026.\r wanted all the details", "k": ["dns server", "ph.intvw", "server", "details", "dns"]}
{"i": "12244744", "t": "You have to design a system for finding the run time puncture of a car. Give a robust and simple design.", "k": ["run time puncture", "system for finding", "finding the run", "run time", "time puncture"]}
{"i": "12244667", "t": "During my 2nd interview\r1. Use 2 stacks to create a queue structure\r2. If you have a tree how to verify it a BST\rA. User the inorder traversal\r3. Write a code to implement above question 2.", "k": ["interview", "stacks to create", "queue structure", "create a queue", "user the inorder"]}
{"i": "12230872", "t": "Given a large buffer which contains almost infinite number of words. You are given an API \"char* getNextWord(int* len)\". You need to find all the words & their frequency in the buffer.\rFor eg. char* buff = { \"I\", \"AM\", \"Programmer\", \"AM\", \"I\", \"Boy\" ....}.. then\rOutput = I = 2, AM =2, Programmer =1, boy =1.", "k": ["infinite number", "programmer", "boy", "large buffer", "words"]}
{"i": "12226889", "t": "Check weather a tree is a sum tree ...\rSum tree is a tree whose root value is equal to the sum of its adjecnt children", "k": ["check weather", "sum tree", "tree", "sum", "weather a tree"]}
{"i": "12219210", "t": "given a 10 digit number,find the greatest continuous 4 digit number.\rEx:9164352435 \rAns : 9164", "k": ["digit number", "greatest continuous", "digit number,find", "number,find the greatest", "digit"]}
{"i": "12228870", "t": "I want to build a system with the following APIs :\r1. put(n) - stores data in the system\r2. get() - will give me the element added the first and so on. \rI gave a queue implementation using the LinkedList (using a head and tail pointers). Interviewer asked the complexity of both put and get operations and asked how I would implement \"removeElement(n)\" - now, given a linkedlist/array implementation of a queue, removeElement(n) is going to be O(n) worst case operation, I could not find any other options.", "k": ["build a system", "apis", "system", "removeelement", "build"]}
{"i": "12179308", "t": "How to find Hexadecimal for a 32-digit integer", "k": ["integer", "find hexadecimal", "hexadecimal", "find"]}
{"i": "12226861", "t": "From two lists/arrays find duplicates. I gave two answers :\r1. Sort them both  O(n log n) \r2. Use a hash table with key as the number in the array and a counter to increment occurences. O(n) to traverse both lists and increment the counters in the hashtable -", "k": ["arrays find duplicates", "find duplicates", "arrays find", "duplicates", "find"]}
{"i": "12219054", "t": "Reverse n-Ary Tree and Return List of Leaf Nodes as Output \r example \r Tree will be like\r                                  1\r                               /  |   \\\r                             2    3   4\r                          /          /  \\\r                       5            6    7\r                     /                     \\\r                    8                        9\r out put will be  1st reverse the tree e.g. 2 points to 1  , 5 points to 2 , 8 poinst to 5 and so on for each node , without modifying the tree and then return list containing leaf node\ras  OutPut Head->  8->3->6->9->NULL \r do it efficiently , i saw a approach & code here but i think its not correct , guys can you make it correct ?", "k": ["reverse n-ary tree", "return list", "output head", "leaf nodes", "leaf node"]}
{"i": "12215810", "t": "why is string immutable?", "k": ["string immutable", "immutable", "string"]}
{"i": "12151821", "t": "Implement level search in a binary tree.", "k": ["implement level search", "implement level", "binary tree", "level search", "implement"]}
{"i": "12193798", "t": "Life cycle of servlet", "k": ["life cycle", "cycle of servlet", "life", "servlet", "cycle"]}
{"i": "12151693", "t": "You are given a binary Tree B and pattern p = LLRLR. Let S = ppppp\u2026 be a sequence generated from the given pattern p. If \u2018L\u2019 denotes left traversal to node from its parent node and \u2018R\u2019 denote right traversal to node from its parent node find in B the largest of all such sequences.\r Note: Only the Head will have neither 'L' or 'R'\r An easy way is to record a path till you reach a NULL node and search for S in the recorded path, but that would be an O(n^2) algorithm, you are expected to give an O(n) algorithm where n denotes the number of nodes in B\r Your algorithm should cater to all possible patterns.", "k": ["binary tree", "llrlr", "tree", "node", "parent node"]}
{"i": "12199863", "t": "Given two integers a and b. Find the value of a/b without using division or modulo operators in C/C++.\rI tried with repeated subtraction of b from a, but the interviewer felt that this approach is inefficient. Any better approach ?", "k": ["integers", "approach", "division or modulo", "modulo operators", "find"]}
