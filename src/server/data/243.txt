{"i": "5640295119060992", "t": "given a double linked list and an array of nodes in that dll\uff0coutput number of clusters. example: dll: n1 n2 n3 n4 n5; array: n1 n4 n5; output 2( (n1) (n4 n5))"}
{"i": "5394358983458816", "t": "given string of chars\uff0cfind way to compress consecutive char with no ambiguity. example\uff1adaaad\rto d4*ad; 5eeeecd to 5*14*ecd"}
{"i": "4861339986034688", "t": "Lucky numbers are those numbers which contain only \"4\" and/or \"5\". For example 4, 5, 44, 54,55,444 are lucky numbers while 457, 987 ,154 are not.\r Lucky number sequence is one in which all lucky numbers exist in increasing order for example 4,5,44,45,54,55,444,445,454,455...\r Now we concatenate all the lucky numbers (in ascending order) to make a lucky string \"4544455455444445454455...\"\r Given n, your task is to find the nth digit of the lucky string. If the digit is 4 then you have to print \"Hacker\" else you have to print \"Earth\".\r Input:\rfirst line contain number of test cases T , next T line contain a single interger n.\r Output:\rFor each test case print \"Hacker\"(without quotes) if nth digit of lucky string is \"4\" else print \"Earth\"(without quotes) if nth digit of lucky string is \"5\". \r Constraints:\r1<=t<=10^5\r1<=n<=10^15"}
{"i": "5245749356920832", "t": "Problem Statement\rThere are three types of tickets and stations available in CodeCountry A, B and C. Tickets of type A can only be bought at stations of type A and end at a station of type B. Tickets of type B can only be bought at stations of type B and end at a station of type C. Similarly, tickets of type C can only be bought at stations of type C and end at a station of type A. Also, you can only travel from station i to station j if j > i, i.e. you can only move forward and if the ticket type bought at station i ends at station j.\rThe cost of a ticket is j x j if you travel a distance of j. For example if you start at Station 3 and end at station 5 the cost is 2 x 2=4.\rNow, you want to travel from Station 1 to Station N using trains in CodeCountry. You are given the type of each station. Output the minimum cost of the journey.\rNote that station N will also have a type and you must reach it using a ticket of compatible type. Output -1 if it is not possible to reach from station 1 to station N\r Input Format\rThe first line contains the number of test cases T. This is followed by T lines one for each test case.\rEach test case consists of a string representing the types of each station. The i-th character of the string represents the i-th station's type.\r Output Format\rOutput the minimum cost of the journey, one line per test case.\r Constraints\rThe number of test cases is atmost 50.\rThere will be atleast 2 stations and atmost 15 stations.\rThe first station (station 1) is always of type A."}
{"i": "5352828797190144", "t": "Write a routine that does secret santa in O(N) time. I don't really understand what it means by 'does secret santa' actually."}
{"i": "5694959181103104", "t": "How would you design a social network and find or keep track of someone's oldest friend in a social network? Oldest friend means the friend that you have added for the longest time period. My solution to the first question is to represent friendship in a graph , storing a list of friends in each User object, and use breadth-first-search to find connection. Not sure about the second question though. My idea is either keep a reference to the oldest friend as a member field, or have a double linked list of users sorted by the start date of friendship."}
{"i": "5076459865505792", "t": "i have an array{{1,2,3},{4,5,6},{7,8,9}}.I want output=1,2,4,3,5,7,6,8,9"}
{"i": "5840928073842688", "t": "We have a list of N nodes with each node pointing to one of the N nodes. \rIt could even be pointing to itself. We call a node \u2018good\u2019, \rif it satisfies one of the following properties:\r * It is the tail node (marked as node 1)\r* It is pointing to the tail node (node 1)\r* It is pointing to a good node\r You can change the pointers of some nodes in order to make them all \u2018good\u2019. \rYou are given the description of the nodes. \rYou have to find out what is minimum number of nodes that you have to change in order\rto make all the nodes good.\r Input:\rThe first line of input contains an integer number N which is the number of nodes. \rThe next N lines contains N numbers, \rall between 1 and N. \rThe first number, is the number of the node pointed to by Node 1; \rthe second number is the number of the node pointed to by Node 2; \rthe third number is the number of the node pointed to by Node 3 and so on.\r N is no larger than 1000.\r Output:\rPrint a single integer which is the answer to the problem\r Sample Input 1:\r5\r1\r2\r3\r4\r5\r Sample output 1:\r4\r Explanation:\rWe have to change pointers for four nodes (node #2 to node #5) to point to node #1. \rThus 4 changes are required\r Sample input 2:\r5\r5\r5\r5\r5\r5\r Sample output 2:\r1\r Explanation:\rWe have to just change node #5 to point to node #1 (tail node) which will make node #5 good.\rSince all the other nodes point to a good node (node #5), every node becomes a good node."}
{"i": "6228597727559680", "t": "Generate MAX_INT (Max signed int value) using bitwise operators. Should work in 32 and 64 bit processors"}
{"i": "6533979565981696", "t": "By mistake I wrote the following program and it compiles and runs without any error in gcc compiler. enter code here\r #include<stdio.h>\r#include<stdlib.h>\rint main()\r{\rint i,**data;\rdata=(int **)malloc(sizeof(int)*1000000);\rfor(i=0;i<1000000;i++)\rdata[i]=(int *)malloc(sizeof(int)*1000000);\rprintf(\"done\\n\");\rreturn 0;\r}\rBut I don't understand how is it allocating an array of 1000000*1000000 bytes,almost equivalent to 1TB??"}
{"i": "6051283794395136", "t": "Given 2D matrix of chars, you can find substring by moving in any [of 8]direction inside the range.\rGet the list of sorted palindromes without duplicate which are available inside all possible substring in the Matrix."}
{"i": "5627710193795072", "t": "Find the digits count in the number from Range 0-n\rFor Example: Input range 0-10\rcount[0]=2\r.\r.\r.\rcount[9] =1"}
{"i": "5940623425142784", "t": "I have declared one double pointer character array as given below:\rchar **errorcode;\rso how to initialize this array with NULL.\rand pass to other function?????"}
{"i": "6084051676954624", "t": "There are 2 arraylists each consisting of 1 million records.\rGive me the same objects present in both the lists.\rThe objects in the list can be any thing of our choice."}
{"i": "5971029612560384", "t": "Imagine you're designing a Web Service for a phone application that returns a list of suggested Words that may complete a given string the user types.\r For example, if the user writes \"ap\", a list of suggested words may contain [\"apple\", \"application\", \"aptitude\", ...].\rAssume English only words and no misspelling.\r I gave a solution with tries and interviewer asked for an alternative solution (I was thinking something along the lines of hashing but time ran out and I couldn't put together anything concrete). I mentioned a couple ways I could optimize my idea, but felt short on that area. For example, ways to return smaller lists, ranking, caching, etc."}
{"i": "6331397635571712", "t": "Determine if a tree is a valid BST with no duplicated values. (This means that if the binary tree has a duplicated number it should return \"invalid\" even if it's an actual BST)\r I gave an O(n) solution and interviewer seemed happy with it."}
{"i": "6696054317645824", "t": "You have a plain with lots of rectangles on it, find out how many of them intersect"}
{"i": "4601987345678336", "t": "Sort a list of numbers in which each number is at a distance k from its actual position"}
{"i": "6361609643491328", "t": "Store a set of sudden-death tournament results in a compact format (eg. a bit array) and a set of predicted match results (also in a bit array). Score the predictions, giving one point per correctly guessed match, without unpacking the bit array into a more convenient format (ie. you have to traverse the tree in-place)."}
{"i": "5570154410803200", "t": "Implement a simple regex parser which, given a string and a pattern, returns a boolean indicating whether the input matches the pattern. By simple, we mean that the regex can only contain special character: * (star), . (dot), + (plus). The star means what you'd expect, that there will be zero or more of previous character in that place in the pattern. The dot means any character for that position. The plus means one or more of previous character in that place in the pattern."}
{"i": "6666552321507328", "t": "1. find all the combinations of a string in lowercase and uppercase. For example, string \"ab\" -> \"ab\", \"Ab\", \"aB\", \"AB\". So, you will have 2^n (n = number of chars in the string) output strings. The goal is for you to test each of these string and see if it match a hidden string."}
{"i": "4582840347918336", "t": "int[] first = {3};   // size 1\rint[] second = new int[3];    // size 3\rsecond[0] = 2;\rsecond[1] = 4;   //2,4\r Second array has enough space to hold all elements of first and second array, where both the arrays are merged. Now write code to have first array into second.\r The following Cracking the coding interview code doesn't work.\r \tpublic static int[] merge2(int[] first, int[] second){\r\t\tint lastA = first.length-1;  //0\r\t\tint lastB = second.length-1;   //2\r\t\tint indexMerge = (lastA + lastB);\r\t\twhile(lastA >= 0 && lastB >= 0){\r\t\t\tif(first[lastA] > second[lastB]){\r\t\t\t\tsecond[indexMerge] = first[lastA];\r\t\t\t\tindexMerge--;\r\t\t\t\tlastA--;\t\t\t\t\r\t\t\t}else{\r\t\t\t\tsecond[indexMerge] = second[lastB];\r\t\t\t\tindexMerge--;\r\t\t\t\tlastB--;\r\t\t\t}\r \t\t}\r \t\twhile(lastA >= 0){\r\t\t\tsecond[indexMerge] = first[lastA];\r\t\t\tindexMerge--;\r\t\t\tlastA--;\r\t\t}\r\t\treturn second;\r\t}"}
{"i": "4944704227508224", "t": "remove duplicates of a linkedList\rfollow up, can you do it without an extra buffer (or temporal storage )"}
{"i": "5779108998938624", "t": "Implement an algorithm to delete a node in the middle of a single linked list, given"}
{"i": "6387185636868096", "t": "Implement an algorithm to find the nth to last element of a singly linked list."}
{"i": "6502347131846656", "t": "You have 2 list with a single digit only. representing a number.  Return a list with the result of adding both list."}
{"i": "5288679434092544", "t": "Reverse of a LinkedList\r follow up\rCan you do it recursively?"}
{"i": "6172012607176704", "t": "Steps Problem, \rGivin n, find how many different ways you can take steps to reach the top\rE.g.\rfindSteps(4)\r1,1,1,1\r1,1,2, \r2,2\r1,3,\r4\r this would return 5"}
{"i": "5424568206360576", "t": "Struct node{\r\tnode *pNext;\r\tnode *pRandom;\r};\r You have a link list of the above node structure. pRandom has connection to any random nodes.\rWrite a program to clone this list.\rnote:You should not add any new items to node"}
{"i": "6221192969060352", "t": "Write a program to find the GCD of two numbers"}
