{"i": "16324665", "t": "Q .2 candles each burns for 1 hr each ,calculate 45 min time \rby burning them in one go .\r Ans : \rburn the first candle from both the side, parallel to first one , burn the other from single side only, once the first is burnt completely 30 mins are over and second is already half burned .\rnow start burning the second one from the other side .\r you have 45 mins calculated.\r !!! Bam !! again kid stuff !!"}
{"i": "16390665", "t": "Remove duplicates from an array say {1,2,7, 9, 9, 5, 4, 9} and create a new array and put the values in the new array. Note: Not to use any collection classes. Space and time complexity needs to be considered."}
{"i": "16425697", "t": "what is the probability of 5 people with different ages sitting in ascending or descending order at a round table."}
{"i": "16274733", "t": "waf to rotate array by k unit\rsize of array n=6\r1 2 3 4 5 6\rk=2\routput\r5  6 1 2 3 4"}
{"i": "15813742", "t": "find the next greatest number that can be form by same digit of the given number .. \rsample test case \rinput \r4765\routput \r5467"}
{"i": "16181731", "t": "waf to swap kth node from first with kth node form last ..\rexample\rif k=3\rlink list input\r1->2->3->4->5->6->7.\routput linked list\r1->2->5->4->3->6->7"}
{"i": "16425693", "t": "given 4 points, whose x and y coordinates are both integers. they are all different. write a function to check if they form a square.\r i forgot to point out that the points can be given in any order"}
{"i": "16436689", "t": "wap to find the  longest arithmetic sequence in given array... return number of element in seriese...\r simple test case..\rsizeofarray=4\rarray element \r3 4 5 8\routput \r3\rsample test case\rsize of array =10\rarray element..\r-1 1 3 7 11 15 19 20 21 22\routput \r5"}
{"i": "16343721", "t": "waf for a linked listed .. \rshift all digit to first then consonant then vowel ..\rsuch that list contain only one time one digit , consonant , vowel .. \rList *(List *head);\rinput :\r2->a->5->a->2->b->o->n->5->n.\routput..\r2->5->b->n->a->o.."}
{"i": "16181719", "t": "wap to take one rotate a square matrix anticlock wise by 90 degree and add a particuler number after rotation  to each prime column. \rfunction prototype should be.. \rvoid rotate(int a[][],int size, int keytobeadded);...\rsample test case.... \rinput \rsize=3\rkeytobeadded=5;\rsquare matrix :\r1 2 3\r4 5 6\r7 8 9\routput should be\r3 11 9\r2 10 8\r1 9    7..........."}
{"i": "15943711", "t": "Write a program that outputs all possible strings formed by using the characters 'c', 'a', 'r', ' b', ' o', and 'n' exactly once. Also write complexity."}
{"i": "16288703", "t": "people are asked to dress in blue and green for a party. People who come in blue colour are assigned \"1\" and people who come in green are assigned \"2\". So the sequence would be something like 121111222212121212....\r Now we need to split the group in x subgroups where the size of each subgroup can take values from given set [3,4,5,6....] and all the members of the group should be in some subgroup. however the ordering of the group should be intact(cannot switch positions). write algorithm/code which splits the group into the required x subgroups where the sum of squares of the differences of 1's and 2's in each sub group is a minimum."}
{"i": "16458685", "t": "Replace bit n to bit m of an integer 'a' with bit n to bit m from another integer 'b'.\re.g. a = 00000000 00000000 10101010 00110011\r        b = 1111111  11110000  10010011 00000001\r        n = 9, m = 16\rAnswer : a = 00000000 00000000 10010011 00110011"}
{"i": "16392679", "t": "In an interview I was asked a question on strings. The problem is given a string s1= \"ABCDBCCDABCD\". and a pattern \"BC\". we have to replace this pattern with other string (\"UVW\" or \"U\"or \"uv\"). Do this without creating new string.\rTake the case to   replace \"BC\" with  following \r a) \"uvw\"   s1=AUVWDUVWCDAUVWD .\r b)  \"U\"    s1=AUDUCDAUD .\r c)  \"UV\"   s1=AUVDUVCDAUVD .\r  This was my first question and I was stuck on this. :("}
{"i": "16392674", "t": "user inputs values which must be stored. The duplicates must be ignored without scanning the array/list. is there a method to do this?"}
{"i": "16457663", "t": "Write an efficient function that returns the n\u2019th Fibonacci number (There are many ways to solve this problem. Please write the most efficient method possible).  Each Fibonacci number is the sum of the last two.  The first 10 are: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55.\r   long getNthFibonacci(long i) { ... }"}
{"i": "15871751", "t": "Setup:\rAssume primitive Facebook. FB has Members.\rclass Member {\r    String name;\r    String email;\r    List<Member> friends;\r}\r Question: \rCode printSocialGraph(Member m). Direct friends of m are Level 1 friends. Friends of friends are level 2 friends.....and so on\rPrint level 1 friends first. Then print level 2 friends....and so on\r void printfriendsByLevel(Member m){\r       //Your code here\r }"}
{"i": "16389667", "t": "Let's say we're developing a vector graphics application. It will allow the user to create lines, rectangles, circles, text, etc. and manipulate them independently - move them, resize them, etc. Design an object model for this application. (How would you model the representation of the document in an object oriented language? What classes would you define? What methods would you have? What would your API look like?)"}
{"i": "15790667", "t": "write a function that print TRUE if (){}[] are balanced in expression .. otherwise return FALSE.\r[{()}] currect.. priority of [ >}>)..........it should be preserved\r....................................................................................\r void check(char *a)\r{\r      struct s\r     {\r            char ch;\r            s*next;\r     };\r            s *st=NULL;\r            s*node=NULL;\r            if(a=='\\0')\r            {\r                  cout<<\"TRUE\";\r                  return ;\r            }\r            else\r            {\r                while(a[0]!='\\0')\r                {\r                              {\r                                node=(s*)malloc(sizeof(s));\r                                    char c=a[0];\r                                    switch(c)\r                                    {\r                                                case '[':\r                                                     if(st==NULL)\r                                                     {\r                                                                  node->ch=c;\r                                                                 node->next=NULL;\r                                                                 st=node;\r                                                                 a++;\r                                                      } \r                                                     else\r                                                     {\r                                                         if(st->ch=='('||st->ch=='{')\r                                                         {\r                                                                        cout<<\"FALSE\";\r                                                                        return ;\r                                                         }\r                                                         else\r                                                         {\r                                                          node->ch=c;\r                                                          node->next=st;\r                                                          st=node;\r                                                          a++;\r                                                         }\r                                                     }\r                                                     break;\r                                                case '{':\r                                                     if(st==NULL)\r                                                     {\r                                                                 node->ch=c;\r                                                                 node->next=NULL;\r                                                                 st=node;\r                                                                 a++;\r                                                     } \r                                                     else\r                                                     {\r                                                         if(st->ch=='(')\r                                                         {\r                                                                        cout<<\"FALSE\";\r                                                                        return ;\r                                                         }\r                                                         else\r                                                         {\r                                                             node->ch=c;\r                                                             node->next=st;\r                                                             st=node;\r                                                             a++;\r                                                         }\r                                                     }\r                                                      break;\r                                                case '(':\r                                                     if(st==NULL)\r                                                     {\r                                                                 node->ch=c;\r                                                                 node->next=NULL;\r                                                                 st=node;\r                                                                 a++;\r                                                     } \r                                                     else\r                                                     {\r                                                              node->ch=c;\r                                                             node->next=st;\r                                                             st=node;\r                                                             a++;\r                                                      }\r                                                      break;\r                                                case ')':\r                                                     if(st==NULL||st->ch=='{'||st->ch=='[')\r                                                     {\r                                                                 cout<<\"FALSE\";\r                                                                        return ;\r                                                     } \r                                                     else\r                                                     {\r                                                         if(st->ch=='(')\r                                                         {\r                                                                        s *newnode=st;\r                                                                        st=st->next;\r                                                                        free(newnode);\r                                                                        a++;\r                                                         }\r                                                      }\r                                                      break;\r                                                case '}':\r                                                     if(st==NULL||st->ch=='('||st->ch=='[')\r                                                     {\r                                                                 cout<<\"FALSE\";\r                                                                        return ;\r                                                     } \r                                                     else\r                                                     {\r                                                         if(st->ch=='{')\r                                                         {\r                                                                        s *newnode=st;\r                                                                        st=st->next;\r                                                                        free(newnode);\r                                                                        a++;\r                                                         }\r                                                      }\r                                                      break;\r                                                case ']':\r                                                     if(st==NULL||st->ch=='{'||st->ch=='(')\r                                                     {\r                                                                 cout<<\"FALSE\";\r                                                                        return ;\r                                                     } \r                                                     else\r                                                     {\r                                                         if(st->ch=='[')\r                                                         {\r                                                                        s *newnode=st;\r                                                                        st=st->next;\r                                                                        free(newnode);\r                                                                        a++;\r                                                         }\r                                                      }\r                                                      break;\r                                                default :\r                                                        a++;\r                                                        if(a[0]=='\\0')\r                                                        {\r                                                                      cout<<\"TRUE\";\r                                                                      return ;\r                                                          }\r                                                        break;\r                                     }\r                              }\r                }\r                 if(st==NULL&&a[0]=='\\0')\r                 {\r                                      cout<<\"TRUE\";\r                                      return ;\r                 }\r                 if(st!=NULL)\r                 {\r                                       cout<<\"\\nFALSE\";\r                                      return ;\r                 }  \r            }\r }"}
{"i": "16182668", "t": "write a funtion to shift all vowel in first and all consonant in last . Order of all vowel  and consonant should should preserved ."}
{"i": "16171693", "t": "You are given the task of creating the address book application for a smart phone. There are some\rof the top level features you must implement.\r1.There will be 1000+ phone book entries and user must get very quick response.\r2.On default screen it shows the names of all people in alphabetical ascending order.\r3.Using the search option, user can search and it will show only those names starting\rwith those characters which are typed in the search box.\rYou are supposed to compare two different data structures and list down the pros and cons of each\rand finally recommend the best suited data structure."}
{"i": "16377675", "t": "Highly coupled code is code where the dependencies between classes are dense, lots of things\rdepend on other things. This kind of program is hard to understand, tough to maintain, and tends\rto be fragile, breaking easily when things change.\rSimplistically, we can say that class A is statically coupled to class B if the compiler needs the\rdefinition of B in order to compile class A. Moreover dependencies among them are transitive.\rThat is if A depends on B and B depends on C, then A also depends on C\rCreate a program logic/pseudo code which can print the \"expanded dependency tree\" given a set\rof input per class dependencies. Make sure that there are no duplicates in the output\rInput\rA -> B,C\rB->C,E\rC->G\rD->A,F\rE->F\rF->H\rOutput\rA depends on B C E F G H\rB depends on C E F G H\rC depends on G\rD depends on A B C  E F G H\rE depends on F H\rF depends on H"}
{"i": "16142677", "t": "Given an virtual 4x4 boggle board, and some 4 letter words, determine if the words are in the board \rex. \r S M E F\rR A T D\rL O N I\rK A F B\r STAR- no\rTONE- no\rNOTE- yes\rSAND- yes\retc."}
{"i": "16432668", "t": "1)Given binary tree find the min weighted node. ? \rMin weighted node is one which has minimun sum,where sum = Rootnode.getdata + leftnode.data + rightnode.data.\rimplement the method to achieve the above,,,"}
{"i": "16173689", "t": "how would u implement a function tat would generate x object 20% of the time , y object 10% of the time,z  object 70% of the time?\rWhich data structure would u use to pass this information to the function from the main.?"}
{"i": "16273666", "t": "What is deque ? - double ended queue\rWhich data structures would u use to implement deque ?\rComplexities of each data structure?\rImplement it using array such tat all the operations are O(1).\roperations are - insert at beginning,insert at end, delete at beginning ,delete at end.\rHow would u achieve this.?\rWrite interface and code to do the above.?"}
{"i": "15909674", "t": "Given an array of N positive integers, N being even, and a number K, find out if it is possible\rto form pairs of the numbers present in the array such that the sum of numbers in each pair is\rdivisible by K."}
{"i": "16240680", "t": "Alice and Bob are playing a game. The game is played as follows :\r- There are N piles of coins on the table. Pile i has A[i] coins.\r- In each turn, each player can pick up 1 or more coins from the leftmost non-empty pile.\r- If a player picks up a coin from pile i , all coins from piles 0 to i-1 should have been taken.\r- The person who picks up the last coin loses the game.\rAlice and Bob play the game alternately. Alice plays first. Given the number of piles N and the\rnumber of coins Ai in pile i, you have to determine which player will win the game, assuming\rboth play optimally."}
{"i": "16306670", "t": "Write a method to evaluate if a given integer is prime."}
{"i": "16421663", "t": "How will we find given binary tree is binary search tree or not with complexity less than O(n)"}
