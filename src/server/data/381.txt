{"i": "13224713", "t": "Simple one to write a program to calculate avg of int array."}
{"i": "13216725", "t": "An expression consisting of operands and binary operators can be written in Reverse Polish Notation (RPN) by writing both the operands followed by the operator. For example, 3 + (4 * 5) can be written as \"3 4 5 * +\".\r You are given a string consisting of x's and *'s. x represents an operand and * represents a binary operator. It is easy to see that not all such strings represent valid RPN expressions. For example, the \"x*x\" is not a valid RPN expression, while \"xx*\" and \"xxx**\" are valid expressions. What is the minimum number of insert, delete and replace operations needed to convert the given string into a valid RPN expression?\r Input: The first line contains the number of test cases T. T test cases follow. Each case contains a string consisting only of characters x and *.\r Output: Output T lines, one for each test case containing the least number of operations needed.\r Constraints: 1 <= T <= 100 The length of the input string will be at most 100.\r Sample Input:\r 5\rx\rxx*\rxxx**\r*xx\rxx*xx**\rSample Output:\r 0\r0\r0\r2\r0\rExplanation:\r For the first three cases, the input expression is already a valid RPN, so the answer is 0. For the fourth case, we can perform one delete, and one insert operation: xx -> xx -> xx"}
{"i": "13225716", "t": "An expression consisting of operands and binary operators can be written in Reverse Polish Notation (RPN) by writing both the operands followed by the operator. For example, 3 + (4 * 5) can be written as \"3 4 5 * +\".\r You are given a string consisting of x's and *'s. x represents an operand and * represents a binary operator. It is easy to see that not all such strings represent valid RPN expressions. For example, the \"x*x\" is not a valid RPN expression, while \"xx*\" and \"xxx**\" are valid expressions. What is the minimum number of insert, delete and replace operations needed to convert the given string into a valid RPN expression?\r Input: The first line contains the number of test cases T. T test cases follow. Each case contains a string consisting only of characters x and *.\r Output: Output T lines, one for each test case containing the least number of operations needed.\r Constraints: 1 <= T <= 100 The length of the input string will be at most 100.\r Sample Input:\r 5\rx\rxx*\rxxx**\r*xx\rxx*xx**\rSample Output:\r 0\r0\r0\r2\r0\rExplanation:\r For the first three cases, the input expression is already a valid RPN, so the answer is 0. For the fourth case, we can perform one delete, and one insert operation: xx -> xx -> xx"}
{"i": "13216720", "t": "How can I do arrangements. of numbers... such that each new number formed out of arrangement has at max a difference of 1 from prev maxima.\r e.g.\rif input is k=1 output will be 1\r if k =2 outputs are : 11, 12\r 2,1 is wrong  as left most has to be 1 always.\r if k = 3 outputs are: 111,112, 121, 122, 123\r if k = 4 : 1111,1112,1121,1122,1123,1212,1211,1213,1223,1221, 1222, 1233, 1234\r 1423 is wrong diff b/w 1 and 4 is 3.\r1243 is wrong diff b/w 2 and 4 is 2....\rHow I do this using DP? if possible ?"}
{"i": "13225713", "t": "Describe in detail what new operator does, elaborate on memory allocators, kernel free page requests and cascading constructor calls in case of derived classes."}
{"i": "13227715", "t": "Write a program to return the longest repeating \rsubstring in a string. eg. for \"ababab\", \"abab\" is the  longest repeating substring."}
{"i": "13216713", "t": "Ur a given a url in following format:\r<protocol>://<host name>:<port>/<filename>\r implement a function which takes URL and do following operations:-\r1. convert hostname & protocol into lowercase.\r2. replace \"//\" by \"/\"\r3.  if host name is no there, add \"http://\" at the begining of the url.\r4. if url contains filename, remove filename from the Url."}
{"i": "13223706", "t": "write data structure for dictionary.\r1. implement function for inserting a word into a dictionary.\r2. implement function for lookup in dictionary."}
{"i": "13225711", "t": "There are M files(>100MB) containing N log entries.\rlog entry: <customer id, access time>.\rWe need to merge all M files into 1 file. How can we do this in optimal way. (write algo only)."}
{"i": "13215720", "t": "you are given a url in a format:\r<protocol>://<hostname>:<port>/<filename>\reg. http://www.amazon.com/index.html\rimplement a function which takes url and do following operations on it:-\r1. convert protocol & host name to lowercase.\r2. If Url don't contain protocol ,then add http:// at the beginning of the url.\r3. replace \"//\" by \"/\"\r4. if Url contain file name, then remove the file name from the Url."}
{"i": "13227711", "t": "Write data structure for dictionary.?\rImplement function for inserting a word into a dictionary .\rImplement function for look up in dictionary."}
{"i": "13227710", "t": "There are M files(>100MB) containing N log entries.\rlog entry: <customer id, access time>.\rWe need to merge all M files into 1 file. How can we do this in optimal way. (write algo only)."}
{"i": "13225707", "t": "There are N people in a village.Everybody knows the head of the village.But nobody else knows everybody else,i.e. an ordinary person may know some people but not everybody.Given a function knows(Person p1 ,Person p2) which return true if p1 knows p2.Find who is the head of the village ,preferably in O(N)."}
{"i": "13225706", "t": "There are N people in a village.Everybody knows the head of the village.But nobody else knows everybody else,i.e. an ordinary person may know some people but not everybody.Given a function knows(Person p1 ,Person p2) which return true if p1 knows p2.Find who is the head of the village ,preferably in O(N)."}
{"i": "13225697", "t": "Given a string, find the substring with minimum length  from it which contains exactly equal no of characters given in a hashmap which contains key as character and values as count of character needed in substring.\r For example:\rString str =\"abcrefbda\";\rmap = {{\"b\"=1},{\"d\"=1\"},{\"a\"=1}};\r Output = \"bda\";"}
{"i": "13224688", "t": "Difference between Java and C++"}
{"i": "13224687", "t": "How to Implement Linkedlist using arrays? Just the fundamentals. The followup question was what are the disadvantages in terms of memory when the array resizes."}
{"i": "13223683", "t": "Amazon receives marketplace sellers (clients) requests in XML format. Sometimes, the clients software makes mistakes and omit certain nodes starting or ending tags (or both). Amazon, being the earth most customer friendly company, still wants to honor the client\u2019s request by converting this malformed XML to well-formed XML. Given a malformed XML as string, you have to return the structure that the input XML follows .\r Following are the assumptions you can make:\r 1.      XML follows the structure below :-\r a.   Any parent node ( say with tag A ) can have multiple children but only of the same tag ( say B ).\r b.   A tag can occur only at the exactly one level in the XML Structure ( say tag B can only occur at the level 2)\r c.   There is single leaf node tag.\r 2.   For a given XML input, it will honor only a unique XML structure.\r 3.   All node tag names are unique.\r 4.   There is a single root node which is always present in the input XML.\r Input Format:\r Only line in the input contains a malformed string.\r Output Format:\r Print in a single line, space separated list of  tags in the structure. Tags that are more closer to root has to be printed before the ones that are farther.\r Sample Input:\r <A><B></B><D><C></C></D><B><D></D></B></A>\r Sample Output:\r A B D C\r Explanation:\r The actual XML structure is root with tag 'A' . Root has two children each having tag 'B'. Each of the node with tag 'B' has one child with tag 'D' and finally each of the node with tag 'D' has one children with tag 'C'. The well-formed string for this case is  \"<A><B><D><C></C></D></B><B><D><C></C></D></B><B><D><C></C></D></B></A>\"  and in the sample input some of the tags were missing. \rConstraints: The number of nodes is not more than 10,000. Size of tag string is less than 20."}
{"i": "13216687", "t": "As a follow up to the Problem \"XML Structure\", given the input malformed XML String and the XML structure that it needs to follow, you need to find the well-formed XML String.  You can assume that malformed XML string does follow the given structure and there is a unique well-formed XML String corresponding to it.\r Input Format:\r First line of input contains the structure of XML. Next line of input contains the malformed string.\r Output Format:\r Print in a single line the well-formed XML string.\r Sample Input:\r A B D C\r<A><B></B><D><C></C></D><B><D></D></B></A>\r Sample Output:\r <A><B><D><C></C></D></B><B><D><C></C></D></B><B><D><C></C></D></B></A>\r Note: You can attempt this problem without attempting XML Structure problem first, however you should read the problem XML Structure for proper background in order to solve this.\r Constraints: There will be no more than 10,000 nodes."}
{"i": "13224683", "t": "You received a transmission containing an expression of single digit positive integers (say: 9 *(5 \u2013 4) * 3). However, during transmission all operators and brackets were lost and you only received 9 5 4 3.  Given the array of digits, you have to calculate the least positive integer value of the expression that could NOT have been received by you.  The binary operators possible are *, +, -, / and brackets possible are ( and ).  Note that / is an integer division i.e. 9/5 = 1. \r Example:  You have received 6,6,4,4. The minimum positive integer that could NOT have been formed is  18. This is because integers less than 18 are formed as below.\r 1 = 6 /6 + 4-4\r 2 = 6/6 + 4/4\r 3 = 6  +( 6/4) -4\r 4 = (6+6+4) / 4\r \u2026\u2026..\r 18 cannot be formed\r Input Format:\r FIrst line contains an integer N, the number of digits in the array.\r Then follow N lines each containing a digit.\r Output Format:\r Print a single integer which is the required answer.\r Sample Input:\r 4\r 6\r 6\r 4\r 4\r Sample Output:\r 18\r Constraints:\r 1 <= N <= 10\r Note: You need not worry about the precedence of operators as you can impose necessary precedence using brackets at appropriate places."}
{"i": "13225680", "t": "malloc implementation\rmalloc allocation & stack allocation compare\rDetailed questions on projects"}
{"i": "13216683", "t": "Difference between array and linked list"}
{"i": "13216682", "t": "Im sure everyones heard of this.\rMatrix with rows and column sorted. Find a particular element.\rI mentioned the O(m+n) solution. He asked to make it better.\r Thought for a while, then told him that you start with the last element of the first row and once you find the row which might contain the element, do a binary search on that row (since its sorted).\rThis further brings down the complexity to O(m+logn).\rHe said make it even better.\r So I said do a binary search on the last column and look for the row where the element in the previous row is smaller and the element in the current row is greater than or equal to the target.\rSo the complexity becomes O(log m + log n).\rHe said ok.\r When I was about to code this, he said there are two ways to implement it.\r1) One you implement the dual binary search method.\r2) Make use of the facts that the rows and columns are sorted.\r Thought this over for a while and mentioned that instead of doing two binary searches, you can do just one considering the entire matrix as a linear array and doing binary search. \rThe complexity would be log(m*n)=log(m) + log(n).(Same as the previous optimal solution).\rThere would be some logic involved in translating the indices to (row,col) pairs. I got this working, but he wanted me to return the (row,col) pair if the element was found or (-1,-1) if not found.\r For this he gave me the function signature \r void find(int A[][10], int m, int n, int target,int&row, int col) \r which is what I couldn't figure out. Here m = number of rows and n=no of cols\r Here is the solution I gave// Initially pass start as 0 and end as m*n when calling function\r\nfind(int A[][10],int start,int end,int target,int cols)\r\n{\r\n    int mid = (start+end)/2;\r\n    if (start > end)\r\n    {\r\n        element not found;\r\n    }\r\n    \r\n    int r = mid/cols;\r\n    int c = mid%cols;\r\n    \r\n    if(A[r][c] == target)\r\n    {\r\n        element found;\r\n    }\r\n    else if (target>A[r][c])\r\n    {\r\n        start = mid+1;\r\n        find(A[][10],start,end,target,cols);\r\n    }\r\n    else \r\n    {\r\n        end = mid-1;\r\n        find(A[][10],start,end,target,cols);\r\n    }\r\n}Can somebody tell me how i can return the (row,col) pairs (yes! return two values) using the function signature he mentioned.\r PS: Thanks for reading the whole post.. I know its kinda long. But I hope it helps someone."}
{"i": "13218678", "t": "Difference between threads and process.\rSimple enough."}
{"i": "13215679", "t": "write a program which returns the first non repetitive character in the string."}
{"i": "13216680", "t": "write a program to find whether the string is palindrome or not."}
{"i": "13227671", "t": "what's the signature of [ ] in std::map? why not const?"}
{"i": "13224678", "t": "what's the advantages of using vector than c array(heap)? what's the difference of the memory models? how is vector more efficient than c array?"}
{"i": "13223674", "t": "0 Answers\rWrite an efficient code to print pairs of anagrams from a given set of strings.\r ex: anna, hjsds, nana, werwe, sads, eerww\r Ouput:\ranna nana\rwerwe eerww"}
{"i": "13216674", "t": "Write an efficient code to print pairs of anagrams from a given set of strings.\r ex: anna, hjsds, nana, werwe, sads, eerww\r Ouput:\ranna nana\rwerwe eerww"}
