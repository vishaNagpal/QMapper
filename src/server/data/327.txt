{"i": "14955106", "t": "Given a board of snakes and ladders game, provide an algorithm to find the minimum number of dice rolls required to reach 100 from 1."}
{"i": "14989772", "t": "Test cases for finger print reader say in a laptop to login. Here you can swipe your finger to have a secured login. e.g. I will swipe my finger and the system will allow me to login."}
{"i": "14989765", "t": "Given a 2-D MxN matrix having each value as difficulty for the block. A frog is starting from a point Matrix[0][0] and will have to reach Matrix[M-1][N-1]. It can jump any step in one go [ 1, 2, ..... M-1] horizontally OR [ 1,2,3,.... N-1] vertically\rEach difficulty value is positive. Write code to give path trace for frog.\rTwo structure to use -\r struct node\r{\r       int x;\r       int y;\r       struct node *next;\r};\r struct path\r{\r       int difficulty;\r       struct node *pathlink;\r}\r Ex matrix -   4X4 matrix\r                            7             9             2                11\r                          13            23          1                 3\r                          14             11          20              6\r                          22            44           3                15\r Minimum difficulty = 7 (a[0][0])+ 2(a[0][2]) +3(a[3][2])+15(a[3][3]) = 27\rPath trace will have =   7->2->3->15"}
{"i": "14945104", "t": "You have a list of 1 million distinct English words. Each word is between 1 to 40 letters long and contains only alphabets, no space or special characters. The list is already sorted alphabetically.\r Given a word shorter than 40 letters, find all words in this list that are only 1 letter different from this word, spelling order is not important. \r There are 3 types of matches: 1. Swap one letter with another and you have an exact match 2. Remove one letter and you have an exact match and 3 Add one letter and you'll have an exact match. For example: Given the word \"coverage\", these are valid matches:\r 1. \"converge\". Swap 'n' with 'a'\r2. \"coverages\". Remove 's'.\r3. \"overage\". Add a 'c'.\r What's the time complexity of your algorithm?\r Can your algorithm handle the request to find words that are 2 letters different from the given word?"}
{"i": "14947116", "t": "Given an integer (assume it's smaller than 50), write an algorithm that will generate all possible combinations of integers greater than 1 and they produce a sum equals to this number. The same number can appear more than once in a combination. What's the time complexity of your algorithm?\r For example: \r<=1 -> {}\r2 -> {2}, \r3->{3}, \r4->{[4], [2, 2]}, \r5->{[5], [3, 2]}, \r6->{[6], [4, 2], [3, 3], [2, 2, 2]} \r7->{[7], [5, 2], [4, 3], [3, 2, 2]}\r8->{[8], [6, 2], [5, 3], [4, 4], [4, 2, 2], [3, 3, 2], [2, 2, 2, 2]}\r...."}
{"i": "14952124", "t": "I have 10 million 10-bit integers to sort, how would you sort them and what's the time complexity? \r Follow-on question: Instead of sorting integers, I now have 10 million pairs to sort. Each pair consists of a 10-bit integer and an object, the sort order is determined by the 10-bit integer. Will your original sort algorithm hold or do you need sort it differently?\r (A word of advice: Ask as many questions as you want during the interview, but you MUST be quick. Also, don't mention anything until you've thought it through clearly, otherwise you're just inviting more questions. Time is of essence, you're too slow if this question takes you more than 15 minutes to come up with the optimal solution, because remember, you have to leave time for explanations and other questions)"}
{"i": "14974903", "t": "Hi All, Recently I came across an interesting problem. Following is the problem description. I would like to have your thoughts on the problem. \r Implement linux \"tail -n\" command in java:\rRestrictions:\r1) Should read file only from top to bottom.\r2) File size can range from 1KB to 1TB.\r3) System has only 32MB of RAM."}
{"i": "14952110", "t": "Given an integer array, sort the integer array such that the concatenated integer of the result array is max. e.g. [4, 94, 9, 14, 1] will be sorted to [9,94,4,14,1] where the result integer is 9944141\r Can we solve this in less than n square time?\r n square algo is here\r private bool isSwapNeeded(int i, int j)\r        {\r            int isum = i * (int)Math.Pow(10, NumberOfDigits(j)) + j;\r            int jsum = j * (int)Math.Pow(10, NumberOfDigits(i)) + i;\r             return isum > jsum;\r        }\r         private int NumberOfDigits(int i)\r        {\r            int noOfDigits = 0;\r             if (i == 0)\r                return 1;\r             while (i>0)\r            {\r                noOfDigits++;\r                 i /= 10;\r            }\r             return noOfDigits;\r        }\r         public int[] MaximumConcatArray(int[] input)\r        {\r            int j;\r            for (int i = 1; i < input.Length; i++)\r            {\r                j = i;\r                while (j>=1 && isSwapNeeded(input[j],input[j-1]))\r                {\r                    input[j] = input[j] ^ input[j - 1];\r                    input[j-1] = input[j] ^ input[j - 1];\r                    input[j] = input[j] ^ input[j - 1];\r                     j--;\r                }\r            }\r             return input;\r        }"}
{"i": "14952108", "t": "write the test cases for the Swiping Pad ....??"}
{"i": "14960067", "t": "#include <stdio.h>\r#include <stdlib.h>\r#include <time.h>\r#include <stdint.h>\r#define _uint64_t\runsigned long long int i,R,L;\rint f1(unsigned long long int num);\r//unsigned long long int a[999999999];\runsigned long long int *a=NULL;\runsigned long long int j,r;\runsigned long long int main()\r{\r //printf(\"enter Minimum value for Delicious Dishes\\n\");\rscanf(\"%llu\",&L);\r//printf(\"enter Maximum value for Delicious Dishes\\n\");\rscanf(\"%llu\",&R);\rj=L+1;\ra=(unsigned long long int *)malloc(sizeof(R-L));\r //int f1(int a[]);\rfor(i=0;i<(R-L);i++)\r{\r//j=L+1;\r *(a+i)=j;\rj=j+1;\r}\r//printf(\"Now Delicious Dishes List is Ready.....:\\n\\n { \");\rfor(i=0;i<R-L;i++)\r{\r\tr=f1(*(a+i));\r \tif(r==1)\r\t{\r\t\t//printf(\"not Delicious Dishes List:\\n\");\r\t\t//printf(\"%d\",a[i]);\r\t\t}\r\t\telse{\r\t\t\tprintf(\" %llu ,\",*(a+i));\r \t\t\t}\r  \t}\r\t//printf(\"  };\\n\\n\");\r\t//int random;\r\t//srand(time(NULL));\r\t//random=a[rand()%(sizeof(a) /sizeof(a[0]))];\r\tprintf(\"%llu\\n \",*(a+4));\rreturn 0;\r}\rint f1(unsigned long long int k)\r{\r\tunsigned long long int rep=0;\r \twhile(k>0)\r\t{\r\t\tif(rep & 1 <<(k%10))\r\t\treturn 1;\r\t\trep|= 1 << (k % 10);\r          k = k / 10;\r\t\t}\rreturn 0;\r}\rits give result correct but in large input value ex L=123456,R=123456789 its give core dump i have already using standard gcc compiler and take unsigned long long int but still giving runtime error core dump can anyone hel me for resolve this bugs"}
{"i": "14968041", "t": "Problem Statement :\r\u2022 Given an 4n X 4n Matrix, where n is a positive integer taken as input. Imagine the matrix consisting of two interleaved coils whose centers are at the centre of the matrix. Implement a java program which takes an integer (n) as input and prints the two coils in two seperate lines.\r Please have a look at the below examples to get a sense of what the two coils are :\r\u2022 Example 1:\r\u2022 Input: 1\r\u2022 Matrix:\r01 02 03 04\r05 06 07 08\r09 10 11 12\r13 14 15 16\r \u2022 Output the Two Coils as:\r- Coil1: 10 06 02 03 04 08 12 16\r- Coil2: 07 11 15 14 13 09 05 01\r \u2022 Example 2:\r\u2022 Input: 2\r\u2022 Matrix:\r01 02 03 04 05 06 07 08\r09 10 11 12 13 14 15 16\r17 18 19 20 21 22 23 24\r25 26 27 28 29 30 31 32\r33 34 35 36 37 38 39 40\r41 42 43 44 45 46 47 48\r49 50 51 52 53 54 55 56\r57 58 59 60 61 62 63 64\r \u2022 Output the Two Coils as:\r- Coil1: 36 28 20 21 22 30 38 46 54 63 52 51 50 42 34 26 18 10 02 03 04 05 06 07 08 16 24 32 40 48 56 64\r- Coil2: 29 37 45 44 43 35 27 19 11 12 13 14 15 23 31 39 47 55 63 62 61 60 59 58 57 49 41 33 25 17 09 01"}
{"i": "14974896", "t": "You are given two database instances at different geographical locations, which are updated too frequently. Different requests are performing different operations on the two instances.\rHow will you keep these in sync."}
{"i": "14948115", "t": "Given an array of integers and a function Arrange(int position), the function takes the position of an element in the array as input and puts this element at the last position and arranges the array. Now the objective is to sort the array using the Arrange function minimum number of times."}
{"i": "14942129", "t": "/* program for construction of full binary tree */\r#include <stdio.h>\r#include <stdlib.h>\r /* A binary tree node has data, pointer to left child\r   and a pointer to right child */\rstruct node\r{\r    int data;\r    struct node *left;\r    struct node *right;\r};\r // A utility function to create a node\rstruct node* newNode (int data)\r{\r    struct node* temp = (struct node *) malloc( sizeof(struct node) );\r     temp->data = data;\r    temp->left = temp->right = NULL;\r     return temp;\r}\r // A recursive function to construct Full from pre[] and post[]. \r// preIndex is used to keep track of index in pre[].\r// l is low index and h is high index for the current subarray in post[]\rstruct node* constructTreeUtil (int pre[], int post[], int* preIndex,\r                                int l, int h, int size)\r{\r    // Base case\rprintf(\"preindex : %d %d %d\\n\", *preIndex, l, h);\r    if (*preIndex >= size || l > h)\r        return NULL;\r     // The first node in preorder traversal is root. So take the node at\r    // preIndex from preorder and make it root, and increment preIndex\r    struct node* root = newNode ( pre[*preIndex] );\r    ++*preIndex;\r     // If the current subarry has only one element, no need to recur\r    if (l == h)\r        return root;\r     // Search the next element of pre[] in post[]\r    int i;\r    for (i = l; i <= h; ++i)\r        if (pre[*preIndex] == post[i])\r            break;\r     // Use the index of element found in postorder to divide postorder array in\r    // two parts. Left subtree and right subtree\r    if (i <= h)\r    {\r        root->left = constructTreeUtil (pre, post, preIndex, l, i, size);\r        root->right = constructTreeUtil (pre, post, preIndex, i + 1, h, size);\r    }\r     return root;\r}\r // The main function to construct Full Binary Tree from given preorder and \r// postorder traversals. This function mainly uses constructTreeUtil()\rstruct node *constructTree (int pre[], int post[], int size)\r{\r    int preIndex = 0;\r    return constructTreeUtil (pre, post, &preIndex, 0, size - 1, size);\r}\r // A utility function to print inorder traversal of a Binary Tree\rvoid printInorder (struct node* node)\r{\r    if (node == NULL)\r        return;\r    printInorder(node->left);\r    printf(\"%d \", node->data);\r    printInorder(node->right);\r}\r // Driver program to test above functions\rint main ()\r{\r    int pre[] = {1, 2, 4, 8, 9, 5, 3, 6, 7};\r    int post[] = {8, 9, 4, 5, 2, 6, 7, 3, 1};\r    int size = sizeof( pre ) / sizeof( pre[0] );\r     struct node *root = constructTree(pre, post, size);\r     printf(\"Inorder traversal of the constructed tree: \\n\");\r    printInorder(root);\r     return 0;\r}\r  why does constructTreeUtil  function needs to pass preindex as a pointer to integer?\rwhy not simply integer"}
{"i": "14956072", "t": "In a file stream, you are at unknown position. You have an API to move forward or backward 1 Byte at a time and the pointer points to first bite. \r Assumption: Chinese character occupies 4 bytes and English character occupies 2 bytes.   Chinese character always starts with first bite value 1 (means first bite of the character out of 4 bytes) and English character with first bite value 0.  Any character (Chinese or English) is identified by first bite of fist Byte of the character.\r Example: x is 0 or 1\rChinese 1xxxxxxxx|xxxxxxxxx|xxxxxxxxx|xxxxxxxxx\rEnglish 0xxxxxxxx|xxxxxxxxx\r Problem Statement: You need to develop an algorithm or code (C++) to find out the character that the current pointer pointing to.\r Suppose we have a some part of stream like CCECC and pointer at 6th Byte, then the current pointer that it is pointing to Chinese character.\r C        | C       |E  |  C       | C\rBBBB|BBBB|BB|BBBB|BBBB\r++++ ++"}
{"i": "14960049", "t": "You have a large number of data maybe millions. Which is the best data structure to use?\rFollowing operation needs to be performed :\rInsert, Delete and Searching."}
{"i": "14989726", "t": "You have a matrix of size (m x n). find submatrix of size (k x k) with maximum possible sum. 0<k<m and 0 <k <n\r[HINT] use DP"}
{"i": "14960045", "t": "Given unsorted array (contains -ve numbers also), write a method to return max sum. Condition is two numbers should not adjacent to each other."}
{"i": "14956067", "t": "write a insert method for singly linked list, so that it will insert elements in the ascending order."}
{"i": "14948096", "t": "Given n length path (assume array with 0's and 1's), each step either a rock or acid bucket (0 is acid and 1 is rock), need to find the jumping pattern of the from to cross the given path. Conditions are:\rlets consider, curretly frog jumping at speed s, at each step \rit can maintain same speed (s)\ror increase by one step (s=s+1) or \rdecrease by one step (s=s-1);\rfind the jumping sequence for the given input."}
{"i": "14989723", "t": "1. Consider you have a function namedint find(sortedArr,val)which return the index of value val in the sorted array in O(1).\r    Constraint: You must have a sorted Array for that.\r 2.You know that you have a new array which was sorted but its elements have been moved by some Pivot which currently isn't known.\r The mission:\rWrite a function which use find(sortedArr,val) in this new array to find the index of a given value in O(1) also.\r Thank you"}
{"i": "14922189", "t": "Write positive test cases to test this function\rbool FileCopy(string source, string destination)"}
{"i": "14922184", "t": "You are given a binary search tree T of finite (means can fit in memory) size n in which each node N contains \r- integer data element\r- pointer to left child\r- pointer to right child\r- pointer to in order successor (which is set null for each node)\r Set all in order successor pointers of the given binary search tree."}
{"i": "14945043", "t": "Given a conteneous input stream of integer.. Find out Maximum N number at any given instance.."}
{"i": "14989691", "t": "You are given with N number of linklist of max size k. Some linklists are merged with each other and some are stand alone. Return all stand alone linkedlist... not just number of stand aone..."}
{"i": "14948073", "t": "Given an 2D array which is row wise sorted and column wise sorted. Search a given element fron the array."}
{"i": "14960014", "t": "Search results shows short segments (\"snippets\") of results and highlights query terms. \r Look, for example, at a search for [buy apple ipad] in [tablet]:\r http://www.search.google.com/search?find_desc=buy+apple+ipad&find_categ=tablet.\r  Only a part relevant to query is shown which is shorter than the entire result.\r For this question you will write a function that finds the most relevant snippet for a document and highlights all the query terms that appear in the snippet (like the highlights you saw on the linked search page). It is up to you to define what constitutes a good snippet and how big the snippets will be.\r  Indicate highlights by surrounding the text to be highlighted with [[HIGHLIGHT]] ...\r[[ENDHIGHLIGHT]]."}
{"i": "14955029", "t": "Suppose there is an array with numbers : \r  1, 14, 5, k, 4, 2, 54, k, 87, 98, 3, 1, 32\r  Output for this can be assuming k =20\r 1,14,5,4,2,3,1,k,k,54,87,98,32\r Now sort this array in a way all k are in middle and all values on left of k are smaller (in any order) and on right are larger (in any order) \r Note: k is an integer value within range of 1 - 32768 \r Follow up: Sorting is ok. what sorting you want to use ? still is sorting necessary ? are there any other approaches ?\r Follow up: Used External array with 2 pointers and 3 pointers approach. They wanted more efficient solution."}
{"i": "14949056", "t": "How would you design an Excel sheet's Data structure. You need to perform operations like addition. The excel sheet is very sparse and is used to store numbers in the range 1-65K. Index for a cell is known."}
{"i": "14947055", "t": "How to sort a 1000 GB file with ram size is 4 GB only. Which algorithm or data structure we need to use to sort these files?\r Follow Up: External sort is Ok... but how can you make this solution more efficient... \r Follow Up 2: Ideal chunk size for external sort (I said 512 MB based on my experience with MS Word 2013, it can not load file size >512 MB)"}
