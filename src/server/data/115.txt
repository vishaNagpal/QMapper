{"i": "5641503067078656", "t": "Given a binary tree & the following TreeNode definition, return all root-to-leaf paths.\r Definition of TreeNode:public class TreeNode {\r\n      public int val;\r\n      public TreeNode left, right;\r\n      public TreeNode(int val) {\r\n          this.val = val;\r\n          this.left = this.right = null;\r\n      }\r\n  }EXAMPLEGiven the following binary tree:\r\n   1\r\n /   \\\r\n2     3\r\n \\\r\n  5\r\n\r\nAll root-to-leaf paths are:\r\n[ \"1->2->5\", \"1->3\" ]From Lint Code - http://www.lintcode.com/en/problem/binary-tree-paths/"}
{"i": "5720449532035072", "t": "You are given an array of positive and negative integers. If a number n at an index is positive, then move forward n steps. Conversely, if it's negative, move backward n steps. Determine if there is a loop in this array.\r For example, given the array [2, -1, 1, 2, 2], index 0 maps to index 2, 1 maps to 0, 2 maps to 3, and so on. There is a loop in this array because 0 maps to 2, 2 maps to 3, and 3 maps to 0 (use the modulo operator)."}
{"i": "5682565236129792", "t": "(Priority Scheduling) In some systems, a priority is associated with each process and the CPU is allocated to the process with the highest priority (small value). Equal priority processes are scheduled in FIFO order. Define a suitable data structure, and then write a simulation program for the system described above. The program should display the following menu: 1. Add a New Process. 2. Serve a Process. 3. Display Information about Waiting Process. 4. Number of Waiting Process 5. Exit menu Hints: You have to adjust the QUEUE ADT in implementation level to be suitable for solving this problem. The process should have the following fields: process ID and priority."}
{"i": "5734337711439872", "t": "Each test file starts with an integer \u2018t\u2019 - the number of testcases.\rIn each of the next \u2018t\u2019 lines, you are given a string of \u2018n\u2019 characters [ either \u2018(\u2018 or \u2019)\u2019 or \u2018*\u2019 ]. \rYour task is to find the number of distinct balanced parentheses expressions you can make by replacing the \u2018*\u2019 with either \u2018(\u2018 or \u2018)\u2019 or removing the \u2018*\u2019\rNote : You have to replace each \u2018*\u2019 with one of  \u2018(\u2018 or \u2018)\u2019 or remove it. If removed, assume the string has reduced by 1 character.\rDuplicate strings are not allowed. The final expressions to be counted have to be distinct\rAs the answer may be large, please output it modulo 1000000007 (10^9+7)\rOutput one integer per line corresponding to each testcase.\rConstraints :\r1 <= t <= 20\r1 <= n <= 100\r0 <= Number of \u2018*\u2019 in the input string <= min(n,10)\r Sample Input:\r2\r(*(*)*)\r*(*(**)*\rSample Output\r5\r9\rExplanation\rThe five possible valid solutions are for the first input are :\r((()))\r()(())\r()()()\r(())()\r(())\rThe nine possible valid solutions are for the second input are :\r(((())))\r(()(()))\r(()()())\r(()())\r((()))\r()(())\r()()()\r()()\r(())"}
{"i": "5750341430673408", "t": "Add a node to sorted circular linked list"}
{"i": "5662443448565760", "t": "You have a string aaabbdcccccf, transform it the following way  => a3b2d1c5f1\rie: aabbaa -> a2b2a2 not a4b2"}
{"i": "5758190080753664", "t": "Given a string, parse it and return a string array. It's like a tokenizer, but the rules are too...\r For exmple, string=\"abc(edf)hij{klmn}opq[rst]uvw\"\r The delimiter are (), {}, []. They are in pair. So output array:\r [\"abc\", \"edf\", \"hij\", \"klmn\", \"opq\", \"rst\", \"uvw\"]\r That's the rule 1. The rule 2 is, if any two consecutive \"(\" means escaping, that is \"((\" is actually output char \"(\". It's not part of the delimitor. Similar to \")\", \"{\", \"}\", \"[\", \"]\".\r abc(e))df) =&gt; [\"abc\", \"e)df\"], since the \"))\" outpus \")\".\r Rule 3: if \"{\" is inside a delimiter pair (), then \"{\" isn't part of the delimitor. Output it as is.\r abc(e{df}}g) =&gt; [\"abc\", \"e{df}}g\"]"}
{"i": "5707346257903616", "t": "/*\r# There's a room with a TV and people are coming in and out to watch it. The TV is on only when there's at least a person in the room.\r# For each person that comes in, we record the start and end time. We want to know for how long the TV has been on. In other words:\r# Given a list of arrays of time intervals, write a function that calculates the total amount of time covered by the intervals.\r# For example:\r # input = [(1,4), (2,3)]\r# > 3\r# input = [(4,6), (1,2)]\r# > 3\r# input = [(1,4), (6,8), (2,4), (7,9), (10, 15)]\r# > 11\r*/"}
{"i": "5672914578833408", "t": "find first not-repeating character by iterating through the length of the string only once and by using constant space."}
{"i": "5732347262533632", "t": "You are given a scrambled input sentence. Each word is scrambled independently, and the results are concatenated. So:\r 'hello to the world'\rmight become:\r'elhloothtedrowl'\r You have a dictionary with all words in it. Unscramble the sentence."}
{"i": "5640790505160704", "t": "The original question can be found from here :\rfranklinchen.com/blog/2011/12/08/revisiting-knuth-and-mcilroys-word-count-programs/\r Read a file of text, determine the *n* most frequently used words, and print out a sorted list of those words along with their frequencies.\r In the same spirit of the history:\r1. Do it using pure shell scripting \r2. Do it in the favourite language of your choice \rTry to minimise code and complexity."}
{"i": "5699228367060992", "t": "We define an undirected graph g,such that: The total number of nodes in the graph is g_nodes. The nodes are numbered sequentially as 1,2,3\u2026.g_nodes. The total number og edges in the graph is g_edges. Each edge connect two distinct nodes(i.e no edge connect a node to itself). The weight of the edge connecting nodes g_to[i] and g_from[i] is g_weight[i]. We define the weight of the path from some start node to some end node to the sum of all edges traversed on the path. Input formate: The first line contain two space-seperated integer describing the respective value of g_node and g_edge. Each line I of the g_edge subsequent lines contain three space \u2013seperated integer describing the respective value of g_to[i],g_from[i] and g_weight[i]. The next line contain an integer denoting start The next line contain an integer denoting end. The next line contain an integer denoting w_extra. input 1:\r 4 4  \r1 2 2  \r2 3 1  \r2 4 2  \r3 4 3  \r1     \r4  \r5  \rOutput:4\rinput2:\r 5 5  \r1 2 2  \r1 4 4  \r2 3 1  \r3 4 3  \r4 5 1  \r1   \r4  \r2  \routput:3\r Int mincost(int g_nodes,int g_edged,int* g_from,int* g_to,int* weight,int start,int end,int w_extra)\r{\r}"}
{"i": "5684743052984320", "t": "1. If I say quick sort takes O(e^n ) on the average, would I be wrong?\r 2. Do you think O( f ) is a good idea for real engineering? \r3.Given a choice, what other 'order of' measure would you propose to use ?\r4. Do you see a real problem with the modified  *order of* ? \r5. If you were to sort 10 elements, what sorting method would you have used? \r6. If you were to sort 1 trillion unicode characters, what sorting method you would have used?"}
{"i": "5758287824814080", "t": "Given a string \"2-4a0r7-4k\", there are two dashes which we can split into 3 groups of length 1, 5, 2. \r If we want each group to be length 4, then we get \"24A0-R74k\"\r Given a String A and an int K, return a correctly formatted string.\r IF A is \"2-4A0r7-4k\" and  B is 4, string is \"24A0-R74K\"\rIF K is 3, string is \"24-A0R-74K\" as the first grp could be shorter."}
{"i": "5740064278577152", "t": "The actual problem from question?id=6289136497459200 \rImplement pow, with :// Assume C/C++, as of now \r\ndouble pow ( double x, double power )No library functions allowed. \rShould return  : x^power \r=== Edit ===\rPeople took it a bit trivially, thus examples should help :x = pow ( 4, 0.5 ) // x = 2.0 \r\n  x = pow ( 8, 0.333333333 ) // 1.99999999986137069 \r\n  x = pow ( 10.1 , 2.13 ) // 137.78582031242644"}
{"i": "5170677343584256", "t": "write a SQL query to retrieve the number of students that received a GPA of 3 or 4. the query should return Total number of students that receive a GPA of 3 separate from Total number of students that receive GPA 4.\r Schema:-\r Student:- Student_ID, name, phoneno, email, gpa, gradyear\rClasses: Class_ID, name, description\rstudent_classes:- Class_ID, Student_ID, Grade"}
{"i": "5734782106337280", "t": "From here : question?id=5660692209205248\rIn-order traversal: \rA->B->C->D->E->F->H->L->M-P->R->S->T \r Write a function (pseudo-code is fine) that given a starting node, advances to the next in-order node in a binary tree. \rPlease also provide a data-structure definition of a node."}
{"i": "5660692209205248", "t": "#include <stdio.h>\r int main( int argc, char* argv[] ){\r    char* string1 = \"string\";\r    char string2[] = \"string\";\r}\r #include <stdio.h>\r /* Describe the code below */\r struct s {\r   double f;\r   int i;\r   char c[3];\r   void *p;\r   int x[0];\r};\r int main( int argc, char ** argv ) {\r struct s temp;\r printf(\"The size of the struct is %d \\n\", sizeof(temp));\r printf(\"The size of the double is %d \\n\", sizeof(temp.f));\r printf(\"The size of a character array is %d \\n\", sizeof(temp.c));\r printf(\"The size of a void pointer is %d \\n\", sizeof(temp.p));\r printf(\"The size of a integer array is %d \\n\", sizeof(temp.x));\r printf(\"The size of a integer is %d \\n\", sizeof(temp.i));\r return 0;\r }\r /* What's wrong with this program? */\r #include <stdio.h>\r  int\rmain( int argc, char const * argv ) {\r   for( int i = 0; i < argc; ++i ) {\r      printf(\"%s\\n\", argv[i] );\r   }\r}\r  /* Can you tell me what the program will do when I run it like this:\r * <prog> 1 2 3 4\r */\r  /*\rDescribe what two of these do, and how they're useful for debugging:\r perf\roprofile\rgprof\rstrace\rgcov\rprintf\rsyslog\r*/\r  #include <stdlib.h>\r#include <stdio.h>\r class C {\r    public:\r        void func() {\r            printf(\"func called\\n\");\r        }\r        virtual void virtualFunc() {\r            printf(\"virtual func called\\n\");\r        }\r};\r int main (int argc, char ** argv) {\r    C * obj = NULL;\r    /* What does the following print? */\r    obj->func();\r    /* What does the following print? */\r    obj->virtualFunc();\r    /* What's the difference? */\r}\r /* What's polymorphism?  */\r /* What's abstraction?  */\r #include <cstdlib>\r#include <ctime>\r#include <sys/time.h>\r#include <iostream>\r#include <cstdio>\rusing namespace std;\r /* What do this do? */\rint a( unsigned int i ) {\r   int c = 0;\r   while( i ) {\r      if( i & 1 ) { c++; }\r      i >>= 1;\r   }\r   return c;\r}\r /* What does this one do? */\r int b( unsigned int i ) {\r   static unsigned char n[] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4};\r   int c = 0;\r   while( i ) {\r      c+=n[i&15];\r      i >>= 4;\r   }\r   return c;\r}\r#include <algorithm>\r#include <stdio.h>\r#include <string.h>\r#include <string>\r using namespace std;\r  std::string::iterator  contains(char c, string s1) {\r        std::string::iterator i = std::find(s1.begin(), s1.end(), c);\r        if (i != s1.end())\r                return i;\r        else\r                return null;\r}\r   int anagram ( const string s1, const string s2) {\r        for( int i = 0; i < s1.size(); i++) {\r                std::string::iterator i = ,s2.find(s1[i]);\r                if (i != s2.end())\r                        s2.erase(i);\r                else\r                        return false;\r        }\r        return s2.size()==0;\r}\r int  main (int argc, char  *argv[] ){\r        printf(\"%d\",anagram(argv[1],argv[2]));\r}\r         F\r      /   \\\r     /      \\\r     D       M\r   /  \\      / \\\r   B   E    L   P\r  / \\      /     \\\r A   C    H       S\r                 / \\\r                R   T\r In-order traversal:\rA->B->C->D->E->F->H->L->M-P->R->S->T\r Requirement:\rWrite a function (pseudo-code is fine) that given a starting node, advances to the next in-order node in a binary tree.\rPlease also provide a data-structure definition of a node.\r  struct node\r{\r};\r  node *next_node(node *current)\r{\r   node *next;\r    /* current - any node in the tree, advance to next node */\r    return next;\r}\r  #include <stdio.h>\r#include <stdlib.h>\r#include <assert.h>\r#include <string.h>\r/*\r    vercmp compares two software version strings and returns the following:\r        if v1 > v2 : return 1\r        if v1 == v2 : return 0\r        if v1 < v2 : return -1\r    input strings are in the form \"1.0.3\", \"2.10\", \"6.0.0.3\", etc...\r    \"1.0\" is considered bigger than \"1\" and \"1.10\" is greater than \"1.2\"\r*/\rint vercmp( char * v1, char * v2 ) {\r }\r int main() {\r    assert( vercmp( \"1.1\", \"1.0\" ) == 1 );\r    assert( vercmp( \"1.0\", \"1.1\" ) == -1 );\r    assert( vercmp( \"1.0\", \"1.0\" ) == 0 );\r    assert( vercmp( \"1\", \"1.0\" ) == -1 );\r    assert( vercmp( \"1.0\", \"1\" ) == 1 );\r    return 0;\r}\r Describe in 5 minutes or less what one of these protocols is:\r BGP\rOSPF\rISIS\rPIM-SM\rIGMP\rSTP\rDHCP\r Could you configure a network device (EOS, Cisco, Linux, JunOS, Quagga, etc.) to\renable any of these?\r  Pick one of these data structures and tell me everything you know about it:\r Red-black tree\rB-tree\rPatricia\rAvl Tree\rTrie\r Or describe a data structure that can store a set of integers.\r If you're not familiar with any of the above, tell me what you know about\rone of these:\r Bit vector\rBinary tree\rstd::vector\rDoubly Linked List\r #!/usr/bin/python\r # Write a program to num up the Nth column of integers in a file that has\r# M columns in it.\r  What do these tools do?\r tcpdump\rping\rwireshark\rtraceroute\rifconfig\rip\rnetstat\r What seven system calls do you use to implement a TCP server?\r #include <stdio.h>\r#include <stdlib.h>\r#include \"list.h\"\r/**\r * Given a linked list of the structure:\r   struct node {\r      int val;\r      struct node* next;\r   };\r   print out the fibonacci nodes e.g. the 1st, 2nd, 3rd, 5th, 8th... nodes\r   up until the list ends.\r */\r int main( int argc, char** argv ) {\r    if( argc != 2 ) {\r        printf( \"usage fib num --you gave %d args\\n\", argc - 1 );\r        exit( 0 );\r    }\r    int nodes = atoi( argv[ 1 ] );\r     if( nodes < 1 ) {\r        printf( \"num must be a positive number --you gave %d\\n\", nodes );\r    }\r     struct node* list = createList( nodes );\r//    ...\r    freeList( list, nodes );\r}\r include <stdlib.h>\r#include <assert.h>\rstruct node {\r    int val;\r    struct node* next;\r};\r struct node* createList( int nodes );\rstruct node* freeList( struct node* list, int nodes );\r struct node* createList( int nodes ) {\r    int i = 0;\r    struct node* list =\r        ( struct node* ) malloc( sizeof( struct node ) * nodes );\r    assert( list );\r    for( i = nodes - 1; i >= 0; --i ) {\r        list[ i ].val = ( nodes - i ) - 1;\r        list[ i ].next = list + ( i - 1 );\r    }\r    list[ 0 ].next = NULL;\r    return &list[ nodes - 1 ];\r}\r struct node* freeList( struct node* list, int nodes ) {\r    free( &list[ 1 - nodes ] );\r}\r #include <stdio.h>\r#include <assert.h>\r#include <stdbool.h>\r extern bool isPalindrome( const char * );\r int main() {\r   assert( isPalindrome( \"civic\" ) == true );\r   assert( isPalindrome( \"evitative\" ) == true );\r   assert( isPalindrome( \"radar\" ) == true );\r   assert( isPalindrome( \"stats\" ) == true );\r   assert( isPalindrome( \"abba\" ) == true );\r   assert( isPalindrome( \"aba\" ) == true );\r   assert( isPalindrome( \"aBa\" ) == true );\r   assert( isPalindrome( \"statss\" ) == false );\r   assert( isPalindrome( \"abracadabra\" ) == false );\r   printf( \"Lower case palindromes passed!\\n\" );\r    assert( isPalindrome( \"ABa\" ) == true );\r   assert( isPalindrome( \"cIviC\" ) == true );\r   printf( \"Upper/lower cases examples passed!\\n\" );\r    assert( isPalindrome( \"\" ) == false );\r   assert( isPalindrome( NULL ) == false );\r   printf( \"No string/empty string corner cases passed!\\n\" );\r    printf( \"Nailed it!! Congratulations!\\n\" );\r    return ( 0 );\r}\r#include \"caesar.h\"\r#include <stdlib.h>\r char rotate(const char in, char pivot, int offset)\r{\r   return pivot + (in - pivot + offset) % 26;\r}\r void caesar(const char *in, char *outbuf, int offset)\r{\r   int i;\r   char *out = outbuf;\r   for (; *in; ++in, ++out) {\r      if (*in >= 'A' && *in <= 'Z')\r         *out = rotate(*in, 'A', offset);\r      else if (*in >= 'a' && *in <= 'z')\r         *out = rotate(*in, 'a', offset);\r      else\r         *out = *in;\r   }\r   *out = 0;\r}\r #include \"caesar.h\"\r#include <stdlib.h>\r#include <stdio.h>\r int\rmain(int argc, char *argv[])\r{\r   char *buf = strdup(argv[1]);\r   caesar(buf, buf, 13);\r   printf(\"%s\\n\", buf);\r   free(buf);\r   return 0;\r}\r struct Tree {\r  struct Tree * left; // for bst, check all nodes are less than parent\r  struct Tree * right; // for bst, check all nodes are greater than parent\r  int value;\r}\r bool isBst( Tree * tr ) {\r  return (tr, INT_MIN, INT_MAX);\r}\r bool helpIsBst(Tree * root, int min, int max) {\r  if (root == NULL) return 1;\r  return ( root->value < max && root->value > min\r           && helpIsBst(root->left, min, root->value)\r           && helpIsBst(root->right, root->value, max));\r}\rExample BST:\r*\r*       8\r*     /   \\\r*    4     12\r*   / \\    / \\\r*  1   7 11   20\r*/\r  struct node {\r     int value;\r     struct node *left, *right, *parent;\r}\r /* print the bst in-order */\rvoid printBst( struct node *n ) {\r}\r struct node * findMin( struct node *n ){\r}\r struct node * findNext( struct node *n ) {\r}\r void foo( struct node *root) {\r    for( struct node * n = findMin(root); n; n = findNext(n) ) {\r        printf( \"%d \", n->value );\r    }\r}\r #include <cstdio>\r //       10\r//     /    \\\r//   5       16\r//  / \\     /  \\\r// 3  11   14  17\r struct node {\r  int value;\r  node * left;\r  node * right;\r  node * parent;\r   node( int value, node * left, node * right, node * parent=NULL ) : value( value ), left( left ), right( right ), parent( parent ) {}\r};\r  // Test functions\r void connect_parents( node * n, node * parent ) {\r  if( n ) {\r    n->parent = parent;\r    connect_parents( n->left, n );\r    connect_parents( n->right, n );\r  }\r}\r node * construct_tree() {\r  node * root = new node(\r                         10,\r                         new node( 5,\r                                   new node( 3, NULL, NULL ),\r                                   new node( 9, NULL, NULL ) ),\r                         new node( 16,\r                                   new node( 14, NULL, NULL ),\r                                   new node( 17, NULL, NULL ) ) );\r  connect_parents( root, NULL );\r  return root;\r}\r int main() {\r  node * root = construct_tree();\r  // for( node * n = find_min( root ); n; n = find_next( n ) ) {\r  //   printf( \"%d\\n\", n->value );\rreturn 0;\r}\r  1. Create account for interviewee\r  $ tempaccount <username>\r 2. Login to recruit.arista.com as interviewee\r  $ ssh username@recruit.arista.com  # passwd=aristarecruit\r 3. Install interview questions into temp account\r  $ cp ~bterrell/screeningQuestions.gz .\r  $ tar xvfz screeningQuestions.gz\r  $ rm screeningQuestions.gz\r 4. Start tmux on my shell with two panes\r  $ cp ~bterrell/.tmux.conf ~/.\r  $ tmux new -s interview\r  - ctrl+\\, \"-\"  to split panes\r  5. Meet with interviewee (or telecon)\r  $ ssh username@recruit.arista.com # passwd=aristarecruit\r  $ tmux attach -t interview\"\r  - switch panes with ctrl+\\, <up-or-down arrow>\r  #include <stdio.h>\r#include <stdlib.h>\r /* Example BST:\r*\r*       8\r*     /   \\\r*    4     12\r*   / \\    / \\\r*  1   7 11   20\r*/\r  typedef struct node {\r   int value;\r   struct node *left, *right, *parent;\r} node_t;\r struct node * findMin( struct node *n ) {\r   for(; n && n->left; n = n->left) ;\r   return n;\r}\r struct node * findNext( struct node *n ) {\r   if(n->right) {\r      return findMin(n->right);\r   }\r   else {\r      for(; n->parent; n=n->parent) {\r         if(n->parent->left == n) {\r            return n->parent;\r         }\r      }\r      return NULL;\r   }\r}\r /* print the bst in-order */\rvoid printBst( struct node *n ) {\r   if(n->left) {\r      printBst(n->left);\r   }\r   printf(\"%d \", n->value);\r   if(n->right) {\r      printBst(n->right);\r }\r void printBstNR( struct node *root) {\r   node_t* n;\r   for( n = findMin(root); n; n = findNext(n) ) {\r       printf( \"%d \", n->value );\r   }\r}\r node_t* insertNode(node_t** root, int newval)\r{\r   node_t *n;\r   if(!(*root)) {\r      n = (node_t*)calloc(1, sizeof(node_t));\r      n->value = newval;\r      *root = n;\r   }\r   else if(newval < (*root)->value) {\r      n = insertNode(&((*root)->left), newval);\r      if((*root)->left == n) n->parent = *root;\r   }\r   else {\r      n = insertNode(&((*root)->right), newval);\r      if((*root)->right == n) n->parent = *root;\r   }\r   return n;\r}\rint main()\r{\r   node_t* root = NULL;\r   int data[] = { 8, 4, 12, 1, 7, 11, 20 };\r   int i, len = sizeof(data) / sizeof(int);\r    for(i=0; i < len; i++) insertNode(&root, data[i]);\r    printf(\"\\ntraversal w/o recursion: \");\r   printBstNR(root);\r   printf(\"\\ntraversal w/o recursion: \");\r   printBstNR(root);\r    printf(\"\\ntraversal w/ recursion: \");\r   printBst(root);\r   printf(\"\\n\");\r   return 0;\r}\r #include <algorithm>\r#include <stdio.h>\r#include <string.h>\r#include <string>\r using namespace std;\r  int anagram ( const string s1, const string s2) {\r        for( int i = 0; i < s1.size(); i++) {\r                int x = s2.find(s1[i]);\r                if (x != string::npos)\r                        s2.erase(x);\r                else\r                        return false;\r        }\r        return s2.size()==0;\r}\r int  main (int argc, char  *argv[] ){\r        printf(\"%d\",anagram(argv[1],argv[2]));\r}"}
{"i": "5766494265802752", "t": "#include <stdlib.h>\r#include <assert.h>\r extern int find( int *, int );\r int main( int argc, char *argv[] ) {\r   int o[4][5] = { { 4,6,7,8,9 },\r                   { 4,5,7,8,9 },\r                   { 4,5,6,8,9 },\r                   { 4,5,6,7,9 } };\r    int e[5][6] = { { 4,6,7,8,9,10 },\r                   { 4,5,7,8,9,10 },\r                   { 4,5,6,8,9,10 },\r                   { 4,5,6,7,9,10 },\r                   { 4,5,6,7,8,10 } };\r   int i;\r   for( i=0; i < 4; i++ )\r      assert( find( o[ i ], 5 ) == i + 5 );\r   for( i=0; i < 5; i++ )\r      assert( find( e[ i ], 6 ) == i + 5 );\r    printf (\"I'm a winner\\n\");\r   return 0;\r}\r #include <stdlib.h>\r //\r// find( ... )\r//\r// find takes and array of sorted consecutive positive ints where\r//  one number is missing and returns the missing number\r// find should return 0 on all error conditions\r//\r// [ 1, 2, 3, 4, 6, 7, 8, 9 ] -> return 5\r// [ 11, 12, 13, 15, 16, 17 ] -> return 14\r//\r /* What's wrong with this program? */\r #include <stdio.h>\r  int\rmain( int argc, char const * argv ) {\r   for( int i = 0; i < argc; ++i ) {\r      printf(\"%s\\n\", argv[i] );\r   }\r}\r  /* Can you tell me what the program will do when I run it like this:\r * <prog> 1 2 3 4\r */\r  /*\rDescribe what two of these do, and how they're useful for debugging:\r perf\roprofile\rgprof\rstrace\rgcov\rprintf\rsyslog\r*/\r int main( int argc, char* argv[] ){\r    char* string1 = \"string\";\r    char string2[] = \"string\";\r}\r  #include <stdio.h>\r class C {\r    public:\r        void func() {\r            printf(\"func called\\n\");\r        }\r        virtual void virtualFunc() {\r            printf(\"virtual func called\\n\");\r        }\r};\r int main (int argc, char ** argv) {\r    C * obj = NULL;\r    /* What does the following print? */\r    obj->func();\r    /* What does the following print? */\r    obj->virtualFunc();\r    /* What's the difference? */\r}\r /* What's polymorphism?  */\r* What's abstraction?  */\u2018\r/* What's a virtual function table?  */\r/* What's a smart pointer?  */\r/* What's a copy constructor?  */\r* Tell me what this expression does:  */\r/*    cout << 3;  */\r/* What could it do?  */\r/* Have you ever seen OOP inside a Unix kernel?  */\r/* What's C++0X?  */\r/* What is const?  */\r/* What is name mangling?  */\r/* What does \"extern C\" do?  */\r/* What's std::map?  */\rwrite( 1, c, strlen(c) );\r /* What does this do? */\rprintf( \"%s\", c );\r /* What's the difference? */\r/* What does malloc do?  */\r /* What does the '-9' mean in 'kill -9'?  */\r/* What would kill -11 do?  */\r/* What's a zombie process?  */\r/* What does fork return?  */\r  /* What is the return value of main used for?  */\r* What is select used for?  Have you ever heard of epoll?  */\r struct s {\r   double f;\r   int i;\r   char c[3];\r   void *p;\r   int x[0]; }; int main( int argc, char ** argv ) { }\r /* How big is a float? */\r/* write a program to tell me how big a float is */\r/* can you use gdb to show me how big a float is? */\r/* How many bytes will structure s take? */\r/* Write a quick program to tell me the size of structure s */\r/* Does this match what you expected? */\r /* What does this do?\r#define ABC(x) aaa ## x\r ABC(b)\r*/\r/* How are 1d arrays laid out in C ? */\r/* What does the compiler do when you have a statement a[ 5 ] */\r/* How do you create dynamically allocated arrays in C and how does the complier generate the memory access for a[ 5 ] */\r/* How are 2d arrays laid out in C */\r/* How do you create a dynamically allocated 2d array in C such that something like:\r int **a = get2dArray( 5, 6)\ra[ 2 ][ 3] = 5;\r would work properly.*/\r/* How would you extend it to create an N dimensional array. Something like:\rgetNdArray( int n, int * dim)\r where n = the number of dimensions, and dim is the actual dimensions.\r so you could create a 3d array of size 3,4,5 as\rint dim[] = [ 3, 4, 5 ];\rint ***a = getNdArray( 3, dim );struct s {\r   double f;\r   int i;\r   char c[3];\r   void *p;\r   int x[0];\r};\r int main( int argc, char ** argv ) {\r  struct s s1;\r  printf(\"%i\\n\", sizeof(s1.f));\r  printf(\"%i\\n\", sizeof(s1.i));\r  printf(\"%i\\n\", sizeof(s1.c));\r  printf(\"%i\\n\", sizeof(s1.p));\r  printf(\"%i\\n\", sizeof(s1.x));\r  printf(\"%i\\n\", sizeof(s1));\r}*/\r #include <ctime>\r#include <sys/time.h>\r#include <iostream>\r#include <cstdio>\rusing namespace std;\r /* What do this do? */\rint a( unsigned int i ) {\r   int c = 0;\r   while( i ) {\r      if( i & 1 ) { c++; }\r      i >>= 1;\r   }\r   return c;\r}\r /* What does this one do? */\r int b( unsigned int i ) {\r   static unsigned char n[] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4};\r   int c = 0;\r   while( i ) {\r      c+=n[i&15];\r      i >>= 4;\r   }\r   return c;\r}\r /* Which one do you think would run faster? */\r /* Write a small program that uses the gettimeofday function to\r * benchmark these functions.\r *\r * int gettimeofday(struct timeval *tv, struct timezone *tz);\r *\r * struct timeval {\r *    time_t      tv_sec;     // seconds\r *    suseconds_t tv_usec;    // microseconds\r * };\r *\r * The tz argument can be NULL in this case.\r */\rint main( int argc, char **argv ) {\r }\r#include <ctime>\r#include <sys/time.h>\r#include <iostream>\r#include <cstdio>\rusing namespace std;\r /* What do this do? */\rint a( unsigned int i ) {\r   int c = 0;\r   while( i ) {\r      if( i & 1 ) { c++; }\r      i >>= 1;\r   }\r   return c;\r}\r /* What does this one do? */\r int b( unsigned int i ) {\r   static unsigned char n[] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4};\r   int c = 0;\r   while( i ) {\r      c+=n[i&15];\r      i >>= 4;\r   }\r   return c;\r}\r /* Which one do you think would run faster? */\r/* Write a small program that uses the gettimeofday function to\r * benchmark these functions.\r *\r * int gettimeofday(struct timeval *tv, struct timezone *tz);\r *\r * struct timeval {\r *    time_t      tv_sec;     // seconds\r *    suseconds_t tv_usec;    // microseconds\r * };\r *\r * The tz argument can be NULL in this case.\r */\rint main( int argc, char **argv ) {\r  struct timeval t1 = {0, 0};\r  struct timeval t2 = {0, 0};\r PROJECT = find\rCC = gcc\rOBJ = find.o main.o\r all: $(PROJECT)\r .c.o:\r        $(CC) -I. -g -c $<\r $(PROJECT): $(OBJ)\r        $(CC) $(OBJ) -o $(PROJECT)\r clean:\r        rm -f find find.o main.o\r /*\r * describe the code below\r */\r struct s {\r   double f;\r   int i;\r   char c[3];\r   void *p;\r   int x[0];\r};\r  int main( int argc, char ** argv ) {\r  struct s new_s;\r  size_t size = sizeof(new_s.f);\r  size_t size_i = sizeof(new_s.i);\r  size_t size_c = sizeof(new_s.c);\r  size_t size_p = sizeof(new_s.p);\r  size_t size_x = sizeof(new_s.x);\r   int size_s = (int) sizeof(new_s);\r   int  total = (int) size + size_i + size_c + size_p + size_x;\r  printf (\"Total: %d\", total);\r  printf (\"Struct size: %d\", size_s);\r   return 0;\r}\r /* How are 1d arrays laid out in C ? */\r/* What does the compiler do when you have a statement a[ 5 ] */\r/* How do you create dynamically allocated arrays in C and how does the complier generate the memory access for a[ 5 ] */\r/* How are 2d arrays laid out in C */\r/* How do you create a dynamically allocated 2d array in C such that something like:\r int **a = get2dArray( 5, 6)\ra[ 2 ][ 3] = 5;\r would work properly.*/\r/* How would you extend it to create an N dimensional array. Something like:\rgetNdArray( int n, int * dim)\r where n = the number of dimensions, and dim is the actual dimensions.\r so you could create a 3d array of size 3,4,5 as\rint dim[] = [ 3, 4, 5 ];\rint ***a = getNdArray( 3, dim );\r*/"}
{"i": "5723560430534656", "t": "#ifndef STACK_H\r#define STACK_H\r typedef struct my_stack_ {\r    unsigned char *buf;\r    size_t elem_count;\r    size_t elem_size;\r    size_t buf_size;\r} my_stack_t;\r  typedef struct my_stack_ my_stack_t;\r my_stack_t * my_stack_init(size_t elem_size);\rvoid my_stack_push(my_stack_t *stack, void *elem);\rint my_stack_pop(my_stack_t *stack, void *elem);\rsize_t my_stack_depth(my_stack_t *stack);\r void my_stack_push(my_stack_t *stack, void *elem)\r{\r    assert(stack && elem);\r     size_t offset = stack->elem_count * stack->elem_size;\r    if(offset >= stack->buf_size) {\r        size_t new_size = stack->buf_size * 2;\r        unsigned char *p = realloc(stack->buf, new_size);\r         stack->buf = p;\r    }\r     stack->elem_count++;\r    memcpy(stack->buf + offset, elem, stack->elem_size);\r}\r  #endif\r  struct node {\r  int value;\r  struct node * next;\r};\r struct node * mylist;\r   mylist\r    [--]--\r         |\r         |\r         ---->[ 3, --]---->[ 2, --]---->[ 1, X]\r remove_matches( mylist, 2 );\r   mylist\r    [\u2014]\u2014:\r         |\r         |          -----------------------\r         |          |                      |\r         |          |                      v\r          ---->[ 3, | ]     [ 2, --]---->[ 1, X]\r    mylist\r    [--]--\r         |\r         |\r         ---->[ 3, --]---->[ 1, X]"}
{"i": "5638009950044160", "t": "determine whether a word is in a stored list;\rthe list doesn't fit into memory;\rno disk access allowed, for lookups, memory access only;\rno false positives allowed, false negatives ok"}
{"i": "5700380391374848", "t": "Design a service to generate unique 64 bit IDs"}
{"i": "5730931131285504", "t": "Write code for transforming equation into canonical form. An equation can be of any order. It may contain any amount of variables and parentheses.\r The equation will be given in the following form:\r P1 + P2 + ... = ... + PN\r where P1..PN - terms that look like: \r ax^k\r where a - floating point value;\rk - integer value;\rx - variable (each term can have many variables).\r For example:\rx^2 + 3.5xy + y = y^2 - xy + y\r Should be transformed into:\rx^2 - y^2 + 4.5xy = 0"}
{"i": "5695112077115392", "t": "Apparently DESCO asked it. It was faulty, and I am fixing it. The physics was wrong.  A mono pole is an abstract magnet with either the north or the south pole of the magnet.\r[ en.wikipedia.org/wiki/Magnetic_monopole ]\r  Imagine you are given such *n* monopoles, all of the same type, say North type. Thus, all of these repel one another. The force of repulsion follows inverse square law : \r[  en.wikipedia.org/wiki/Inverse-square_law ]\rThat is, given two such monopoles with a distance *r* between them,  the force of repulsion between them is given by :F = ( 1.0 ) / ( r ** 2 )Now, suppose you are also given an array of *n* number of positions over X axis, like : [ 0, 1, 4, 10 , 21 , .. ] where you need to place the monopoles ( imagine they are hold tight there, and do not move away ).\r After placement, you are given another monopole, of different type S, say. Find positions to place the  monopole so that it is stable.\r Fixes from the original question :\r[geeksforgeeks.org/d-e-shaw-interview-experience-set-19-on-campus/ ]\r 1. Monopoles exhibit inverse square law, not inverse law.\r2. It is impossible to have stable configuration using same type monopole, so one must use another type, repulsion is not stable, attraction is. \r( Terrible physics mistakes )\r PS. Do not try to do binary search here. Binary search assumption is underlying linearity of the structure, thus, effectively there are proportionate elements in left and right. In the classic cases of sorted array, the expectation is 50/50. But here due to non linearity (inverse square) , it won't work."}
{"i": "5737305298960384", "t": "Programming Challenge Description: \rDevelop a service to help a client quickly find a manager who can resolve the conflict between two employees. When there is a conflict between two employees, the closest common manager should help resolve the conflict. The developers plan to test the service by providing an example reporting hierarchy to enable the identification of the closest common manager for two employees. Your goal is to develop an algorithm for IBM to efficiently perform this task. To keep things simple, they just use a single relationship \"isManagerOf\" between any two employees. For example, consider a reporting structure represented as a set of triples:\r Tom isManagerOf Mary\rMary isManagerOf Bob\rMary isManagerOf Sam\rBob isManagerOf John\rSam isManagerOf Pete\rSam isManagerOf Katie\r The manager who should resolve the conflict between Bob and Mary is Tom(Mary's manager). The manager who should resolve the conflict between Pete and Katie is Sam(both employees' manager). The manager who should resolve the conflict between Bob and Pete is Mary(Bob's manager and Pete's manager's manager). \r Assumptions:\rThere will be at least one isManagerOf relationship.\rThere can be a maximum of 15 team member to a single manager\rNo cross management would exist i.e., a person can have only one manager\rThere can be a maximum of 100 levels of manager relationships in the corporation\r Input: \rR1,R2,R3,R4...Rn,Person1,Person2 R1...Rn - A comma separated list of \"isManagerOf\" relationships. Each relationship being represented by an arrow \"Manager->Person\". Person1,Person2 - The name of the two employee that have conflict\rOutput: \rThe name of the manager who can resolve the conflict Note: Please be prepared to provide a video follow-up response to describe your approach to this exercise.\r Test 1:\rTest Input \rFrank->Mary,Mary->Sam,Mary->Bob,Sam->Katie,Sam->Pete,Bob->John,Bob,Katie \r Expected Output \rMary \r Test 2:\rTest Input \rSam->Pete,Pete->Nancy,Sam->Katie,Mary->Bob,Frank->Mary,Mary->Sam,Bob->John,Sam,John\r Expected Output \rMary"}
{"i": "5140810577215488", "t": "Given an n-ary tree, find the longest sequence in it. The sequence doesn't end to start at the root. It can go from leaf to leaf."}
{"i": "5759602621677568", "t": "Given an NxN grid with an array of lamp coordinates. Each lamp provides illumination to every square on their x axis, every square on their y axis, and every square that lies in their diagonal (think of a Queen in chess). Given an array of query coordinates, determine whether that point is illuminated or not. The catch is when checking a query all lamps adjacent to, or on,\u2026"}
{"i": "5700803177218048", "t": "Write a code to convert from long type time to date using java?\rEg: 324561092314 to 02/20/2015"}
{"i": "5696357181423616", "t": "Write a code to find index of integer item in an integer array using java? Note : Complexity should be less than O(n) or with out using any for loop."}
{"i": "5721708662095872", "t": "Find the shortest path between a start node and end node in a undirected +ve weighted graph.\rYou are allowed to add at max one edge between any two nodes which are not directly connected to each other.\rex:\r From | To | Weight\r1 2 2\r1 4 4\r2 3 1\r3 4 3\r4 5 1\r  start node = 1, end node = 5.\rextra edge weight = 2.1----(2)----2\r\n\t |\t         |\r\n\t |\t\t\t |\r\n\t(4)  \t    (1)\r\n\t |\t\t\t |\r\n\t |\t\t\t |\r\n5-(1)-4----(3)----3\r\n\r\nIn this case answer would be 3 (from 1 - > 5 - > 4) \r\nSolution:\r\n\r\n     1----(2)----2\r\n\t/|\t         |\r\n   / |\t\t\t |\r\n(2)/ (4)  \t    (1)\r\n /   |\t\t\t |\r\n/    |\t\t\t |\r\n5-(1)-4----(3)----3"}
