{"i": "4557716425015296", "t": "Many sticks with length, every time combine two, the cost is the sum of two sticks' length. Finally, it will become a stick, what's the minimum cost?"}
{"i": "5082917910872064", "t": "HashMap<Integer,Integer> hs = new HashMap<Integer,Integer>();\rhs.put(1,1);\rhs.put(1,2);\rwhen call hs.get(1) it return 2 i want first 1,so how to get this"}
{"i": "5481974596632576", "t": "We can start a Thread using either of two methods start() and run().What is the difference between these two?"}
{"i": "5122268938108928", "t": "How would you find a random non-null element from an array of 10 million, where most elements are null, in a reasonable amount of time?"}
{"i": "5687662727921664", "t": "There are 5 buckets filled with coins. Real coins weigh one gram each, and fake coins weigh 0.9 grams each. Each bucket is either fake (contains only fake coins) or real (contains only real coins). Given the number of buckets is fixed(say 5) how many coins should each bucket contain so that the it is possible to find/locate fake buckets vs real buckets in 1 weighing(use of the machine). Also, find the sequence of coins which have to be selected from each bucket ?\r Here more than one bucket could be fake. Also, each bucket could either be fake or real. All buckets contains same number of coins."}
{"i": "4874896538599424", "t": "An integer array contains elements in increasing order till some point and then decreasing order , return  the index of maximum number. Solution should be less than O(n). Ex - {1,2,3,4,5,3,1}"}
{"i": "4790221258358784", "t": "Given a larger integer buffer/array (say size, x), now given a window size (say, n) and a number (say, k). Windows starts from the 1st element and keeps shifting right by one element. The objective is to find the minimum k numbers present in each window."}
{"i": "5752996830904320", "t": "There is a village in which parent prefer to have at least 1 boy. So they keep doing child until they get their first boy and then they stop doing children. What is ratio of girl/boy in such town after infinite years."}
{"i": "5434428369141760", "t": "You are given a large set of integers, which are not sorted. Figure out a method to retrieve the largest 1000 elements, in O(n) run time"}
{"i": "5754339008184320", "t": "multiplication of two numbers without actual multiplication ::\r Using vedic mathematics"}
{"i": "5702042412646400", "t": "Having trouble with this array pair difference problem (NOT array pair sum) because of a certain edge case.\r Example is: k = 4 a = [ 1, 1, 5, 6, 9, 16, 27] output: 3 (Due to 2x [1, 5], and [5, 9])\r So, find the difference that equals to k. I used this code in my interview but realized it was wrong hours later unfortunately. It only gives 2.public static int arrayPairDifference(int[] a, int k)\r\n    {\r\n        HashMap<Integer, Integer> hashMap = new HashMap<>();\r\n        int count = 0;\r\n        for (int i = 0; i < a.length; i++)\r\n        {\r\n            if (hashMap.containsValue(a[i] - k))\r\n            {\r\n                count++;\r\n            }\r\n            hashMap.put(i, a[i]);\r\n        }\r\n        return count;\r\n    }How to account for the edge case of the 2x [1, 5] ?"}
{"i": "5725312545456128", "t": "Operation :Deleting element in the binary search tree(Without linked list) I'm trying to implement a pseudo-code but operation not implemented.can cause?(If you want I can write a pseudo-code.)So,delete operation is not happening for BST.can cause?-1 is null element in array. Linked list is not be for this code.\r   void deleting(int *Tree,int element){\r int temp=0;\r  while((Tree[temp]!=element) && (Tree[temp]!=-1)){\r/*loop until the element is found*/\rif(element<Tree[temp])\r    temp=2*temp+1;\relse\r    temp=2*temp+2;\r   }\r      if(Tree[temp]!=1)/* if the element is found*/\r       /*case1 - Delete leaf node*/\r      if((Tree[2*temp+1]==-1) && (Tree[2*temp+2]==-1))\r    Tree[temp]=-1\r                  /*case 2- delete node with one child*/\r  else if((Tree[2*temp+1]==-1)|| (Tree[2*temp+2]==-1)){\r if(Tree[2*temp+1]!=-1) /* is the child in the left of temp*/\rpreOrder((2*temp+1),Tree);\r else \r    preOrder((2*temp+2),Tree);\r }\r /*case 3-delete node with 2 children*/\r else if {\r int  inOrder_N=2*temp+2 /* inorder successor is surely in the right sub tree*/\r     while(Tree[2*inOrder_N]!=-1)\r     inOrder_N=2*inOrder_N;\r Tree[temp]=Tree[inOrder_N]; /* replace with inorder successor*/\rif(Tree[2*inOrder_N+2]==-1);/* inorder successor has no child*/\r   Tree[inOrder_N]=-1;\r    else /* inorder successor has no child*/\r    preOrder(((2*inOrder_N)+1),Tree)\r   } \r   else\r    printf(\"element not found\");\r}\r  void preOrder(int node, int *bst,int n){\r  if(node<n){\r printf(\"Node : %d - Value : %d \\n\",node,bst[node]);\r preOrder(2*node+1,bst,N);\r preOrder(2*node+2,bst,N);\r }\r return;\r}"}
{"i": "5732809947742208", "t": "Given a dictionary, and a list of letters ( or consider as a string), find the longest word that only uses letters from the string. [I didn't meet this question, what's the best solution?]"}
{"i": "5676919538319360", "t": "Given 2 strings S1 and S2 where length of each string can go upto 10^5 I need to find Longest Common Substring of the two strings (Both its length and Substring also).\rIf their are many substrings with same maximum length  I need to find that substring which occurs earliest in S2.\r EXAMPLE : Let S1=defghi and S2=ghidef Then here answer will be ghi and length is 3.\r I tried implemented it using suffix array but got stuck in between.Could someone help and provide the code to do it in c++/java\r Note : It was mentioned that length of S1 is always greater or equal to length of S2"}
{"i": "5739818260627456", "t": "Say you were assigned the task to optimize a website, what would you do first?"}
{"i": "5735304249999360", "t": "Insert a element in a sorted circular linked list"}
{"i": "5205167846719488", "t": "For a given node in binary search tree find a next largest number in search tree."}
{"i": "4857362737266688", "t": "Write a function return an integer that satisfies the following conditions:\r1) positive integer\r2) no repeated digits, eg., 123 (valid), 122 (invalid)\r3) incremental digit sequence, eg., 1234 (valid) 1243(invalid)\r4) the returned integer MUST be the smallest one that greater than the input. eg., input=987, return=1023\r function signature could be like this:\rString nextInteger(String input)"}
{"i": "4716965625069568", "t": "Given a 2-D matrix represents the room, obstacle and guard like the following (0 is room, B->obstacle, G-> Guard):\r0  0  0\rB G  G\rB  0  0\r calculate the steps from a room to nearest Guard and set the matrix, like this\r2  1   1\rB  G  G\rB  1   1\rWrite the algorithm, with optimal solution."}
{"i": "5919519960727552", "t": "Deck of cards : \r 1) Put the first card on the table and next at the bottom of the deck\r2) Repeat the above until all the cards are on table.\r3) Pick up the cards and repeat steps 1 and 2.\r Find after how many iterations the original order is restored. \r For Ex :: \r1 2 3\r1st iteration - 2 3 1\r2nd iteration - 3 1 2\r3rd iteration - 1 2 3\r so after 3 iterations. Find for n."}
{"i": "6040954054115328", "t": "2 players place the knight in his desired postion (input taken from user) on chess board.The knights move in valid knight postions in chess.2 knights move one after the other.game ends when any one knight reaches bottom right corner."}
{"i": "6204813163364352", "t": "Given a N*N adjacency matrix of graph I need to find the size of maximum set of vertices that do not share any common edge between any two vertices of the graph.\r Like : Say we have 3*3 matrix as \r 0 1 0\r1 0 1\r0 1 0\r Then here answer is 2 as vertex 1 and vertex 3 dont have any edge in common.\r I was asked this question in my interview to implement it in c++."}
{"i": "6017147251720192", "t": "IF we remove next line character then program runs fine else it gives a seg fault#include <stdio.h>\r\n\r\n        void main()\r\n\r\n        {\r\n\r\n            char *a[10] = {\"hi\", \"hello\", \"how\"};\r\n\r\n            int i = 0, j = 0;\r\n\r\n            a[0] = \"hey\";\r\n\r\n            for (i = 0;i < 10; i++)\r\n\r\n            printf(\"%s\\n\", a[i]);\r\n\r\n        }"}
{"i": "5146675492421632", "t": "Understand the Elevator_Operations class definition below and expand the solution:\rclass Elevator_Operations\r{\rprivate:\rint number_of_persons;\rpublic:\rvirtual void move_up() = 0;\rvirtual void move_down()= 0;\rvirtual void next_stop() =0;\rvoid set_max_persons(int number_of_persons);\rvoid set_max_weight(float weight_in_kilograms);\rint get_current_floor();\rint get_next_destination_floor();\rvirtual void overload_alert(int currentLoad)=0;\r};\r1) Program must be customizable for different buildings having varying number of floors\r2) Method to set the maximum weight and number of persons an elevator can support\r3) Method to display alert message when elevator is overloaded, along with the current load\r4) At any part of the program current floor and next destination floor details must be made available\r5) Code to control the movement of the elevator should be defined only in child class as the working\rmechanism varies based on the usage.eg: elevator moves to the very next floor up/down or moves to the\rfloor which was chosen by the first user, then the next user etc\r6) Once destination is reached write a code to open the door; similarly, to close the door after the user\rdecides\rdestination floor"}
{"i": "5766198755065856", "t": "You are given a string which has numbers and letters. Numbers occupy all odd positions and letters even positions. You need to transform this string such that all letters move to front of array, and all numbers at the end.\r The relative order of the letters and numbers needs to be preserved\r I need to do this in O(n) time and O(1) space.\r eg: a1b2c3d4 -> abcd1234 , x3y4z6 -> xyz346\r Please don't submit your answers if it is not fulfilling the time-space complexity requirements."}
{"i": "5914549945368576", "t": "Program to count all Response codes individually per database  ( slideshare_backedn_fe01 is one db) in the given log file'\r output should like this\r{\rbackend : backend name\r{\r 200: 20\r503: 3 where 3 is count of response codes 503\r}\r}\r once again logfile looks like this\r May 29 13:53:13 127.0.0.1 haproxy[27326]: 164.85.131.129:15592 [29/May/2013:13:53:13.671] slideshare slideshare_backend/fe01 1/0/1/106/296 200 451 - - --VN 1526/1526/837/402/0 0/0 {www.slideshare.net|Mozilla/5.0 (Windows NT 5.1; rv:10.0.4) Gecko/20100101 Firefox/10.0.4|http://www.slideshare.net/slideshow/embed_code/11959978?hostedIn=slideshare&referer=http://www.slideshare.net/goulart.sousa|} {2471317690|||pingback/embed_or_homepageplayerhits|s11959978/a8717995|} \"GET /pingback/embed_or_homepageplayerhits/11959978?ref=http%3A%2F%2Fwww.slideshare.net\r%2Fgoulart.sousa&_=1369853592559 HTTP/1.1\"\rMay 29 13:53:13 127.0.0.1 haproxy[27326]: 217.129.26.81:50910 [29/May/2013:13:53:13.724] slideshare slideshare_backend/fe02 17/0/0/1/246 200 3291 - - --VN 1529/1529/839/435/0 0/0 {www.slideshare.net|Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.0; Trident/5.0)|http://www.slideshare.net/inexita/4|} {1098476889 1090975733|||||} \"GET /images/fadedlogo.jpg?829e162373dc3b1cc145ba5b62aba32c8c804b67 HTTP/1.1\"\rMay 29 13:53:13 127.0.0.1 haproxy[27326]: 79.154.237.97:50310 [29/May/2013:13:53:13.758] slideshare autosuggest_backend/solrsearch10_01 13/0/0/3/212 200 526 - - ---- 1528/1528/17/3/0 0/0 {autosuggest.slideshare.net|Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36|http://www.slideshare.net/faroviejo/las-10-ciudades-ms-grandes-del-mundo-y-la-paz-bcs|} {|||||} \"GET /?q=las?10?ciudades?ma*&rows=5&wt=json&sort=frequency%20desc&fq=%2Bresults%3A%5B10%20TO%20*%5D&json.wrf=jQuery17209988682114053518_1369853526684&_=1369853590254 HTTP/1.1\""}
{"i": "5971731193790464", "t": "In a Binary tree, every element(node's value) must contain the sum of its left and right sub-trees.\rFollow up question: how would you solve this if you can ONLY increment the value of a node\rEg. If a node\u2019s value is 20 and its sub-tree sum is 10, the node\u2019s value can\u2019t be set to 10 because you can only increment.\rHow would you solve this if you can ONLY increment the value of a node\r Further clarifications.\r1. You can make assumption that leaf nodes retain their original value and does not change.\r2. \"Sum of its left and right subtrees\" means sum of all nodes' values in its left subtree + sum of all nodes' values in its right subtree.\r PS: I am asking this question coz I am not sure of its solution myself. Hence seeking experts' advice."}
{"i": "5199916779438080", "t": "how to print this pattern\r input N=4\routput :\r4444444\r4333334\r4322234\r4321234\r4322234\r4333334\r4444444\r input N=3\routput :\r33333\r32223\r32123\r32223\r33333"}
{"i": "5098399858688000", "t": "In Amazon web site, the product items has to show with different attributes combination for clothers.\r Example: \rcolor - red blue green\rsize - XL X M S\rpattern - checks lines \r  so output should be in below format in different combinations:\r red - xL - checks\rred - xL - lines\rred - X - checks\rred - x - lines\rred - M - checks\r:\r:\rgreen - S - checks\rgreen - S - lines \r Note:- In above example, no. of attributes is 3. but attributes can be N.\r Below is the code, I have written. Hope it will be useful for anyone. \r   This is an non-recursive logic which will work for large value of N. time Complexity is O(n2).-------------------------------------------------------------------------------------\r\npackage com.test;\r\n\r\nimport java.util.Scanner;\r\npublic class Solution \r\n{\r\n\tpublic static void main(String args[] ) throws Exception \r\n\t{\r\n\t\t/* Enter your code here. Read input from STDIN. Print output to STDOUT */\r\n\t\tScanner in = new Scanner(System.in);\r\n\t\tint n = in.nextInt();\r\n\t\tin.nextLine(); //to read new line\r\n\t\tString[][] attributes = new String[n][];\r\n\t\tint i=0;\r\n\t\twhile(i < n)\r\n\t\t{\r\n\t\t\tString temp = in.nextLine();\r\n\t\t\tString[] values = temp.split(\" \");\r\n\t\t\tattributes[i] = values;\r\n\t\t\ti++;\r\n\t\t}\r\n\t\tprintAttributesCombination(attributes);\r\n\t}\r\n\r\n\tstatic void printAttributesCombination(String[][] attributes)\r\n\t{\r\n\t\tint count[] = new int[attributes.length];\r\n\t\tint totalcount[] = new int[attributes.length];\r\n\r\n\t\t//initialize the totalcount and temp index count\r\n\t\tinitialize(count, totalcount, attributes);\r\n\r\n\t\twhile(isDone(count,totalcount))\r\n\t\t{\r\n\t\t\tprintArray(attributes,count);\r\n\t\t}\r\n\t}\r\n\r\n\tstatic void initialize(int count[], int totalcount[], String[][] attributes)\r\n\t{\r\n\t\tfor(int i = 0; i < count.length; i++)\r\n\t\t{\r\n\t\t\tcount[i] = 0;\r\n\t\t\ttotalcount[i] = attributes[i].length - 1;\r\n\t\t} \r\n\r\n\t\tcount[count.length-1] = -1;\r\n\t}\r\n\r\n\tstatic boolean isDone(int count[], int totalCount[])\r\n\t{\r\n\t\tboolean prevIndexSet = true;\r\n\t\tboolean canTerminateLoop = false;\r\n\t\tint i = 0;\r\n\r\n\t\tfor(i = count.length - 1; i >= 0 ; i--)\r\n\t\t{\r\n\t\t\tif(count[i] == totalCount[i])\r\n\t\t\t{\r\n\t\t\t\tcount[i] = 0;\r\n\t\t\t\tprevIndexSet = true;\r\n\t\t\t\tcanTerminateLoop = true;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcount[i] = count[i] + 1;\r\n\t\t\t\tprevIndexSet = false;\r\n\t\t\t\tcanTerminateLoop = false;\r\n\t\t\t}\r\n\t\t\tif(!prevIndexSet)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif(canTerminateLoop  && i == -1 )\r\n\t\t\treturn false;\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tstatic void printArray(String[][] arr, int count[])\r\n\t{\r\n\t\tSystem.out.println();\r\n\t\tfor(int i = 0; i < arr.length; i++)\r\n\t\t{\r\n\t\t\tSystem.out.print(\"  \" + arr[i][count[i]]);\r\n\t\t}\r\n\t}\r\n}\r\n-------------------------------------------------------------------------------------Output:\r==============\r Sample1:-\r============\r3\ra b c\rd e f\rg h i\r   a  d  g\r  a  d  h\r  a  d  i\r  a  e  g\r  a  e  h\r  a  e  i\r  a  f  g\r  a  f  h\r  a  f  i\r  b  d  g\r  b  d  h\r  b  d  i\r  b  e  g\r  b  e  h\r  b  e  i\r  b  f  g\r  b  f  h\r  b  f  i\r  c  d  g\r  c  d  h\r  c  d  i\r  c  e  g\r  c  e  h\r  c  e  i\r  c  f  g\r  c  f  h\r  c  f  i\r  Sample2:-\r============\r4\ra b\ra b c\rd e\rf i\r   a  a  d  f\r  a  a  d  i\r  a  a  e  f\r  a  a  e  i\r  a  b  d  f\r  a  b  d  i\r  a  b  e  f\r  a  b  e  i\r  a  c  d  f\r  a  c  d  i\r  a  c  e  f\r  a  c  e  i\r  b  a  d  f\r  b  a  d  i\r  b  a  e  f\r  b  a  e  i\r  b  b  d  f\r  b  b  d  i\r  b  b  e  f\r  b  b  e  i\r  b  c  d  f\r  b  c  d  i\r  b  c  e  f\r  b  c  e  i"}
{"i": "5179916190482432", "t": "input [2,3,1,4]\routput [12,8,24,6]\r Multiply all fields except it's own position.\r Restrictions: \r1. no use of division\r2. complexity in O(n)"}
