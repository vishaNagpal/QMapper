{"i": "8726805", "t": "Also asked me about my most interesting project and wanted to know what I did in that."}
{"i": "8729811", "t": "A functions inputs an array and gives out a shuffled version of the input array. The technique he described is to generate random value between 0 and n-1 and append the particular value from the input list to the output list. He wanted me to give a correct way of doing this."}
{"i": "8726804", "t": "How do you get two numbers that sum up to x from an array of n numbers in the shortest time."}
{"i": "8690812", "t": "Asked me about Has tables and complexities of various operations on it."}
{"i": "8727806", "t": "Asked me basic questions about data structures. Also asked me to give a detailed explanation of Heaps. How to add, delete nodes."}
{"i": "8690712", "t": "How will you design a ticTactoe game using a 2-D array."}
{"i": "8690711", "t": "how will you design google instant search? (suggestions when you type letters)"}
{"i": "8690710", "t": "A class inherits Thread. All the methods are synchronized. If two objects are created then which one will get access to the class first?\r Can you predict the order? why, why not? Explain wrt thread model."}
{"i": "8686348", "t": "Why is it fine to alter the data members' value of a final class?"}
{"i": "8708989", "t": "Write insert function for a binary search tree? \rGiven constraint:\r1. The insertion should be such that the tree remains balanced.\r2. You can move the any non-leaf/root node to be a leaf/non-root node.\r At the end of inserting any random insertion the tree should be BST and balanced. he gave the sample data as {1,2,3,4,5,6,7,8}"}
{"i": "8718937", "t": "void fun(int *p){ int v = 0; p=&v;v++;}\rint main()\r{\r    int* p;\r    fun(p);\r}\rwhat will be the output. One of the options was compiler error which is the right one as tested by me."}
{"i": "8644988", "t": "Design a reference counted smart pointer."}
{"i": "8714943", "t": "Design a data structure which should behave LIKE a queue. FCFS should be followed.\rName = SQueue.\r 3 Operations - \r1) Enqueue - Put the items at the end of the queue.\r2) Dequeue - Remove n return the element at the head of the queue.\r3) FindMe - Return the smallest integer in the queue currently.\r The challenge is to support all three operation in O(1) Amortized Case Complexity."}
{"i": "8698937", "t": "You have a sorted array.\rIt is then rotated left/right i times.\reg.\r1 2 3 4 5 6 7 8 9\rRotate it right 3 times.\r7 8 9 1 2 3 4 5 6\r You are just given the rotated array. Nothing else.\r Design a searching algorithm which find a position of the provided key in O(log n) time."}
{"i": "8714942", "t": "Given a binary tree.\rIt might be full or some nodes might be missing.\rEvery node has a extra \"next\" pointer.\rMake the \"next\" pointer point to the next cousin/sibling node. Last node's \"next\" pointer should point to null.\r Eg.Given Binary Tree -\r\n              1\r\n       2             3\r\n    4     5      6      7\r\n  8  9  10   12 13  14  15\r\n\r\n1's next = null\r\n\r\n2's next = 3\r\n3's next = null\r\n\r\n4's next = 5\r\n5's next = 6\r\n6's next = 7\r\n7's next = null\r\n\r\n8's next = 9\r\n9's next = 10\r\n10's next = 12\r\n12's next = 13\r\n13's next = 14\r\n14's next = 15\r\n15's next = null"}
{"i": "8714941", "t": "You have a stream of 1 million numbers.\rThey are not in memory, you are reading them from a stream.\rYou have to give top 'K' biggest numbers.\rGive a solution better than O(Kn)"}
{"i": "8710946", "t": "Spiral Print a binary tree.\rBinary Tree might be full or some nodes might be missing.Eg.\r\nGiven Binary Tree -\r\n              1\r\n       2             3\r\n    4     5      6      7\r\n  8  9  10 11  12 13  14  15\r\n\r\nPrint\r\n1 3 2 4 5 6 7 15 14 13 12 11 10 9 8Solution:\r 1) Initialise two queue queue1 and One Stack stack1\r2) Consider root element at level 1\r3) Put root element in queue\r4) while(stack1!=null || queue1 !=null)\r   4.1) if(level ==odd)\r         while(queue !=null)\r          pick first element from queue and   process it\rput all the childs of picked element into stack. If level is odd then first put left child and then right child.\r  4.2) if(level ==even)\r         while(stack !=null)\r          pick pop element from stack and   process it\rput all the childs of picked element into queue. If level is even then first put right child and then left child.\r5) Increment level by 1"}
{"i": "8654965", "t": "Given 2 sorted integer arrays, find the intersecting element in them."}
{"i": "8713959", "t": "Given 2 sorted linked lists - merge them. Make sure you don't have duplicates in the merged list. The input lists could have duplicates within them or across the 2 lists."}
{"i": "8641142", "t": "printing, deleting linked list and some more questions on linked list, accesing time of binary search"}
{"i": "8718891", "t": "implementation of sizeof(), string copy, macro defintion, testing no.of bits set in a number, dynamic allocation of double array, structure padding"}
{"i": "8680315", "t": "what classes can i make in UML program for parking garage project in software engineering"}
{"i": "8635453", "t": "Formatting was incorrect so posted again.\rConsider the given structure:\rstruct node\r{\r    int data;\r    struct node *next;\r    struct node *next_larger;\r}\rYou are given a list where each node is of type defined above. Initially all the next larger pointer of each node points to NULL. Write an algorithm to update the next larger pointer of each so that they point to immediate next largest node in the list.\re.g.4-------->8------->2------->1------->9 \r\n|->NULL   |->NULL  |->NULL  |->NULL  |->NULL\r\n\r\nOutput:\r\n|------------------|\r\nV         |--------!-----------------V  \r\n4-------->8------->2------->1------->9 \r\n|---------^        ^--------|        |--->NULL"}
{"i": "8687931", "t": "1st Round interview:\rCommand to sort the file contents in Linux"}
{"i": "8656191", "t": "Written round pattern:\r15 Question - Aptitude\r15 Question - SQL / JAVA / C++ (any 2 sections, objective)\rSubjective:\rSQL - School, Courses & Teachers scenario. Asked to write 3 queries. \rThese queries where slightly complicated as they all required use of Inner Query / JOINS\r JAVA - Write a program to simulate the digital display (as in Calculator)\r C++ - Implement a generic smart pointer with reference counting.\r C++ objective was heavy on operator overloading.\rSQL objective was no cakewalk either.\rAptitude is a compulsory section and questions were of moderate difficulty (Ratios, Work and Time, SI, CI, Probablity, Permutation, Circles etc)"}
{"i": "8687930", "t": "1st Round interview:\rAsked to write a query which would join 3 tables to query for rows."}
{"i": "8687929", "t": "1st Round interview:\rContent Based Search (Have a file with a word say \"Mumbai\". Do not remember the File Name or the File Path. Search for the string)"}
{"i": "8656190", "t": "1st Round interview:\rStored Proc vs Normal Query. Which is faster and why?"}
{"i": "8632147", "t": "what kind of bug have you found in your job and why was it so big?\rThere was no code related question at all. no questions on resume."}
{"i": "8673885", "t": "what kind of tests will you do?"}
