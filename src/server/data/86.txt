{"i": "5703699023265792", "t": "Design a Shopping Cart. Come up with anything, how to ensure we scale, and how to ensure discount can be done."}
{"i": "5681177959596032", "t": "Find the largest repeating sub-string in a string.\rex: banana \rans is: ana"}
{"i": "5742035901349888", "t": "I was given a questions during an interview which I was not able to solve, please help me in finding the solution.\r Ques : - Divide the set in two partition such that both the partition has minimum difference of their sum. If we add an element to the left subset during partitioning than the value of that number will automatically increases by 1, but it will not increase by 1 if I add it to the right side. Find the minimum difference between both the subsets : -ex :- {1,2,3,4,5}\r\n leftSubset = {3,4} , rightSubset = {1,2,5}\r\n effective sum of leftSubset = 3+4+2(number of elements)\r\n effective sum of rightSubset = 1+2+5 = 8\r\n difference of left and right = (9-8)=1 =, min differencesolution : (1,2,3} {4,5}"}
{"i": "5756760659853312", "t": "A binary tree is started burning from a leaf node. What is the time(1ms to burn from node to node) it takes to entire tree get burned? The fire will spread to all the paths from a node."}
{"i": "5652547573383168", "t": "Input: expression_tree | sequence_of_operations\r The input is a single line of text with a expression tree and a sequence of operations separated by | character and ended by a \\n newline character. Spaces are allowed in the input but should be ignored.\r The expression tree is a sequence of 1-character variables A-Z and with sub expression trees formed by parenthesis (expression_tree). Examples: AB, A(B C D), (AB)C((DE)F)\r The sequence of operations is a string of with characters R (reverse) or S (simplify)\r Reverse means reverse the order of everything in expression tree. Applying reverse twice in a row cancels out. Example: (AB)C((DE)F) | R should print (F(ED))C(BA)\r Simplify means remove the parentheses around the very first element in the expression tree and each of its subexpression trees. Applying S multiple times should have same result as applying S once. Example: (AB)C((DE)F) | S should print ABC(DEF)\r String process(String input){\r }"}
{"i": "5734169131876352", "t": "You are given a log file with the bandwidth information of users in several lines. \rBandwidth info for a certain user may be repeated.\rUser:A Bandwidth:50 CountryCode:IND\rUser:B Bandwidth:60 CountryCode:USA\rUser:A Bandwidth:70 CountryCode:IND\r(i) Find total amount of bandwidth consumed per user\r(ii) Suppose there are 4 country codes, for every country code, find the top 5 users which consumed maximum bandwidth sorted."}
{"i": "5692321789116416", "t": "Design Airport Baggage System"}
{"i": "5711789131038720", "t": "How to design to record analytics for top n records that user listened in last 1 week? Please help."}
{"i": "5678829954662400", "t": "How to design an image viewer app to see recent photos /albums from let's say Facebook? Please help"}
{"i": "6247981035552768", "t": "Given the following input:\r Array: array of integer coordinates(x,y) of length N\r return a integer M that represents the maximum number of points that falls within the same line.\r Example:\r Array: [ [0,0], [1,1], [3, 12] ]\rOutput: 2#  [0,0] and [1,1] falls in the same line. [3,12] falls on a different line. Thus the maximum number of points that falls on the same line is 2"}
{"i": "5653291273814016", "t": "Given the following inputs:\r Array: Array of positive non repetitive integers of length N.\rK: Integers in range of [2,N)\rTarget: A Target integer\r return any subset of Array with K elements that sums up to target.\r Example:\r Array: [1,2,3,4,5]\rK: 2\rT: 6\rOutput: [1,5]\r Array: [1,2,3,4,5]\rK: 3\rT: 6\rOutput: [1,2,3]\r Array: [1,2,3,4,5]\rK: 4,\rT: 11\rOutput: [1,2,3,5]"}
{"i": "5756307675021312", "t": "Implement multithreaded rm -r <folder>, i.e recursively delete files/folder under <folder> by walking through it and assume there can be billions of files under folder and you can only delete folder if all contents in it are first deleted"}
{"i": "5639883728093184", "t": "Median of Stream of Running Integers \rNote: The integers are in particular range from 1..n\rThe time complexity of the code should be o(n)"}
{"i": "5674264404426752", "t": "Design a space shooter program . \rNote: The game includes spaceship , bullets and asteroids. Spaceship rotates in 180 degree generating bullets. The position of the bullets gets updated after certain time period every time . No Need to write the code for collision detection \rBasic code in expected . Not the entire working code."}
{"i": "5699709669736448", "t": "Given a matrix. Convert it into a linked list matrix such that each node is connected to its next right and down node.\r Ex:\r1 2 3\r4 5 6\r7 8 9\r Output:\r1->2->3->NULL\r|  |  |\rv  v  v\r4->5->6->NULL\r|  |  |\rv  v  v\r7->8->9->NULL\r|  |  |\rv  v  v\r--NULL-\r This is my code.class Ideone\r\n{\r\n\tpublic static void main(String args[]) throws Exception {\r\n\t\tint arr[][] = { { 1, 2, 3 }, \r\n\t\t\t\t        { 4, 5, 6 } };\r\n\t\tLList op = convert2DArrintoList(arr, 0, 0);\r\n\t\tSystem.out.println(op);\r\n\t}\r\n \r\n\tpublic static LList convert2DArrintoList(int arr[][], int col, int row) {\r\n\t\tif (col >= arr[0].length || row >= arr.length)\r\n\t\t\treturn null;\r\n\t\treturn new LList(arr[row][col], convert2DArrintoList(arr, col, row + 1), convert2DArrintoList(arr, col + 1, row));\r\n\t}\r\n \r\n\tstatic class LList {\r\n\t\tLList(int data) {\r\n\t\t\tthis.data = data;\r\n\t\t}\r\n \r\n\t\tLList(int data, LList down, LList next) {\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.down = down;\r\n\t\t\tthis.next = next;\r\n\t\t}\r\n \r\n\t\tLList() {\r\n\t\t\tthis.data = Integer.MAX_VALUE;\r\n\t\t}\r\n \r\n\t\t@Override\r\n\t\tpublic String toString() {\r\n\t\t\treturn \" \" + this.data + \" \";\r\n\t\t}\r\n \r\n\t\tint data;\r\n\t\tLList next;\r\n\t\tLList prev;\r\n\t\tLList rand;\r\n\t\tLList down;\r\n\t}\r\n}Are there better ways of doing it?"}
{"i": "5685873063493632", "t": "Given a binary tree, write a recursive method boolean method(int x, int y) which will return true \r1. if node y (meaning a node with a value of int y) is a node that is contained in one of the two possible subtrees of x, \r2. true if    x==y, and a node with a value x==y exists,    otherwise  \r3. return false,          \rbasicallly whether   x  contains       y? I had  a question like this on my exam, I solved this problem using   four arguments in my     function. I wonder whether it is even possible to solve it with only 2 int arguments and   recursively."}
{"i": "5712523167793152", "t": "Generate all possible matched parenthesis, given n left parenthesis and right parenthesis needs to be matched."}
{"i": "5727266179907584", "t": "Create a data structure that stores integers, let then add, delete. It also should be be able to return the minimum diff value of the current integers.\rThat is, \rmin_diff = minimum ( | x_i  - x_j | )\rExample:\r -1,3,4,10,11,11\rmin_diff = 0\r -1,3,4,10,11,14\rmin_diff = 1"}
{"i": "5697371865350144", "t": "If you are given 2 infinitely large integers in the form of strings, given the length of the string, find the product of the two integers."}
{"i": "5766097516101632", "t": "How will you multiply two infinitely large integers."}
{"i": "5736750809874432", "t": "write a program to find the nearest smaller number array for the given array.nearest smaller number is the number which is smaller than the given number and nearest to the given numbers position .if no such number is found print -1"}
{"i": "5086492123725824", "t": "// Create a numeric binary tree structure/classes that have left and right children and an integer numeric value.\r// Write a function 'isBalanced' for a node that returns true if the sum of all the children on the left is equal \r//   to the sum of all the children on the right.\r //Example:\r//     [12]         [12].isBalanced() -> True.  [3, 3]\r//    /     \\\r// [3]       [1]      [1].isBalanced() -> True. [2, 2]\r//          /   \\\r//       [2]     [0]\r//              /   \\\r//            [2]   [0]\r// - Part I:  setup and isBalanced() function\r// - Part II: implement \u201callBalancedNodes()\u201d <\u2014 given a node, finds all balanced children\r// allBalancedNodes(12) -> returns a list of balanced nodes: { [1], ... }"}
{"i": "5691748142546944", "t": "Given a fully connected graph with n nodes and corresponding values. One node can interact with other node at a time, to replace/ignore/add its value to other node\u2019s value. Assuming this operation takes 1 unit of time, how much time would it take for all the nodes to have value equal to sum of all the nodes.\r Examples : Given a graph with values {1,2,3,4}, find total time it takes, such that all nodes have value as 10.\r I am assuming it can be done in O(N).It will take basically two traversals, one for calculating the sum of values of nodes(first traversal), other for replacing the value of the nodes(second traversal).\r It will take 2*(no of nodes) time.\r Are there any better ways possible ?"}
{"i": "5759061822799872", "t": "Solve the 24 Game"}
{"i": "5644714492559360", "t": "Given a list/array of \"Assign\" trees with integers, operators and variables, return the result of the requested \"Result\" tree expression.\r Example:\"Assign\"\r\n  /  \\\r\n\"x\"  \"+\"\r\n    /   \\ \r\n   2     3\r\n\r\n\"Assign\"\r\n  /  \\\r\n\"y\"  \"-\"\r\n    /   \\ \r\n  5000  30\r\n\r\n\"Assign\"\r\n  /  \\\r\n\"z\"  \"*\"\r\n    /   \\ \r\n  50     x\r\n\r\n\"Return\"\r\n  \\\r\n  \"-\"\r\n  /  \\    \r\n z   \"*\"\r\n     / \\\r\n    1   y"}
{"i": "6246739957776384", "t": "You are given logs that contain user and page visits for a given day.\ru1 -> p4\ru3 -> p2\ru7 -> p9\r...\rcomeup with efficient data structure  that  answers these  queries\r Which page was visited by exactly 100 users in day?\rWhich page was visited by only one user exactly 15 times in a day?\rWhich page was visited by u3 more than 20 times in a day?"}
{"i": "5673860039966720", "t": "Problem:\rGiven 100 stones, two players alternate to take stones out. One can take any number from 1 to 15; however, one cannot take any number that was already taken. If in the end of the game, there is k stones left, but 1 - k have all been previously taken, one can take k stones. The one who takes the last stone wins. How can the first player always win?\r My Idea\rUse recursion (or dynamic programming). Base case 1, where player 1 has a winning strategy.\rReducing: for n stones left, if palyer 1 takes m1 stones, he has to ensure that for all options player 2 has (m2), he has a winning strategy. Thus the problem is reduced to (n - m1 - m2).\r Follow Up Question:\rIf one uses DP, the potential number of tables to be filled is large (2^15), since the available options left depend on the history, which has 2^15 possibilities.\rHow can you optimize?\r I don't have a great answer to the follow up question\u3002\u3002\u3002"}
{"i": "5762451793510400", "t": "Implement a function that returns whether a string made of different bracket characters is well formed or not.\r For example,\r\"{({})[]}\" is a well formed bracket string\r\"{[](}\" is not a well formed bracket string\r Needless to say any single brackets are automatically counted as not well formed"}
{"i": "5763572243103744", "t": "Design and implement a multi-threaded application that finds the occurrence(s) of a string in a text file of 100GB. It should return the line-number(s) in which the match(es) is/are found.\r Need not worry about the system constraints in spawning and running threads. There is a 32 core CPU with immense power. Huge amount of RAM.\r The result should be returned in few sec."}
{"i": "5730243296886784", "t": "You are in charge of a classroom which has n seats in a single row, numbered 0 through n-1.\rDuring the day students enter and leave the classroom for the exam.\rIn order to minimize the cheating, your task is to efficiently seat all incoming students.\r You're given 2 types of queries: add_student(student_id) -> seat index, and remove_student(student_id) -> void.\r The rules for seating the student is the following:\r1) The seat must be unoccupied\r2) The closest student must be as far away as possible\r3) Ties can be resolved by choosing the lowest-numbered seat."}
