{"i": "4838147984719872", "t": "Delete m nodes for every n nodes in linked list and write the test cases"}
{"i": "6241738196779008", "t": "Write a 10 digit number in such a way that the 1st digit will describes the no. of occurrence of 1, 2nd digit , no. of occurrence of 2 and so on 9th digit, the no. of occurrence of 9 in the 10 digit number."}
{"i": "5389627422670848", "t": "Given two (dictionary) words as Strings, determine if they are isomorphic. Two words are called isomorphic\r if the letters in one word can be remapped to get the second word. Remapping a letter means replacing all\r occurrences of it with another letter while the ordering of the letters remains unchanged. No two letters\r  may map to the same letter, but a letter may map to itself.\r   Example:\r   given \"foo\", \"app\"; returns true\r    we can map 'f' -> 'a' and 'o' -> 'p'\r   given \"bar\", \"foo\"; returns false\r   we can't map both 'a' and 'r' to 'o'\r    given \"turtle\", \"tletur\"; returns true\r  we can map 't' -> 't', 'u' -> 'l', 'r' -> 'e', 'l' -> 'u', 'e' -'r'\r     given \"ab\", \"ca\"; returns true\r      we can map 'a' -> 'c', 'b'"}
{"i": "6246973761912832", "t": "Suppose you have to maintain the stock values of various companies during various periods and return minimum stock value of a particular company over a given period of time.what data structure is best for this."}
{"i": "5684023808491520", "t": "You have a String which has the value of the text of a magazin or a newspaper.\r Find the 10 most used words."}
{"i": "5090227399950336", "t": "Write a method that takes a string, in this format \"aabbaadddc\". Encode the string by counting the consecutive letters. Ex: \"a2b2a2d3c1\""}
{"i": "5754864999071744", "t": "Explain Binary Search Tree. What is its time complexity?"}
{"i": "5653177353371648", "t": "What is a hash table? Explain how they work (hash function and buckets)."}
{"i": "4647477475016704", "t": "consider 3 entity and show-\r1.they are association,table representation,class interpretation using java"}
{"i": "5173689888800768", "t": "Complexity of a function:\r int func_fibonacci ( int n) {\r     if (n < 2) {\r        return n;\r    } else {\r         return ( func_fibonacci(n-1) +  func_fibonacci(n-2));\r    }\r}"}
{"i": "4861407111675904", "t": "There is a matrix of very large dimension (10^30 * 10*40) of characters. You need to search a string of length 10^10 inside the matrix. Adjacent characters in any direction can be chosen and same cell can be counted multiple times to find the pattern"}
{"i": "5674882507472896", "t": "You need to select an ad among large no. of advertisements depending on n keywords. What data structure should be used to serve the request efficiently"}
{"i": "5072902038749184", "t": "You visited a list of places recently, but you do not remember the\rorder in which you visited them. You have with you the airplane\rtickets that you used for travelling. Each ticket contains just the\rstart location and the end location. Can you reconstruct your journey?"}
{"i": "6232624813047808", "t": "Campus Interview question:\rQ: What is the difference between a HashMap and HashTable?\rA: HashTable is always synchronized - undesirable - HashMap is better\r Q: How is ConcurrentHashMap different from Collections.tosynchronized(map)?\rA: First locks individual rows the second locks whole structure"}
{"i": "5299060655259648", "t": "Campus Interview question:\rDesign the File System for an OS."}
{"i": "5092225096613888", "t": "Campus Interview question:\rSearch for an element in a rotated sorted array for eg. sorted: {1, 2, 3, 4, 5, 6} rotated: {5, 6, 1, 2, 3, 4}"}
{"i": "5655175050035200", "t": "Campus Interview question:\rFind the top k items out of an array where items can have values [0... 100]"}
{"i": "5177378863054848", "t": "Write a function for retrieving  the total number of substring palindromes.\rFor example the input is 'abba'  then the possible palindromes= a, b, b, a, bb, abba\rSo the result is 6.\r Updated at 11/11/2013:\rAfter the interview I got know that the O(n^3) solution is not enough to go to the next round. It would have been better to know before starting implementing the solution unnecessarily ..."}
{"i": "4883612763684864", "t": "Construct BST for a given inorder and preorder traversal using ITERATIVE METHOD ONLY"}
{"i": "4775436764577792", "t": "Modify the linkedListType class you already studied by adding the following member functions to it (so here you are a class developer):\r void removeTwoByTwoegg; // this function removes the first two nodes and the last two nodes from the linked list. Be warned that the list has to have AT LEAST 4 nodes in order for this function to execute.\r void duplicateEachNode(); // this function duplicates each node on the linked list\r#include <iostream>\rusing namespace std;\r struct nodeType\r{\r\tint info;\r\tnodeType *next;\r};\r class linkedListType\r{\rpublic:\r\tlinkedListType();\r\tint listSize();\r\tbool isEmpty();\r\tint seqSearch(int);\r\tvoid remove(int);\r\tvoid insertFirst(int);\r\tvoid insertEnd(int);\r\tvoid insertAt(int, int);\r\tvoid removeAt(int);\r\tvoid print();\r\tvoid clearList();\r\tvoid insertOrdered(int);\r\tvoid removeFirst();\r\tvoid removeLast();\r\tvoid removeLast2();\r\tint removeOddSumEven();\r\t ~linkedListType();  \r  private:\r\tnodeType *first, *last;\r\tint length;\r};\r // This function assumes that the list is NOT empty\r// and first and last elements are NOT odd\rint linkedListType::removeOddSumEven()\r{\r\tint sum = first->info;\r\tnodeType *current = first->next;\r\tnodeType *trailCurrent = first;\r \twhile(current != NULL)\r\t{\r\t\tif(current->info % 2 == 0)\r\t\t{\r\t\t\tsum += current->info;\r\t\t\ttrailCurrent = current;\r\t\t\tcurrent = current->next;\r\t\t}\r\t\telse\r\t\t{\r\t\t\ttrailCurrent->next = current->next;\r\t\t\tdelete current;\r\t\t\tlength--;\r\t\t\tcurrent = trailCurrent->next;\r\t\t}\r\t}\r\treturn sum;\r}\r   void linkedListType::removeLast()\r{\r\tif(length == 0)\r\t\tcout<<\"ERROR: EMPTY LIST\" << endl;\r\telse if(length == 1)\r\t{\r\t\t\tdelete first;\r\t\t\tlast = first = NULL;\r\t\t\tlength--;\r\t}\r\telse\r\t{\r\t\tnodeType *current = first->next;\r\t\tnodeType *trailCurrent = first;\r\t\twhile(current != last)\r\t\t{\r\t\t\ttrailCurrent = current;\r\t\t\tcurrent = current->next;\r\t\t}\r\t\tdelete current;\r\t\ttrailCurrent->next = NULL;\r\t\tlast = trailCurrent;\r\t\tlength--;\r\t}\r}\r void linkedListType::removeLast2()\r{\r\tif(length == 0)\r\t\tcout<<\"ERROR: EMPTY LIST\" << endl;\r\telse if(length == 1)\r\t{\r\t\t\tdelete first;\r\t\t\tlast = first = NULL;\r\t\t\tlength--;\r\t}\r\telse\r\t{\r\t\tnodeType *current = first;\r\t\twhile(current->next != last)\r\t\t\tcurrent = current->next;\r \t\tdelete last;\r\t\tcurrent->next = NULL;\r\t\tlast = current;\r\t\tlength--;\r\t}\r}\r void linkedListType::removeFirst()\r{\r\tif(length == 0)\r\t\tcout<<\"ERROR: EMPTY LIST\" << endl;\r\telse if(length == 1)\r\t{\r\t\t\tdelete first;\r\t\t\tlast = first = NULL;\r\t\t\tlength--;\r\t}\r\telse\r\t{\r\t\tnodeType *current = first;\r\t\tfirst = first->next;\r\t\tdelete current;\r\t\tlength--;\r\t}\r}\r linkedListType::linkedListType()\r{\r\tfirst = last = NULL;\r\tlength = 0;\r}\r int linkedListType::listSize()\r{\r\treturn length;\r}\r bool linkedListType::isEmpty()\r{\r\treturn (length == 0);\r}\r int linkedListType::seqSearch(int item)\r{\r\tnodeType *current = first;\r\tint loc = 0;\r\twhile(current != NULL)\r\t{\r\t\tif(current->info == item)\r\t\t\treturn loc;\r\t\tcurrent = current->next;\r\t\tloc++;\r\t}\r\treturn -1;\r}\r void linkedListType::remove(int item)\r{\r\tif(isEmpty())\r\t{\r\t\tcout<<\"Can not remove from empty list\\n\";\r\t\treturn;\r\t}\r \tnodeType *current, *trailCurrent;\r\tif(first->info == item)//delete the first element, special case\r\t{\r\t\tcurrent = first;\r\t\tfirst = first->next;\r\t\tdelete current;\r\t\tlength--;\r\t\tif(length == 0)\r\t\t\tlast = NULL;\r\t}\r\telse\r\t{\r\t\tcurrent = first->next;\r\t\ttrailCurrent = first;\r\t\twhile(current != NULL)\r\t\t{\r\t\t\tif(current->info == item)\r\t\t\t\tbreak;\r\t\t\ttrailCurrent = current;\r\t\t\tcurrent = current->next;\r\t\t}\r \t\tif(current == NULL)\r\t\t\tcout<<\"The item is not there\\n\";\r\t\telse\r\t\t{\r\t\t\ttrailCurrent->next = current->next;\r\t\t\tif(last == current) //delete the last item\r\t\t\t\tlast = trailCurrent;\r\t\t\tdelete current;\r\t\t\tlength--;\r\t\t}\r\t}\r}\r   void linkedListType::insertFirst(int item)\r{\r\tnodeType *newNode = new nodeType;\r\tnewNode->info = item;\r\tif(length == 0){\r\t\tfirst = last = newNode;\r\t\tnewNode->next = NULL;\r\t}\r\telse{\r\t\tnewNode->next = first;\r\t\tfirst = newNode;\r\t}\r\tlength++;\r}\r void linkedListType::insertEnd(int item)\r{\r\tnodeType *newNode = new nodeType;\r\tnewNode->info = item;\r\tif(length == 0){\r\t\tfirst = last = newNode;\r\t\tnewNode->next = NULL;\r\t}\r\telse{\r\t\tlast->next = newNode;\r\t\tnewNode->next = NULL;\r\t\tlast = newNode;\r\t}\r\tlength++;\r}\r void linkedListType::insertAt(int loc, int item)\r{\r\tif(loc < 0 || loc > length)\r\t\tcout<< \"ERROR: Out of range\" << endl;\r\telse\r\t{\r\t\tnodeType *newNode = new nodeType;\r\t\tnewNode->info = item;\r\t\tif (loc == 0) //insert at the begining\r\t\t\tinsertFirst(item);\r\t\telse if (loc == length) //insert at the end;\r\t\t\tinsertEnd(item);\r\t\telse\r\t\t{\r\t\t\tnodeType *current = first;\r\t\t\tfor(int i = 1; i < loc; i++)\r\t\t\t\tcurrent = current->next;\r\t\t\tnewNode->next = current->next;\r\t\t\tcurrent->next = newNode;\t\r\t\t\tlength++;\r\t\t}\r \t}\r}\r void linkedListType::removeAt(int loc)\r{\r\tif(loc < 0 || loc >= length)\r\t\tcout<< \"ERROR: Out of range\" << endl;\r\telse\r\t{\r\t\tnodeType *current, *trailCurrent;\r\t\tif(loc == 0) //remove the first item\r\t\t{\r\t\t\tcurrent = first;\r\t\t\tfirst = first->next;\r\t\t\tdelete current;\r\t\t\tlength--;\r\t\t\tif(length == 0)\r\t\t\t\tlast = NULL;\r\t\t}\r\t\telse\r\t\t{\r\t\t\tcurrent = first->next;\r\t\t\ttrailCurrent = first;\r\t\t\tfor(int i = 1; i < loc; i++)\r\t\t\t{\r\t\t\t\ttrailCurrent = current;\r\t\t\t\tcurrent = current->next;\r\t\t\t}\r \t\t\ttrailCurrent->next = current->next;\r\t\t\tif(last == current) //delete the last item\r\t\t\t\tlast = trailCurrent;\r\t\t\tdelete current;\r\t\t\tlength--;\r\t\t}\r\t}\r}\r  void linkedListType::print()\r{\r\tnodeType *current = first;\r\twhile(current != NULL)\r\t{\r\t\tcout<<current->info <<endl;\r\t\tcurrent= current->next;\r\t}\r}\r void linkedListType::clearList()\r{\r\tnodeType *current;\r\twhile(first != NULL)\r\t{\r\t\tcurrent = first;\r\t\tfirst = first->next;\r\t\tdelete current;\r\t}\r\tlast = NULL;\r\tlength = 0;\r}\r void linkedListType::insertOrdered(int item)\r{\r\tnodeType *newNode = new nodeType;\r\tnewNode->info = item;\r \tif(first == NULL)\r\t{\r\t\tfirst = last = newNode;\r\t\tnewNode->next = NULL;\r\t\tlength++;\r\t}\r\telse if(first->info >= item)\r\t{\r\t\tnewNode->next = first;\r\t\tfirst = newNode;\r\t\tlength++;\r\t}\r\telse\r\t{\r\t\tnodeType *current = first->next;\r\t\tnodeType *trailCurrent = first;\r \t\twhile(current != NULL)\r\t\t{\r\t\t\tif(current->info >= item)\r\t\t\t\tbreak;\t\t\r\t\t\tcurrent = current->next;\r\t\t\ttrailCurrent = trailCurrent->next;\r\t\t}\r\t\tif(current == NULL) //insert at the end\r\t\t{\r\t\t\tlast->next = newNode;\r\t\t\tnewNode->next = NULL;\r\t\t\tlast = newNode;\r\t\t\tlength++;\r\t\t}\r\t\telse\r\t\t{\r\t\t\ttrailCurrent->next = newNode;\r\t\t\tnewNode->next = current;\r\t\t\tlength++;\r\t\t}\r\t}\r}\rlinkedListType::~linkedListType()\r{\r\tclearList();\r}\r int main()\r{\r\tlinkedListType l1;\r  \tl1.insertAt(0, 10);\r\tl1.insertAt(1, 1);\r\tl1.insertAt(2, 3);\r\tl1.insertAt(3, 40);\r   \tl1.print();\r  \treturn 0;\r}"}
{"i": "5726815775621120", "t": "Given two Btrees. these trees \"may\" have right and left branches swapped. Now compare it"}
{"i": "5442107225407488", "t": "Find number of palindromes in a string"}
{"i": "4907555595747328", "t": "Given a set of n points (coordinate in 2d plane) within a rectangular space, find out a line (ax+by=c), from which the sum of the perpendicular distances of all the points will be minimum. This can has a general usecase like, in a village there are few house, you have to lay a road, such that sum of all the approach roads from each house will be minimum."}
{"i": "6173167567503360", "t": "Given a matrix M with (with positive or negative numbers) find the largest sum S of any sub-matrix of M."}
{"i": "6083655080345600", "t": "Find the length of the longest palindrome in a string"}
{"i": "6745269022490624", "t": "in this i have to improve the enqueue function\renqueue returns the queue after adding the element but the original queue is not to be changed\rand same is for dequeue function\r import java.util.ArrayList;\rimport java.util.List;\rimport java.util.NoSuchElementException;\r public class PersistentQueue<E>{\r    private List<E> queue;\r     public PersistantQueue<E>(){\r        queue=new ArrayList<E>();        \r    }\r     private PersistentQueue(List<E> queue){\r        this.queue=queue;\r    }\r     public PersistantQueue<E> enqueue(E e){\r\t/*\r\tReturns the queue that adds an item into tail of this queue without modifying this queue ( how to return without cloning ??)\r\t*/\r        if(e==null){\r            throw new IllegalArgumentException();\r        }\r        List<E> clone = new ArrayList<E>(queue);\r        clone.add(e);\r        return new PersistantQueue<E>(clone);\r    }\r     public PersistantQueue<E> dequeue(){\r\t/*\r\tReturns the queue that removes the object at the head of this queue without modifying this queue ( here also how to do instead of clone as it it slow ??)\r\t*/\r        if(queue.isEmpty()){\r            throw new NoSuchElementException();\r        }\r        List<E> clone = new ArrayList<E>(queue);\r        clone.remove(0);\r        return new PersistantQueue<E>(clone);\r    }\r     public E peek(){\r        if(queue.isEmpty()){\r            throw new NoSuchElementException();\r        }\r        return queue.get(0);\r    }\r     public int size(){\r        return queue.size();\r    }\r}"}
{"i": "6065702117048320", "t": "Implement below function.\rint getRandom(int N, int K[]) \r Constraints: \r->K is sorted and contains elements in range [0,N)\r->Output should be a random number between [0,N) excuding elements from K\r->probability of generated number should be 1/(N-K.length) and not 1/N\r-->int uniform(int N) is given which returns random number [0,N) with 1/N probability for each number.\r->No more than O(1) memory\r->No more than O(N) time\r Below is my solution but it uses O(N) space.public int randomNumber(int N, int[] K) { // K is sorted\r\n\r\n\t//assumed size of K is less than N\r\n\tint remains[] = new int[N-K.length];\t\r\n\t//i is index [0,N-1], j is an index of K, k is an index of remainings\r\n\t//Fill remaining array\r\n\tfor (int i=0,j=0,k=0;i<N;i++){\r\n\t\tif (i!=K[j]){\r\n\t\t\tremainings[k++]=i;\t\r\n\t\t}else{\r\n\t\t\tj++;\r\n\t\t}\r\n\t}\r\n\tint index = uniform(remainings.length);\r\n\treturn remainings[index];\r\n}\r\n\r\nTime complexity: O(N)\r\nSpace Complexity: O(N)"}
{"i": "6553387063574528", "t": "Solve the given equation in one variable 'x'. The equation will be either linear of quadratic, i.e. the maximum degree of the equation will be 2. The usual precedence of the operation will hold true. There won't be any other operations apart from +, -, * and /. x will not present in the donominator, and only the elipse-shaped \"()\" brackets can exist in a given test. The constant in the equation will be smaller than 1000. We can not ignore the * operation.\r Sample Input\r1>\tx + 3 * 5 = 80\r2>  (x-3)*(x+4) = 0\r3>\tx * (2 * x - 3) + x / 3 = x / 3 - 1\r Output\r1>\t65\r2>\t-4 and 3\r3>\t0.5 and 1.0"}
{"i": "5963086758412288", "t": "Given a result in string of pass, fail, blocked, unknown as pppppppfffffbbbbbuuuuu or pppppppppppppppfffffff or pfpfpfpfpfpfpfpfpuuuuuuuuu or any combination of characters from p,f,b, or unknown character say u or x or y or z... question is write a program which can identity a pattern like all tests passed or all tests are failing or tests started failing (blocking issue may be) or unknown pattern... this is what my friend recall if someone also faced this question and recall better explaination , please add.. interviewer asked to code the solution not algo..."}
{"i": "4739759813427200", "t": "Tossing a coin ten times resulted in 8 heads and 2 tails. How would you analyze whether a coin is fair? What is the p-value?\rIn addition, more coins are added to this experiment. Now you have 10 coins. You toss each coin 10 times (100 tosses in total) and observe results. Would you modify your approach to the the way you test the fairness of coins?"}
