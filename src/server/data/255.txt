{"i": "4880578318958592", "t": "Print an n-ary tree with level. For e.g.0                    foo\r\n1          bar\t\tbaz\r\n2 foobar\t\t         \tbarfoo\r\n\r\nDesired output:\r\nLevel 0: foo\r\nLevel 1: bar baz\r\nLevel 2: foobar barfoo\r\n\r\nclass TreeNode\r\n{\r\n\tString name;\r\n\tList<TreeNode> getChildren();\r\n}\r\n\r\nvoid printLevels(TreeNode root)\r\n{\r\n\t// -- CODE--\r\n}"}
{"i": "6242440189050880", "t": "The strength of a pair integer sequences is defined by the number of integers that they have in common. You are required to find the strength of several pairs of integer sequences. \r INPUT\rThe first line of input contains T, the number of test cases. T test cases follow. Each test case contains 3 lines. The first line contains two integers N and M, which are the lengths of the two sequences. The next two lines contain the sequences. \r OUTPUT\rThis should contain T lines, each containing an integer representing the strength of the pair of sequences for the corresponding test case. \r CONSTRAINTS\rThe length of each sequence will be between 1 and 20 inclusive\rA sequence can contain an integer between 1 and 100 inclusive\rSequences will not contain duplicate integers \r SAMPLE INPUT\r3\r4 4\r1 2 3 4\r3 4 5 6\r4 5\r1 2 3 4\r1 2 3 5 6\r3 4\r1 2 3\r5 6 7 4 \r SAMPLE OUTPUT\r2\r3\r0"}
{"i": "5728628201488384", "t": "The binary weight of a positive integer is the number of 1's in its binary representation. For example, the decimal number 1 has a binary weight of 1, and the decimal number 7 (which is 111 in binary) has a binary weight of 3. \r Given a positive integer N, find the smallest integer greater than N that has the same binary weight as N. \r INPUT\rThe first line of input contains a number T the number of test cases. The next T lines contain a number N. \r OUTPUT\rFor each test case output a line containing the smallest number greater than N which has the same binary weight as N. \r CONSTRAINTS\r1 <= N <= 10000 \r SAMPLE INPUT\r2\r3\r7 \r SAMPLE OUTPUT\r5\r11"}
{"i": "5679665574313984", "t": "Given an integer N, find the smallest integer greater than N which is prime. \r INPUT\rThe first line of input contains T, the number of test cases. T test cases follow. Each test case contains a single integer N. \r OUTPUT\rThis should contain T lines, each containing the smallest prime integer greater than N. \r CONSTRAINTS\r1 <= T <= 5\r1 <= N <= 100 \r SAMPLE INPUT\r2\r6\r11 \r SAMPLE OUTPUT\r7\r13"}
{"i": "4786244462575616", "t": "you have the string ={ aabb, aafd,acff,aacg,.....} , if i am writing a as first char or first two char or first three char and so on, it should show the all unique combination of words started with the that characters for eg. say if iam writing aa then it show that aabb or aafd\r i have tried using hashmap is it increase my complexity or should i have to use list"}
{"i": "5098831913943040", "t": "Dart thrown land up uniformly and random at a distance from centre of a unit circle. Distance from center is in the range [0,1]. One who lands up farther from the center loses and the loser pays amount equal to distance from the centre. What is the expected pay?"}
{"i": "6468463698640896", "t": "in C++, Suppose we are creating 2 objects like:     \"sample *s1 = new sample(); and sample *s2 = new sample(); then in this case what will happen if we do like: *s1 = *s2;\" Please provide me the answer in detail"}
{"i": "5162225899667456", "t": "In an undirected graph G=(V,E) .Find the number of vertex-disjoint paths between two nodes s and t."}
{"i": "4861659206123520", "t": "/*\rQuestion 2 / 36 (FizzBuzz)\rWrite a program which prints the numbers from 1 to N, each on a new line. But for multiples of three print \u201cFizz\u201d instead of the number 3 and for the multiples of five print \u201cBuzz\u201d.  For numbers which are multiples of both three and five print \u201cFizzBuzz\u201d. Read in the input number from STDIN.\r Sample Input #00:\r 15\r Sample Output #00 :\r 1\r2\rFizz\r4\rBuzz\rFizz\r7\r8\rFizz\rBuzz\r11\rFizz\r13\r14\rFizzBuzz\r   Explanation:\r Position 3,6,9,12 have the word \"Fizz\" because they are multiples of 3.\r Positions 5 and 10 have the word \"Buzz\" because they are multiples of 5.  \r Position 15 has the word FizzBuzz because it is a multiple of both 3 and 5.  \r   */\r  import java.io.*;\rclass Solution {\r    public static void main(String args[] ) throws Exception {\r        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\r        System.out.println(\"Enter the value of N\");\r        int N=Integer.parseInt(br.readLine());\r        Solution objSolution=new Solution();\r        objSolution.fizzBuzz(N);\r    }\r    public static void fizzBuzz(int N) throws IOException\r    {\r         for(int i=0;i<=N;i++)\r        {\r            if((i%5==0)&&(i%3==0))\r            {\r                System.out.println(\"fizzBuzz\");\r            }\r            else\r            {\r                if((i%3)==0)\r                {\r                     System.out.println(\"Fizz\");\r                }\r                if((i%5)==0)\r                {\r                    System.out.println(\"Buzz\");   \r                }\r                if((i%3!=0)&&(i%5!=0))\r                   {\r                       System.out.println(i);\r                   }\r             }\r        }\r       }\r}\r   ----------------------------------------\rWhat is the complexity of this algorithm ?\rIs there any solution with better efficiency ?"}
{"i": "5728785773101056", "t": "Given a binary tree. Modify it in such a way that after modification you can have a preorder traversal of it using only right pointers. During modification you can use right as well as left pointers. Write complete code and dry run it for some test cases"}
{"i": "6229237509914624", "t": "Given N numbers , [N<=10^5] we need to count the total pairs of numbers which have a difference of K. [K>0 and K<10^9]. The solution should have as low of a computational time complexity as possible.\r Input Format:\r 1st line contains N & K (integers).\r2nd line contains N numbers of the set. All the N numbers are assured to be distinct.\r  Output Format:\r One integer saying the no of pairs of numbers that have a diff K.\r Sample Input #00:\r5 2\r1 5 3 4 2\r Sample Output #00:\r3\r Explanation:\rThe possible pairs are (5,3), (4,2) and (3,1)."}
{"i": "5148778843602944", "t": "Find cousins of a given node in a Binary tree and  BST.\r My Approach:Steps:(Using level order Traversal)\r\n1. Create a queue  q and en-queue root element and take variable qSize and a flag=true\r\n2. Start a loop and check queue is empty or not\r\n    {\r\n      if qSize==0 then qSize=q.size();\r\n      if not flag then print the current queue (q)\r\n      Start one more loop and check for qSize>0\r\n      {      qSize--\r\n             x=deque();\r\n        if((x.left != null && x.left== key) || (x.right!= null && x.right== key))\r\n       {\r\n           flag=false\r\n           continue\r\n       }\r\n       enqueue(x.left)\r\n       enqueue(x.right)\r\n      }\r\n   }"}
{"i": "6047481959809024", "t": "For a given string of some sentence, reverse words in that sentence. Ex: I am Don..return Don am I."}
{"i": "5096672887570432", "t": "For given set of natural number, suppose we can negate some number. Find what all number we should negate such that sum of all number (after negating some number) is zero. For ex: {1,2,3} return {-1, -2}, {1,2,3,4} return {-1,-4} or {-2,-3}. 1st check if such number in given set exist or not. If not return empty array else return numbers."}
{"i": "6338884266885120", "t": "Picture a restaurant kitchen with tickets of customer\u2019s orders which has a start time, end time of when the order was completed, and price. How would you find the longest contiguous time that tickets were processed within a given day?"}
{"i": "5725080826937344", "t": "using a log generated by a multiprocessor machine, which contains start and end time of each process, find the longest slot of time in which the machine wasn't idle.\rthe log is sorted by the process's start time"}
{"i": "5426941377118208", "t": "How to convert binary tree to BST inplace.?\r P.S.  shape of binary tree should be same after converting it into BST"}
{"i": "5648527329853440", "t": "Question: You are given a CSV file with 3 columns -- all integers: \r id,parent,weight \r10,30,1 \r30,0,10 \r20,30,2 \r50,40,3\r40,30,4\r 0 is the assumed root node with weight 0\r which describes a tree-like structure -- each line is a node, 'parent' refers to 'id' of another node. \r Print out, for each node, the total weight of a subtree below this node (by convention, the weight of a subtree for node X includes the own weight of X). \r You may assume that the input comes pre-parsed as a sequence of Node objects \r(substitute the appropriate syntax for java/python/c++): \r Node {\r  int id; \r  int parent; \r  int weight;\r  // ... you can add other fields right here, if necessary \r}\r implement the following:\rpublic void printSubTreeWeight(List<Node> nodes) {\r....}"}
{"i": "5205047260479488", "t": "public static LinkedList reverse(LinkedList current)\r\t{\r\t\tLinkedList result=null;\r\t\tif(current==null) return null;\r\t\tif(current.next==null) return current;\r \t\t//LinkedList current=head;\r\t\tLinkedList prev=null;\r\t\tLinkedList next=current.next;\r\t\twhile(current!=null)\r\t\t{\r\t\t\tnext=current.next;\r\t\t\tcurrent.next=prev;\r\t\t\tprev=current;\r\t\t\tcurrent=next;\r\t\t}\r\t\tresult=prev;\r \t\treturn result;\r\t}"}
{"i": "6326059494539264", "t": "How to add a more memory dynamically to an array without deleting the old memory, means, expanding an aray without deleting the old one?"}
{"i": "5711002997882880", "t": "what is green thread in java..??"}
{"i": "5664860016738304", "t": "Suppose you have N machines connected to a network.\rNow you generate a new file on one machine, and want to sync up across all machines. please design a system to accomplish this task and also analyze the error tolerance issue."}
{"i": "5729537878917120", "t": "Given two unsorted integer arrays A & B of unequal length.\rFind an element from A(say 'X') and another element from B(say 'Y') such that |X-Y| is minimum.\r Note: A & B can contain positive/negative numbers.\r How can you find this without sorting both arrays?\rHow can you find this by sorting both arrays?"}
{"i": "5633395035996160", "t": "Given two log files, each with a billion usernames (each username appended to the log file), find the usernames existing in both documents?"}
{"i": "5754369232338944", "t": "How to partition an array of integers into subarrays so that the average of the two subarrays becomes equal, in efficient way?...."}
{"i": "5721852034940928", "t": "how to convert array into sub arrays"}
{"i": "5655194142507008", "t": "how to convert array into sub array so that we can access element from array into sub arrays in serial manner"}
{"i": "6296068761321472", "t": "Find the longest path in a binary tree\r with one bend.\rOne bend means like SAY I HAVE\r                1\r           2         44\r       3\r With one bend means all the nodes means if we start connecting nodes then connect as much as possible in a single line and u can take maximun one bend.Say left left left than right right right.That is maximum one turn..It is not same as diameter say ia have\r         1\r     /\r   2\r       \\\r         3\rDiameter of above is 3 but if we take all the nodes then we will have 2 bends..\r  So we will two nodes to get nodes with one bend..hope m clear"}
{"i": "5728965574524928", "t": "Implement your own  sizeof operator using bitwise operation ."}
{"i": "5169800024162304", "t": "design a system to return an unique ID for each request. For most of requests, the ID value should increase as time goes, the system should handle 1000 requests per second at least.\rtimestamps alone is not valid since there might be multiple requests with same timestamps."}
