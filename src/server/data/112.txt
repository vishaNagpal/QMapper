{"i": "4862471882932224", "t": "Given a set find its power set. (This question is from CTCI) Interviewer then discussed the complexity of my solution. He asked me to explain him how the complexity is 2^n? As per my solution, I was iterating over an arraylist which contained the set elements so the size of list was getting doubled in every iteration. Hence the complexity (2^0 + 2^1 + 2^2 +.....+2^n-1 = 2^n)"}
{"i": "5708537557680128", "t": "Given a string, add some characters to the from of it so that it becomes a palindrome. E.g.1) If input is \"abc\" then \"bcabc\" should be returned. 2) input -> \"ab\" output -> \"bab\" 3) input -> \"a\" output -> \"a\""}
{"i": "5701538572926976", "t": "You are given a binary tree. Each node in the tree is a house and the value of node is the cash present in the house. A thief can rob houses in alternate levels only. If thief decides to rob house at level 0 then he can rob houses in levels 2,4,6... or he can rob houses in levels 1,3,5,7...Find out the maximum possible amount thief can rob."}
{"i": "5733020146335744", "t": "A list of students and their marks in three subjects are given in the respective order.\r Student1\t20\t40\t65\rStudent2\t35\t40\t50\rStudent3\t10\t55\t65\r Given n = 2. \r Find the name of the students who has got top marks in atleast n subjects.\rOutput for the above example\r student1\rstudent3\r since they got top marks in atleast 2 subjects"}
{"i": "5752392394997760", "t": "Create a RESTful microservice that implements a card shuffling algorithm, as defined below.  Should have evidence of test-driven development with unit tests. Use best practices of interfaces and generics for abstraction, preferably implementing a strategy pattern for deploy-time dependency injection of a shuffling algorithm.\rRequirements:\r\u00b7         Create a microservice that stores and shuffles card decks.\r\u00b7         A card may be represented as a simple string such as \u201c5-heart\u201d, or \u201cK-spade\u201d.\r\u00b7         A deck is an ordered list of 52 standard playing cards.\r\u00b7         Expose a RESTful interface that allows a user to:\r\u00b7         PUT an idempotent request for the creation of a new named deck.  New decks are created in some initial sorted order.\r\u00b7         POST a request to shuffle an existing named deck.\r\u00b7         GET a list of the current decks persisted in the service.\r\u00b7         GET a named deck in its current sorted/shuffled order.\r\u00b7         DELETE a named deck.\r\u00b7         Design your own data and API structure(s) for the deck.\r\u00b7         Persist the decks in-memory only, but stub the persistence layer such that it can be later upgraded to a durable datastore.\r\u00b7         Implement a simple shuffling algorithm that simply randomizes the deck in-place.\r\u00b7         Implement a more complex algorithm that simulates hand-shuffling, i.e. splitting the deck in half and interleaving the two halves, repeating the process multiple times.\r\u00b7         Allow switching the algorithms at deploy-time only via configuration."}
{"i": "5642960319283200", "t": "If you can hop 1, 2, or 3 steps at a time, calculate the total number of possible combinations for `n` steps."}
{"i": "5689208527126528", "t": "Find longest consecutive path in a binary tree.\r1. the path can be decreasing or increasing, i.e [1,2,3,4] and [4,3,2,1] are both valid\r2. the path can be child-parent-child, not necessarily a parent-to-child path\r similar to this question: http://www.geeksforgeeks.org/longest-consecutive-sequence-binary-tree/"}
{"i": "5691693232816128", "t": "Given a singly linked list: 1->2->3->4->5\rChange it to 1->5->2->4->3 using O(1) space"}
{"i": "5704108573982720", "t": "Implement delete operation for N-ary tree. Your function should return a list of roots after deletion operation. Notice that your delete function only delete one node instead of a subtree. The delete function takes a list of nodes to be deleted.private class TreeNode {\r\n   int val;\r\n   TreeNode[ ] child;\r\n}\r\n\r\nList<TreeNode> delete(TreeNode root, HashSet<TreeNode> set) { }"}
{"i": "5637656839979008", "t": "You have a grid of size N x M. Rows of the grid are numbered from 1 to N from top to bottom and columns of the grid are numbered from 1 to M from left to right. So, top-left corner is indexed as (1,1) and bottom-right corner is indexed as (N,M).\r Cost of visiting a cell at index (i,j) is denoted by C[i][j]. Cost of changing the direction of your facing at index (i,j) is denoted by P[i][j].\r You have to start from cell (1,1) and reach to cell (N,M) with minimum cost. At cell (1,1), you can either face towards 'Right' or face towards 'Down'. At any point of time, you can either face 'Right' or face 'Down'.\r There are 2-types of moves allowed:\r1. Move one cell towards the facing direction i.e. if you are facing 'Right', you can move one cell 'Right' or if you are facing 'Down', you can move one cell 'Down'. The cost of visiting cell (i,j) will be C[i][j].\r2. Change the direction of facing i.e. if you are facing 'Right', you can now face 'Down' or if you are facing 'Down', you can now face 'Right'. The cost of changing the facing direction at cell (i,j) will be P[i][j].\r Find the minimum cost to reach (N,M) after starting from (1,1).\r Constraints:\r1 <= T <= 3\r1 <= N,M <= 1000\r1 <= C[i][j], P[i][j] <= 1000\r Input Format:\rFirst line of each testfile contains T, the number of test cases.\rIn each testcase, First line contains two inetgers N and M denoting the dimensions of the grid.\rNext N lines contains M integers each denoting the cost matrix C.\rNext N lines contains M integers each denoting the cost matrix P."}
{"i": "5107149794443264", "t": "given a stream of natural numbers ,\r and a array J contains integers in increasing orders\roperations performed J = [2,3,4]\r1 2 3 4 5 6 7 8 9 10\u2026\u2026\u2026\u2026..27....100...1111\rfirst operation\r J[0] = 2 => remove every 2nd integer\r now the stream is\r1 3 5 7 \u2026 27\rJ[1] = 3\rremove every 3rd\rstream is now\r1 3 7 \u2026\r    3rd\rgiven a natural number n , find if it will survive given J, or at what index it will\r die."}
{"i": "5693718846767104", "t": "Return the length of longest possible chunked palindrome string.\r Examples : \r Input : VOLVO \rOutput : 3\rExplanation :\r(VO)L(VO)\r  Input : merchant \rOutput : 1\r Explanation : No chunks possible.\r Input :\r ghiabcdefhelloadamhelloabcdefghi\r Output : 7\r Explanation :\r (ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)"}
{"i": "5754527530614784", "t": "Given a list of manager and employee information represented in hashMap entries {AAA->BBB,CCC,EEE},{CCC->DDD}.\rPrint company structure tree with proper indentations. BBB, CCC and EEE directly reports to AAA, so they have one white space before \"-\", DDD reports to CCC, it has two whitespace before \"-\". The input is map<String,List<String>>-AAA\r\n -BBB\r\n -CCC\r\n  -DDD\r\n -EEE"}
{"i": "5166346791813120", "t": "A producer continuously produces a stream of characters. There are multiple consumer threads which read the chars and match to one of known strings and increment the counter for that pattern. Write the consumer function. Show how you will synchronize and maintain parallelism.\r Ex: Producer: abcdegabccaabbaacv ......\rKnown strings[] = {\"ab\", \"aa\", \"fff\" ... }\rpatternMatchCount[] = {3, 2, 0 ... }"}
{"i": "5638730112040960", "t": "Design OO  food delivery app catering to use cases -\r1) User can search different restaurant\r2) User can select a restaurant\r3) User sees a menu\r4) Restaurant can change the menu any time\r5) User adds an item from menu \r6) User orders the food\r7) User can track the order in real time\r8) User can cancel the order\r9) User pays for the order"}
{"i": "None", "t": "Design food delivery app (OO design). Cater to use cases like search for different restaurants, selecting a restaurant, select an item from menu, menu can be updated in real time by restaurant, order the food, customer keeps track of the order in real time, payment for the order, cancel the order etc."}
{"i": "5683755059511296", "t": "Design Uber low level OO design. Cater to use cases like search for a ride, different category of rides, select a ride, registration for a user and driver, paying for ride etc."}
{"i": "5174005121155072", "t": "Find sum of n elements after kth smallest element in BST. Tree is very large, you are    not allowed to traverse the tree."}
{"i": "5725166060437504", "t": "As an input, you have points on a 2D graph. You aim to find a straight line that can fit as my points as possible. Return, the maximum number of points you can fit."}
{"i": "5725943181082624", "t": "Given a number, return the count of numbers having non-repeating digits till that number starting from 1?"}
{"i": "5685105155637248", "t": "For a linked List p1 ->p2 ->p(n-1)->p(n) shuffle it to be p(1) -> p(n) ->p(2) ->p(n-1)....p(n/2)"}
{"i": "5661073739874304", "t": "Given the Java 8 Function interface:\rinterface Function<T,R> {\rR apply<T t>;\r}\rProvide code that will apply the composition of the following implementations and would have the type\rFunction<String, Integer>:\rclass GetBytes<String, byte[]> {\rbyte[] apply<String value> {\rreturn value.getBytes<>;\r}\r}\rclass ArrayLength<byte[], Integer> {\rInteger apply<byte[] value> {\rreturn value.length;\r}\r}\rIf the input is \u201chello world\u201d what would the expected result of the function be?"}
{"i": "5708280396513280", "t": "Function to find if the characters of the sample string is in the same order in the text string. They need not be\rconsecutive.\rEg.. TextString: Redmond, Washington\rSample string :Rdd Waitn"}
{"i": "5683186110562304", "t": "https://www.hackerrank.com/challenges/array-and-simple-queries\r Given two numbers N and M. N indicates the number of elements in the array A[](1- indexed)  and M indicates number of queries. You need to perform two types of queries on the array A[] .\rYou are given M queries. Queries can be of two types, type 1 and type 2.\r Type 1 queries are represented as 1 i j : Modify the given array by removing elements from  to  and adding them to the front.\r Type 2 queries are represented as 2 i j : Modify the given array by removing elements from  to  and adding them to the back.\r Your task is to simply print | A[1] - A[N] |  of the resulting array after the execution of M queries followed by the resulting array.\r Note While adding at back or front the order of elements is preserved."}
{"i": "5707619374202880", "t": "Given a dictionary and an char array print all the valid words that are possible using char from the array.\r Ex- char[] arr = {'e','o','b', 'a','m','g', 'l'}\r Dict - {\"go\",\"bat\",\"me\",\"eat\",\"goal\", \"boy\", \"run\"}\r Print - go, me, goal.\r We can pre-compute as much we want but the query time must be optimal."}
{"i": "5684019468435456", "t": "Given a pattern and a string - find if the string follows the same pattern Eg: Pattern : [a b b a], String : cat dog dog cat"}
{"i": "5631912925200384", "t": "public interface FirstCommonAncestor {\r     /**\r     * Given two nodes of a tree,\r     * method should return the deepest common ancestor of those nodes.\r     *\r     *          A\r     *         / \\\r     *        B   C\r     *       / \\   \\\r     *      D   E   H\r     *         / \\\r     *        G   F\r     *\r     *  commonAncestor(D, F) = B\r     *  commonAncestor(C, G) = A\r     *  commonAncestor(E, B) = B\r     */\r    Node commonAncestor(Node one, Node two);\r}class Node {\r\n \r\n    final Node parent;\r\n    final Node left;\r\n    final Node right;\r\n \r\n \r\n    public Node(Node parent, Node left, Node right) {\r\n        this.parent = parent;\r\n        this.left = left;\r\n        this.right = right;\r\n    }\r\n \r\n    boolean isRoot() {\r\n        return parent == null;\r\n    }\r\n}"}
{"i": "5647545129762816", "t": "Q. Given an array of numbers. Print all the pairs (2) of numbers in the array if the sum of those numbers is also present in the array. Write in C"}
{"i": "5633833983541248", "t": "Given a matrix  consisting of only 0's and 1's find the largest rectangular sub-array consisting of only 1's. Rows  can be interchanged with each other and columns too can be interchanged with each other"}
{"i": "5711620404674560", "t": "Given N stacks, each stack contains Si elements, find the maximum sum of the M numbers in the N stacks. To get the number of the stack, only supporting get the top number. For example, S=[1,200,1,2,3], if you want to get the number 200, you need choose 3,2,1 first.\rEX:\rS1=[1,1,100,3]\rS2=[2000,2,3,1]\rS3=[10,1,4]\rthe maximum sum of the 3 numbers in the above stacks is 3+100+3=107. \rAny better solution for this problem?"}
