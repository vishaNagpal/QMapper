{"i": "5651720030912512", "t": "Check if two given binary trees(expression trees with two characters 'a' and 'b' and obviously operators like +,-,*) are mathematically equivalent?", "k": ["mathematically equivalent", "expression trees", "binary trees", "check", "expression"]}
{"i": "5176331307319296", "t": "We have a List of FlightRoutepublic static class FlightRoute {\r\n        String from;\r\n        String to;\r\n        int time;\r\n        ....\r\n    }and write a function to find Shortest Path: findShorestPath(String start, String end, List<FlightRoute>routes)", "k": ["flightroutepublic static class", "static class flightroute", "int time", "find shortest path", "string"]}
{"i": "5113685182775296", "t": "Iterate over a singly linked list backwards. Call print on each node.\r Example: The list A->B->C should print as\r \"C B A\"class Node {\r\n  public Node next;\r\n  public String value;\r\n}There are 4 solutions\r1) recursive\r2) iterative with O(n) memory\r3) iterative with O(1) memory and O(n\u00b2) runtime\r4) iterative with O(1) memory and O(n) runtime (for this solution the initial list may be modified)\r Explain all 4 solutions and write the code for solutions 3 and 4", "k": ["linked list backwards", "singly linked list", "singly linked", "list backwards", "linked list"]}
{"i": "5682803648757760", "t": "You are given an array of integers. \r Write an algorithm that brings all nonzero elements to the left of the array, and returns the number of nonzero elements. \r The algorithm should operate in place, i.e. shouldn't create a new array.\r The order of the nonzero elements does not matter. The numbers that remain in the right portion of the array can be anything. \r Example: \rgiven the array [ 1, 0, 2, 0, 0, 3, 4 ], \ra possible answer is [ 4, 1, 3, 2, ?, ?, ? ], 4 non-zero elements, where \"?\" can be any number. \r Code should have good complexity and minimize the number of writes to the array.", "k": ["array", "nonzero elements", "elements", "nonzero", "number"]}
{"i": "5180942491582464", "t": "using System;\rusing System.Collections.Generic;\rusing System.Linq;\rusing System.Text;\rusing System.Threading.Tasks;\r namespace ArrayProblems\r{\r    public class MultiplyTwoLargeNumber\r    {\r        public static string MultiplyBigNumbers(string s1, string s2)\r        {\r            char[] num1 = s1.ToCharArray();\r            char[] num2 = s2.ToCharArray();\r            //string=99\r            //char--> 9 , val --> 57(48+9) \r            //so s[i]-'0' will give val 9 and char as horizontal tab\r             char[] result = new char[num1.Length + num2.Length]; // Default 0 '/0'  2 ==> 50 '2'\r            int carry = 0;\r            int offset = 0;\r             for (int i = num1.Length - 1; i >= 0; i--)\r            {\r                int tail = result.Length - 1 - offset;\r                for (int j = num2.Length - 1; j >= 0; j--)\r                {\r                    int resval = 0;\r                    if(result[tail]!=0)\r                    {\r                        resval = result[tail] - '0';\r                    }\r                    int sum =  resval+ ((num1[i] - '0') * (num2[j] - '0')) + carry; //remember to add result before taking mode \r                    result[tail] = (char)((sum % 10) + '0');\r                    carry = sum / 10;\r                    tail--;\r                }\r                if (carry > 0)\r                {\r                    int res = (result[tail] != 0) ? (result[tail] - '0') + carry : result[tail] + carry;\r                     result[tail] = (char)(res + '0');\r                    carry = 0;\r                }\r                offset++;\r            }\r             return new string(result);\r        }\r      }\r}", "k": ["public class multiplytwolargenumber", "public static string", "static string multiplybignumbers", "horizontal tab char", "taking mode result"]}
{"i": "5768760305647616", "t": "Find three non-overlap windows of size k in an int array, that together has a maximum sum \rof the 3k entries.\rexample\rint[] nums = [1,2,1,2,6,7,5,1] \rk = 2\routput\r[1,2],[2,6],[7,5]", "k": ["find three non-overlap", "non-overlap windows", "windows of size", "maximum sum", "int array"]}
{"i": "5724734743379968", "t": "Given a list of words with lower and upper cases.   Implement a function to find all Words that have the same unique character set .  \r For example:\rMay  student  students dog studentssess\r god  Cat act tab bat flow wolf lambs  Amy Yam balms looped poodle john alice\r output:\rmay amy  \rstudent  students  studentssess\rdog god\rcat act\rtab bat\rflow wolf\rlambs balms\rlooped, poodle", "k": ["cat act tab", "god cat act", "upper cases", "act tab bat", "tab bat flow"]}
{"i": "5728041465544704", "t": "Write test cases to test a browser App", "k": ["write test cases", "browser app", "write test", "test cases", "app"]}
{"i": "5068525614923776", "t": "A = \"ffgggtvshjsdhjfffffffhvjbjcharu\"\rFind the max consecutive repitative chracter\rOutput : f -> 7", "k": ["repitative chracter output", "find the max", "chracter output", "max consecutive repitative", "consecutive repitative chracter"]}
{"i": "5705773536509952", "t": "A = {1,2,4,-6,5,7,9,....}\rB = {3, 6, 3, 4, 0 .......}\rn = 5 -> pairs whose sum is n\r Output = (1,4), (5,0)....", "k": ["pairs whose sum", "output", "pairs", "sum"]}
{"i": "5091778836299776", "t": "Given an int array without repeated elements and a target, count the total number of subset that can be generated from the array such that min (subset) + max (subset)  < target\rpublic int countSubSet(int[] nums, int target){\r }", "k": ["public int countsubset", "target public int", "count the total", "repeated elements", "total number"]}
{"i": "5700441468829696", "t": "Data structure design, N horse races, there are 10 checkpoints, whenever a horse through a check point will produce a (horse number, check point number) message, then design a data structure and algorithm to update the messages and then get the top 3 horse efficiently.", "k": ["check point number", "data structure design", "data structure", "check point", "point number"]}
{"i": "5692984331862016", "t": "Input friend\u2019s relation {{1,2}, {2,3}, {3,4}}, could you split all the users into two groups and for the user in each group, all the users do not know each other. So the expected output should be group1 {1,3}, group2 {2,4}. If it is cannot be spitted into two group, just return \u201cimpossible\u201d", "k": ["input friend", "friend \u2019s relation", "users", "input", "relation"]}
{"i": "5187607743954944", "t": "Given:\ra encoded to 1\rb encoded to 2\r....\rz encoded to 26\r You can translate a number to a string:\r '123' can be translated to 'abc'\rbut also can be translated to 'aw','lc' which gives 3 total translations\r'12' can be translated to 'ab' and 'l' -> 2 translations\r Write a function to get the number of valid combinations from a number like '123123123'", "k": ["encoded", "translations write", "write a function", "translated", "number"]}
{"i": "5715775307382784", "t": "Given an array that contains both positive and negative integers, find the start and end index of the subarray that achieves the maximum subarray product using one pass", "k": ["maximum subarray product", "negative integers", "find the start", "positive and negative", "start and end"]}
{"i": "5169267562512384", "t": "find the given Binary tree is mirrored tree or not \r should be like  \r                   60\r               /      \\\r           30        30\r         /    \\        /   \\\r       20   50    50  20", "k": ["binary tree", "mirrored tree", "binary", "find", "tree is mirrored"]}
{"i": "5758569019342848", "t": "Given a BST (Binary Search Tree) , Each node value should replace with sum of the node which are greater-than the given node. \r conditions : \rNo Extra space / variable can use\rModify the existing tree in optimal way.", "k": ["binary search tree", "binary search", "search tree", "replace with sum", "bst"]}
{"i": "5717364176846848", "t": "how to find leaf node value from preorder sequence of BST without rebuilding the tree", "k": ["find leaf node", "sequence of bst", "bst without rebuilding", "rebuilding the tree", "find leaf"]}
{"i": "5695618220556288", "t": "deleted", "k": ["deleted"]}
{"i": "5746785508130816", "t": "Say you have an array for which the ith element is the price of a given stock on day i.\r Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\r, but each time you sell you need to pay transaction fee, please calculate the maximum profit you can take.\r public int maxProfit(int[] prices, int fee) {\r }", "k": ["ith element", "maximum profit", "stock", "sell", "stock multiple times"]}
{"i": "5719394085765120", "t": "1) Given a file containing lines of chars, find if it contains \"aaaaab\\naaaaa\" string pattern. Need to return true only if contains the EXACT pattern specified  (observe the new line character). \r 2) How do you differentiate between actual new line and the new line character?\r 3) what if the file is way too big to bring it all in memory?", "k": ["line character", "string pattern", "exact pattern", "aaaaab", "naaaaa"]}
{"i": "5690590961336320", "t": "for a binary tree, print the root to the leaf path, but add \"_\" to indicate the relative position.\rexample:A \r\n       /   \\  \r\n      B     C \r\n     / \\   / \\\r\n    D  E   F  G\r\n\r\noutput\r\n_ _ A\r\n_ B\r\nD\r\n\r\n_A\r\nB\r\n_E\r\n\r\nA\r\n_C\r\nF\r\n\r\nA\r\n_ C\r\n_ _ G", "k": ["binary tree", "print the root", "leaf path", "relative position", "tree"]}
{"i": "5739022086307840", "t": "Design a system having multiple jobs, interacting with each other such that :\r1) A job can run for very long periods (1-2 days)\r2) A node can fail/crash on which certain job is running\rsystem should be scalable\r3) Amount of data getting transferred is huge\r4) Data in the system is very sensitive and needs security\rjob/s can fail", "k": ["node can fail", "long periods", "transferred is huge", "amount of data", "running system"]}
{"i": "5710673423106048", "t": "Top View of a Binary Tree in constant space", "k": ["binary tree", "top view", "tree in constant", "constant space", "view"]}
{"i": "5644221689102336", "t": "Given a pattern containing only Is and Ds. I for increasing and D for decreasing. Devise an algorithm to print the MINIMUM number following that pattern. Digits from 1-9 and digits can\u2019t repeat.\r    Example:\r   1. Input: D        Output: 21\r   2. Input: I        Output: 12\r   3. Input: DD       Output: 321\r   4. Input: II       Output: 123\r   5. Input: DIDI     Output: 21435\r   6. Input: IIDDD    Output: 126543\r   7. Input: DDIDDIID Output: 321654798", "k": ["input", "output", "didi output", "iiddd output", "ddiddiid output"]}
{"i": "5752938854088704", "t": "Implement ConcurrentHashMap class in Java", "k": ["implement concurrenthashmap class", "class in java", "implement concurrenthashmap", "java", "concurrenthashmap class"]}
{"i": "5687466372628480", "t": "Implement LinkedHashMap class in Java", "k": ["implement linkedhashmap class", "class in java", "implement linkedhashmap", "java", "linkedhashmap class"]}
{"i": "5719764526694400", "t": "You have been given a grid with some doors, walls and some empty spaces.\r1st part : You have to tell the least no of moves to go from random position in the grid to the nearest door. You can move in four directions only, i.e, left, right, above, below.\r2nd part : Least distance of every empty cell to the nearest door. Lots of discussion was done on both the parts of the problem.", "k": ["nearest door", "empty spaces", "door", "grid", "walls"]}
{"i": "5672570352304128", "t": "Design garbage collector in Java", "k": ["design garbage collector", "collector in java", "design garbage", "java", "garbage collector"]}
{"i": "5688201214689280", "t": "/**\r * Definition for an interval.\r * public class Interval {\r *     int start;\r *     int end;\r *     Interval() { start = 0; end = 0; }\r *     Interval(int s, int e) { start = s; end = e; }\r * }\r */\rGiven a list of intervals, and a target interval\rOur goal is to merge these intervals, so that the results of the merge can cover the target interval, return the minimum number of the original interval required for this merge\r For example\rIntervalList: [-1, 9] [1, 10] [0, 3] [9,10] [3, 14] [2, 9] [10, 16]\rTarget interval: [2, 15]\rwe find that there are several ways to cover [2,15], such as:\r[-1, 9] + [9,10] + [10, 16] or [1, 10] + [10, 16].\rWe want to merge the least number of ways, so here should return 2", "k": ["target interval", "interval", "public class interval", "definition", "original interval required"]}
