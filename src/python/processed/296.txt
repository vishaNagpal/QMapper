{"i": "17597662", "t": "Given an array of integers, find all sub-arrays whose elements sum zero.\r1.-1,4,-4 has 3 such arrays 1 to -1, 1 to -4 and 4 to -4", "k": ["find all sub-arrays", "sub-arrays whose elements", "elements sum", "array of integers", "integers"]}
{"i": "17596662", "t": "Write a java program to count the words from the file Othello.txt\r- Have the stop words library to filter the words like (to, the, and). (We do not want to count these words)\r- Measure the time taken to execute the code.\r Small input (From File)     :    othello.txt\rOutput (In Console) :\r Welcome - 1\rbhive -1\rcommunity - 2\rJoin -1\rwin - 1\rexciting - 1\rprizes -1\rTime Taken: 100 milliseconds\rBigger Input (From File) : othello.txt\rDoes your code execute within 10 seconds?.", "k": ["stop words library", "write a java", "java program", "library to filter", "program to count"]}
{"i": "17572668", "t": "//Q. Given an array of integers,write a function that retrieves unique instances of any duplicates, returning them in a //new array -\r// [2,1,2,4,3,1,5,1]\r//= [2,1]\r// [1,1,1,1,1,1,1,1,1]\r// =[1]\r // Write test cases for this function", "k": ["write test cases", "write test", "write", "array", "function"]}
{"i": "17543678", "t": "Q: If you have all the companies that are traded, and live inputs are coming of which company is being traded and what is the volume, how do you maintain the data, so that you can carry out operation of giving the top 10 most traded companies by volume of shares most efficiently.\rA: I juggled between Hash Map and Max Heap. I said Max Heap, since I can take out top 10 companies in a jiffy with a Max Heap. But then he asked you will need to find a company everytime there is a trade, which will take quite some time in Heap. He pointed out that in real world scenario, number of trades happening, and hence searching of the company and updating it, will be many times more than finding top 10. Which bought me to HashMap. Updations can happen in Real time, while finding top 10 can be done in O(n) or O(nlog(n)) time.\rEven that wasn't optimal obviously. The interviewer was very nice and friendly type guy. He stressed that at every trade, at most, only 1 company will change in my top 10. This hit me and got me to the correct answer that we keep all actual data in HashMap, but also maintain a MinHeap of 10 most traded company.", "k": ["max heap", "heap", "shares most efficiently", "hash map", "live inputs"]}
{"i": "17425672", "t": "Q: If I give you a new book, and ask you to create the index which is found at the end of the book, how will you do it.\rA: I said for constant addition time of words (and page numbers) in the data structure, we can use Hashmap or TRIE. But since output has to be in alphabetic order, we will use a Trie DS, where at the end of each word, we simple store a list of page numbers.", "k": ["create the index", "page numbers", "book", "constant addition time", "numbers"]}
{"i": "17380675", "t": "Q: The New operator...how does it work, what are the steps?\rA: I just said it creates a new memory in the heap and the reference points to it. He seemed satisfied.", "k": ["operator", "work", "steps", "reference points", "creates"]}
{"i": "17544673", "t": "Q: Do you know what is a Binary tree? How would you go about coding for addition of a new element to Binary tree?\rA: I asked if they want a Binary Tree or a BST? When he said BST I just said we can have a recursive function in which we pass the root of the tree and see if the value to be added is smaller or bigger than the root, and depending on result, we go to left or right of the tree, assuming the left (or right) is not null. If null, just use new to create a memory location, put the value, and use the left reference of the root to link to this new memory.\tSimple basic stuff.", "k": ["binary tree", "binary", "tree", "bst", "root"]}
{"i": "17215679", "t": "Q: Do you know what is a stack? Explain\rA: Yes, explained LIFO push pop peek\rQ: In stack, Push and Pop are constant. What will you do if you want an operation which gives the min of the stack also in constant time?\rA: Question is straight out of Gayle's Book. You just maintain a new stack of minimum number till that point.", "k": ["lifo push pop", "explained lifo push", "lifo push", "push pop peek", "explained lifo"]}
{"i": "17188673", "t": "Implementation of Advanced set which have the functionality as \"Set\" in c++ along with extra functionality-Random number generator.Returns the random number from the set.", "k": ["extra functionality-random number", "functionality-random number generator.returns", "implementation of advanced", "advanced set", "extra functionality-random"]}
{"i": "17332676", "t": "Given a directed acyclic graph.How to represent it in the relational database for efficient retrieval of all the children nodes and all the parents of any node.(ex a->b here b is child of a and a is parent of b)", "k": ["directed acyclic graph.how", "directed acyclic", "acyclic graph.how", "graph.how to represent", "relational database"]}
{"i": "17221689", "t": "Given a string.Find the longest substring in it such that the substring contains only 2 unique characters.Ex- aabbcbbbadef Ans-bbcbbb", "k": ["aabbcbbbadef ans-bbcbbb", "unique characters.ex", "string.find the longest", "longest substring", "ans-bbcbbb"]}
{"i": "17539664", "t": "In a party there are n different-flavored cakes of volume V1, V2, V3 ... Vn each. Need to divide them into K people present in the party such that\r - Each member of party gets equal volume of cake (say V, which is the solution we are looking for)\r - A given member should get a cake of single flavour only i.e. You cannot distribute parts of different flavored cakes to same member.\r - Minimum volume of cake gets wasted after distribution so that means a maximum distribution policy", "k": ["different-flavored cakes", "volume", "party", "minimum volume", "cake"]}
{"i": "17425669", "t": "How do you remove duplicates from a dataset that does not fit into memory?", "k": ["fit into memory", "remove duplicates", "memory", "remove", "duplicates"]}
{"i": "17540663", "t": "Find the merge point of two linked list.", "k": ["find the merge", "linked list", "merge point", "find", "list"]}
{"i": "17332672", "t": "3)Reverse individual words of a sentence.", "k": ["reverse individual words", "reverse individual", "reverse", "individual words", "sentence"]}
{"i": "17473666", "t": "Reverse an integer without using temp variable.", "k": ["reverse an integer", "temp variable", "reverse", "variable", "integer"]}
{"i": "17542662", "t": "How to swap two bits in an integer.", "k": ["swap two bits", "integer", "swap", "bits"]}
{"i": "17406717", "t": "In a shop, product X is available in different quantities q1,q2,q3...... with price tags p1,p2,p3,...\r wap to purchase X of quantity Q such that total price is less and also number of baggage is less \r *Consider the cost to be optimum than baggage.\r (Sorry the trouble guys, I have edited the ques here)", "k": ["price tags", "shop", "product", "quantities", "tags"]}
{"i": "17511673", "t": "Wap to find kth largest element in a binary search tree", "k": ["binary search tree", "find kth largest", "kth largest element", "wap to find", "search tree"]}
{"i": "17467663", "t": "Given a binary tree convert it to doubly linked list, with left pointer of binary tree as prev pointer of doubly linked list and right pointer of binary tree as next pointer of doubly linked list.\r Example:\rInput:\rBinary tree with\rA as root\rB left of A\rC right of A\r B&C have no children\r Output:\r \t        B->A->C->null\r       null<-B<-A<-C", "k": ["doubly linked list", "doubly linked", "linked list", "binary tree convert", "binary tree"]}
{"i": "17316666", "t": "Given a linked list, print n nodes from tail of the list in reverse order\rExample:\r 1->2->3->4->5->6->7->8->9->10\r Output:\rn=3\r10->9->8", "k": ["print n nodes", "output", "nodes from tail", "reverse order", "linked list"]}
{"i": "17265677", "t": "What will be the output of the program ?\r #include< stdio.h >\rvoid fun(void *p);\rint i;\rint main()\r{\rvoid *vptr;\rvptr = &i;\rfun(vptr);\rreturn 0;\r}\rvoid fun(void *p)\r{\rint **q;\rq = (int**)&p;\rprintf(\"%d \", **q);\r}", "k": ["void fun", "int main", "void", "vptr", "fun"]}
{"i": "17250682", "t": "test(){\rreturn 3;\r}\rvoid main(){\rint i=2;\rfor(test();test();test();)\r{\rprintf(\"2\");\r}\r Output value or run-time error or compile time error ?", "k": ["compile time error", "test", "void main", "compile time", "run-time error"]}
{"i": "17256671", "t": "Given an array A of integers, find an integer k that is not present in A. Assume that the integers are 32-bit signed integers.", "k": ["find", "integers", "find an integer", "signed integers", "array"]}
{"i": "17264666", "t": "Given sorted arrays A and B of lengths n and m respectively,return an array C containing elements common to A and B. The array C should be free of duplicates.", "k": ["elements common", "sorted arrays", "array", "sorted", "lengths"]}
{"i": "17362664", "t": "In a 5*4 matrix what is the most optimal way of traversal and compare the time complexity for different solution ?", "k": ["traversal and compare", "compare the time", "time complexity", "matrix", "solution"]}
{"i": "17248670", "t": "How can you implement a Hashtable with any given data structure\rWhat is hash function\rHow can you resolve collisions", "k": ["implement a hashtable", "resolve collisions", "data structure", "hash function", "hashtable"]}
{"i": "17470662", "t": "Given an integer array, return the combinations of 4 array values whose sum is x\rEg: \rInput int array = {1,2,3,5,0,-2}\rReturn all possible combinations such that\ra+b+c+d = 1\rLike: -2 , 0 , -2 , 5 \r2 , -2 , 0 , 1, etc...", "k": ["input int array", "input int", "integer array", "int array", "return"]}
{"i": "17468662", "t": "Car  has two sides.One side A B C and other side a b c\rWAP to print all the combinations. Positions are not changed. \rEg: for the above you will get 8 combinations.\rABC\rAbC\rABc\rAbc\raBc\raBC\rabC\rabc", "k": ["abc abc abc", "abc abc", "wap to print", "abc", "sides.one side"]}
{"i": "17457663", "t": "Create a Session Manager class that iterates thru Session objects throw stale sessions out -  How would you automatically purge Session objects that have not been active for 30 seconds or (n) seconds?  The answer needs to handle millions of sessions.", "k": ["session manager class", "objects throw stale", "session objects throw", "purge session objects", "throw stale sessions"]}
