{"i": "5188169901277184", "t": "Write a function to retrieve the number of a occurrences of a substring(even the reverse of a substring) in a string without using the java substring() method.\r Ex: 'dc' in 'abcd' occurs 2 times (dc, cd).", "k": ["java substring", "write a function", "function to retrieve", "retrieve the number", "substring"]}
{"i": "5727010055782400", "t": "00011111100011\r11100010111110\r11000111111100\r00111100001111\r00110000110000\r11000100000110\rfind the maximum areas(m*n) covered by 0.", "k": ["find the maximum", "maximum areas", "find", "areas", "covered"]}
{"i": "5717956264722432", "t": "Find Common Ancestor of given two nodes A and B \rCondition :Node does not have the parent pointer and data value.\r So its is like class Node {\rNode L;\rNode R;\r}\r I mentioned below Solution. Since they didnt give me Parent I created one for each node than did back tracking from two given Nodes A & B;\r Node commonAncestor(Node A, Node B, Node root){\r HashMap<Node> map=new HashMap<Node>();\r Queue q=new Queue();\r map.(root,null);\r q.enqueue(root);\r while(!q.isEmpty()){\r Node curr=q.dequeue();\r if(curr.L !=null)\r\t\t\tmap.put(curr.L,cur);\r if(curr.R !=null)\r\t\t\tmap.put(curr.R,cur);\r\t}\r Node prev=A;\rNode next=null;\r        while(map.contains(prev)){\r\t\tnext= map.get(prev);\rmap.remove(prev);\rprev=next;\r}\r      prev=B;\r     next=null;\r    while(map.contains(prev)){\r\t\tprev=map.get(prev);\r}\r   }", "k": ["find common ancestor", "common ancestor", "node", "find common", "pointer and data"]}
{"i": "5485521224597504", "t": "Given an input list of lists.. flatten the list. For e.g. \r {{1,2}, {3}, {4,5}} ... Output should be {1, 2, 3, 4, 5}", "k": ["input list", "lists.", "list of lists.", "list", "input"]}
{"i": "5672369481842688", "t": "Find the max height of a binary tree.", "k": ["find the max", "binary tree", "max height", "find", "tree"]}
{"i": "4639756264669184", "t": "Write your own regular expression parser for following condition:\r az*b can match any string that starts with and ends with b and 0 or more Z's between. for e.g. azb, azzzb etc.\r a.b can match anything between a and b e.g. ajsdskjb etc.\r Your function will have to parameters: Input String and Regex. Return true/false if the input string satisfies the regex condition. Note: The input string can contain multiple regex. For e.g. az*bc.g", "k": ["regular expression parser", "regular expression", "expression parser", "input string", "string"]}
{"i": "5404243263488000", "t": "Given a array of numbers, for each element give the product of every other number. eg 1 2 4 3--> 24 12 6 8", "k": ["element give", "give the product", "array of numbers", "numbers", "number"]}
{"i": "5434651631943680", "t": "Find the first repeating character in a given string.", "k": ["repeating character", "find", "string", "repeating", "character"]}
{"i": "6302874975862784", "t": "Given two values in a Binary Tree - how do you find the lowest common ancestor?", "k": ["binary tree", "lowest common ancestor", "common ancestor", "tree", "find the lowest"]}
{"i": "6668639759499264", "t": "How to find if a  number is power of 4 in O(loglogn).", "k": ["loglogn", "number is power", "find", "number", "power"]}
{"i": "4519781721964544", "t": "There is a file of size 100 gb and you have given a memory of size 100GB. How you will sort the file on basis of ASCII. File is having line of text inside it. No line in the file is repeated.", "k": ["memory of size", "size", "file", "basis of ascii", "file of size"]}
{"i": "6314497157365760", "t": "Find if 2 lists of rectangle are exactly equal. How would you sort the lists?", "k": ["find", "equal", "lists", "rectangle", "lists of rectangle"]}
{"i": "5638753846558720", "t": "1.\tUsing C or Java programming language, implement merge sort. Run it on the following list of numbers:\r                  56  93 65 34 13  19  88  84  67 48  51 21  \rEach time your main recursive function is called, output the following information (print each item on one line, and print \\****\" at the very beginning of the function):\r\u2022\tThe input list that the merge sort function is being called on\r\u2022\tThe left and right lists it splits into, before recursively calling merge sort\r\u2022\tThe left and right lists, after they are recursively sorted\r\u2022\tThe result of merging the left and right lists\rSubmit  the printed output from this program, as well as the source code", "k": ["merge sort", "java programming language", "implement merge sort", "merge sort function", "calling merge sort"]}
{"i": "5871715020177408", "t": "WAP to generating all the possible combination of a given character.\rExample:- \rInput: {a,b,c}\routput: {a,b,c,ab,ac,ca,ba,,cb,bc,abc,bca,cab,cba,acb,bac}", "k": ["wap to generating", "wap", "input", "output", "character"]}
{"i": "5358150211338240", "t": "Give me an algorithm to reverse a string.", "k": ["reverse a string", "algorithm to reverse", "give", "string", "algorithm"]}
{"i": "6333028867506176", "t": "How would you test the Location Services feature on a smartphone?", "k": ["location services feature", "location services", "test the location", "services feature", "location"]}
{"i": "5090941505372160", "t": "How would you test the Add Friend feature on Facebook?", "k": ["add friend feature", "add friend", "feature on facebook", "test the add", "friend feature"]}
{"i": "4688374220718080", "t": "How do you motivate software engineers? How to you encourage quality? What are your engineering principals?", "k": ["motivate software engineers", "software engineers", "motivate software", "engineers", "encourage quality"]}
{"i": "5965096199127040", "t": "white a function/method to determine if two strings are anagrams. What is the time complexity of the algorithm (big O)? Is there a more efficient way?", "k": ["white a function", "method to determine", "strings are anagrams", "white", "function"]}
{"i": "5657651165790208", "t": "write a function to determine if two strings are anagrams? what is the run-time (big O) of this? Is there a better way to do this?", "k": ["write a function", "strings are anagrams", "function to determine", "write", "anagrams"]}
{"i": "5770860598132736", "t": "Given a sorted array where only number occurs once and others occur twice.  e.g. arr = { 0, 0, 1, 1, 2, 4, 4, 5, 5}. Find the number occurring once in o(lgn)", "k": ["sorted array", "arr", "number occurs", "sorted", "array"]}
{"i": "4823871848972288", "t": "Given a sorted array (e.g. arr = { 0, 0, 0, 0, 1, 3, 5 }) which has been rotated clockwise less than arr.length times, return the number of rotated times.", "k": ["sorted array", "return the number", "arr.length times", "rotated times", "rotated clockwise"]}
{"i": "6562685063790592", "t": "Given a binary tree, an integer k and a node, you have to find all the nodes at distance k from the given node.", "k": ["binary tree", "tree", "nodes at distance", "node", "binary"]}
{"i": "6228978989793280", "t": "write a function to generate a random number in a given range.\rCondition:\r\tEach number should be generated exactly n times, i.e., if each number has to be generated only 5 times and \r\tthe number 7 has already occured 5 times then your function should not generate 7 again.\r Actual he asked question  linking with array but it is bit confusion, he asked  to do the above only", "k": ["random number", "number", "write a function", "write", "range"]}
{"i": "5678547255427072", "t": "Q: Given a sorted 2D N x N array (where array[i][j] < array[i][j+1] and array[i][j] < array[i+1][j]), can you write a function that converts this to a sorted 1D array?\r The obvious and naive way that I thought of was to convert the entire array into a 1D and do a mergesort on it, but there must be a better way than that.  I'm wondering what the better and more efficient way is.", "k": ["write a function", "sorted", "array", "function that converts", "write"]}
{"i": "5639014228951040", "t": "determine the series of numbers entered (array a) from the encoded output of the program (array b).For i from 0 to size - 1:\r\n    For j from 0 to size - 1:\r\n         b[(i+j)/32] ^= ((a[i/32] >> (i%32)) & (a[j/32 + size/32] >> (j%32)) & 1) << ((i+j)%32)", "k": ["determine the series", "numbers entered", "series of numbers", "encoded output", "size"]}
{"i": "5240638832377856", "t": "How to use private members of Base class in Subclasses without exposing them ?", "k": ["members of base", "base class", "class in subclasses", "subclasses without exposing", "private members"]}
{"i": "5309537623998464", "t": "There are n points on a 2D plan, find the k points that are closest to origin ( x=0, y=0)", "k": ["closest to origin", "plan", "find", "origin", "points"]}
{"i": "6576175019196416", "t": "Hi,\rFollowing was a question that was asked to me in one of the interviews.\rWe know anagram of eat is: tea and ate\rThe question is:\rWe have a program. We feed a list of 10 thousand alphabets to this program.\rWe run the program. \rNow at run-time, we provide a word to this program eg. \"eat\"\rNow the program should return the number of anagrams that exist in the list of 10 thousand alphabets. Hence for an input of \"eat\", it should return 2.\r What will be the strategy to store those 10 thousand alphabets so that finding the number of anagrams becomes easy.", "k": ["thousand alphabets", "program", "thousand", "alphabets", "question"]}
{"i": "4594399799410688", "t": "Given a list of arraylists containing elements, write a function that prints out the permutations of of the elements such that, each of the permutation set contains only 1 element from each arraylist and there are no duplicates in the list of permutation sets.\r Eg: consider the following lists\rL1= {a1,b1,c1,d1}\rL2={a2,b2,c2}\rL3= {a3, b3, c3}\r Valid Permutations are:\r{a1,b2,c3}\r{a1,a2,a3}\r{b1,c2,b3}\r...\r...\r..\r Please note that \r{a1,b2,c3} is same set as {b2,a1,c3}", "k": ["write a function", "function that prints", "valid permutations", "elements", "permutations"]}
