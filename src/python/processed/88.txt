{"i": "5642495974178816", "t": "Check if any number is sum of any two numbers in array of length n\rExample: [40,90,50] -> check -> true (90 = 40 + 50)\rExample: [1,2,4] -> check -> false( A_x != A_y + A_z)", "k": ["array of length", "check", "true", "false", "number is sum"]}
{"i": "5084163580362752", "t": "Compress String with character and its count. \rExample: \"aaabbba\" -> compress -> \"a3b3a1\u201d", "k": ["string with character", "compress string", "string", "compress", "count"]}
{"i": "5754655823888384", "t": "Generate a random number with UNIFORM DISTRIBUTION between [0,n) where n is given and excluded list is given. The randomly generated number should belong to the range [0, n) but should be excluded from the given excluded list. For example, n = 10 and excluded list ={2,3,0} then the random number should be from {1,4,5,6,7,8,9} such that any number from the list {1,4,5,6,7,8,9} has UNIFORM probablility of occuring", "k": ["uniform distribution", "excluded list", "distribution", "excluded", "random number"]}
{"i": "5658085027741696", "t": "Design a mall where there are 'm' entry gates and 'n' exit gates. There can be only 'x' number of people inside it. No more then 'x' people can be inside mall at any time.", "k": ["entry gates", "exit gates", "gates", "design", "entry"]}
{"i": "4911642864254976", "t": "We have to merge a set of Intervals.How to decide if to sort them on start or end time? Which one is better to sort based on start or end time?", "k": ["end time", "start or end", "merge a set", "set of intervals.how", "intervals.how to decide"]}
{"i": "5643686955188224", "t": "Given a 2D matrix of 0's and 1's, where the 1's make up a rectangle, find the coordinates of the top-left corner of the rectangle and the rectangle's width and height.", "k": ["find the coordinates", "width and height", "top-left corner", "rectangle width", "rectangle"]}
{"i": "5106209647493120", "t": "Array has N integers\uff0crange[0...N-1]\u3002Set S[k], 0 <= K < N as S[K] = {A[K], A[A[K]], A[A[A[K]]],....},\rwrite a function returns the size of the largest set S[K] for this array. return 0 if empty.\rex:\rA = [5, 4, 0, 3, 1, 6, 2]\rreturn 4 because S[2] equals {0, 5, 6, 2} 4 elements", "k": ["largest set", "write a function", "set", "function returns", "array"]}
{"i": "5728926218321920", "t": "Phone Interview Amazon, Seattle\r I. Get the sum of all prime numbers up to N. primeSum(N).\r Follow-up: If primeSum(N) is frequently called, how to optimize it.\r  II. OODesign Parking Lot", "k": ["phone interview amazon", "interview amazon", "phone interview", "prime numbers", "amazon"]}
{"i": "5164989764599808", "t": "I was asked this question for the above role:\rCreate a fixed size cache which is fully associative. The entries are evicted based on the rank. for any entry added, the function int getEntryRank(entry) will return its rank which will not change on lookup\rdb_read_entry() to get the entry from db \r  Part 2)  The rank will change on lookupMy solution was:\r\na hashtable (unordered_set<entry>)\r\n\r\nand a priority queue <pair<int, entry> >\r\n\r\nlookup(entry) {\r\n   hashtable lookup. \r\n  if found, return the entry (O(1))\r\n\r\n  // otherwise (not found)\r\n    if limit reached, then\r\n      // evict the priority queue top,\r\n  \r\n    entry e = db_read_entry(); // expensive op\r\n    //insert the entry into the hash set, \r\n    //insert pair<int, entry>(get_entry_rank(entry), entry)\r\n          into the priority queue.  (O(logn))\r\n    return entry;\r\n} \r\n\r\nPart 2: The rank change on lookup\r\n   Since the priority queue does not provide the key(hash key)\r\n   value to be modified, and only provide access to top entry. \r\n  I propose change in the associated ds for hashset, \r\n\r\n   My proposal was: create an associated binary tree(std::set) with the hashmap (map of entry as key, and the iterator entry in the std::set of entries) . I used iterator to avoid look up for entry into the set during each entry lookup in the hashset. \r\nThe set contains the [rank information + entry]. On look up, the entry into the set(of rank) is looked up (O(1)) and then erased, and then insert back after recaulated rank value.The iterator inrto the hash_set is also updated with this new iterator. \r\n\r\nOn limit reached,  the tree is searched for min value. from that min value item (the rank and the entry), the entry is looked up into the hash_set, and hence removed from there too. \r\nThe rest of the process is the same as lookup as described below. \r\n\r\nI believed my slution was faor enough \r\nO(1) look up, \r\nif not found. the look up (with const rank) O(logn) + db access time. db access time dominate the O(logn) hence this logn (to insert into the priority queue,(or pop and insert into the priority) does not matter\r\n\r\nFor changing rank:\r\nThe binary tree lookup (O(1) since the hash_map has the iterator\r\nupdate of the rank, (lookup and removal of the rank entry in the binary tree O(1), and insert is O(logn). \r\nHence each operator (lookup, evict and lookup, excluding the db access) will take O(logn) instead of O(1).\r\n\r\nI was rejected because of not optimize solution (performance is not good). I am wondering whether the solution was not good even though it was phone interview and I have to work within the time frame of 25 minutes. or the interview process is just unrealistic. \r\n\r\nPlease share your solution so that I can see where I failed", "k": ["entry", "rank", "fixed size cache", "priority queue", "lookup"]}
{"i": "5676363938791424", "t": "How will you design a true collar?", "k": ["true collar", "design a true", "collar", "design", "true"]}
{"i": "5631766810329088", "t": "Given an array of co ordinates (x,y). WAP to figure out if a square can be formed from any four points.", "k": ["ordinates", "wap to figure", "wap", "array", "points"]}
{"i": "5679315655065600", "t": "Given a 2d matrix and 4 points. WAP to figure out if they are row wise, column wise of diagonally wise consecutive.", "k": ["points", "wap to figure", "matrix", "diagonally wise consecutive", "wise"]}
{"i": "5707236163715072", "t": "Given an array of integers and a target number, determine if an arithmetic expression using these integers can be evaluated to the target number, you are allowed to use '+', '-', '*', '/'. Follow-up: when evaluating the expression, take operand precedence into account,\rpublic boolean  getTarget(int[] nums, int target){\r}\r  exponentia is ok", "k": ["target number", "number", "arithmetic expression", "public boolean gettarget", "array of integers"]}
{"i": "5675602320293888", "t": "Given a list of input tasks to run, and the cooldown interval, output the minimum number of time slots required to run them. \r// Tasks: 1, 1, 2, 1, 2\r// Recovery interval (cooldown): 2\r// Output: 8  (order is 1 _ _ 1 2 _ 1 2 )\r =========\rTasks are task numbers in that order coming in for execution. Cooling time is time interval required to cool down the machine after executing a task. So it's like if CPU executed task 1 then it needs 2 cooling time intervals before executing another task 1 but meanwhile, it can execute other tasks which are not same as 1 and so on. So before executing any task, you have to check if you have executed same task number before and if yes, then if its cooling time interval is done or not. \rThe output is basically the number of cycles/time slots CPU took to execute these tasks in that order (including when task executed and cooling intervals).", "k": ["task", "time", "list of input", "cooling time", "required to run"]}
{"i": "5697108630831104", "t": "Implement Ring Buffer with read and write pointers. \rFor example if the Ring buffer is implemented in the form of array of integers , one should be able to read / write more than one integer at a time. In short the data read / written should be in a chunk .", "k": ["implement ring buffer", "ring buffer", "implement ring", "write pointers", "ring"]}
{"i": "5697155539927040", "t": "find the Closest leaf to a given node in Binary Tree\rcan you do it in o(n) time\rpublic TreeNode findCloestLeafNode(TreeNode root, TreeNode target){}\r no parent pointer", "k": ["time public treenode", "public treenode findcloestleafnode", "binary tree", "find the closest", "closest leaf"]}
{"i": "5729762931638272", "t": "validate IP in string format and return the uint32 format\r \u20181.2.3.4\u2019  -> 0x01020304", "k": ["string format", "format and return", "validate", "format", "string"]}
{"i": "5749530317291520", "t": "aa", "k": []}
{"i": "5696348153184256", "t": "Ranjith is a newsoholic and reads news daily . Being a techie he is lazy and \rloves to automate things. \r Problem : \rHe collects a set of text documents containing news articles from all \raround everyday. \rHe wants the news to be Categorize / clustered so that he can skip \rcategories he is not interested in and read his favorites. \r Please help him do so by writing a program in language of your choice. \r Predict category name in such a way that it should also work with any set \rof news articles. \r Input : \rCollect a set of news articles as .txt files from domains such as Sports, \rPolitics, Business, Technology etc.. (One text file contains only one news). \r Output : \rEg:- \r File1.txt : CategoryName \rFile2.txt : CategoryName \rFile3.txt : CategoryName", "k": ["automate things", "lazy and loves", "loves to automate", "newsoholic and reads", "categoryname"]}
{"i": "5745104621928448", "t": "Apple Map Team\r 1. Given an array A and some queries, query(i, j) returns the result of Ai*...*Aj, in other words the multiplication from Ai to Aj.\rThe numbers in A are non-negative. \rImplement query(i, j).\r 2. Flatten nested linked list\r 3. POI search design\r 4. LC238 & LC279", "k": ["apple map team", "map team", "apple map", "team", "map"]}
{"i": "5700048737271808", "t": "Airbnb Interview \r  Min cost of flight from start to end if allowed at most k transfers.\r Given all the flights in a string:\r A->B,100,\r B->C,100,\r A->C,500,\r If k = 1\uff0cfrom A to C the best route is A->B->C at the cost of 200.", "k": ["airbnb interview min", "interview min cost", "interview min", "airbnb interview", "min cost"]}
{"i": "4889325677314048", "t": "// Imagine you have an array of N messages which is consistently having new messages added to it. \r// When you loop through the array, the messages are guaranteed to be ordered chronologically by timestamp.\r// Write some code that loops through the array of messages and when a unique user_id has two messages within one second of each other, call a method too_fast that takes in two parameters, the first is the older message, the second is the newer message.\r// In the message examples below we would expect to call the too_fast method with the first and third message, and then again with the third and fifth message.\r // message example 1 = { \"container_id\": 123, \"item_id\": 456, \"success\": true, \"timestamp\": 1499351653, \"user_id\": 789 }\r// message example 2 = { \"container_id\": 111, \"item_id\": 222, \"success\": false, \"timestamp\": 1499351654, \"user_id\": 333 }\r// message example 3 = { \"container_id\": 444, \"item_id\": 555, \"success\": true, \"timestamp\": 1499351654, \"user_id\": 789 }\r// message example 4 = { \"container_id\": 123, \"item_id\": 456, \"success\": true, \"timestamp\": 1499351655, \"user_id\": 999 }\r// message example 5 = { \"container_id\": 123, \"item_id\": 456, \"success\": true, \"timestamp\": 1499351655, \"user_id\": 789 }\r // Within the loop you can access attributes by using message.getContainerId() or message.getItemId for example, message.getTimestamp()", "k": ["message", "timestamp", "user", "imagine", "container"]}
{"i": "5729398060744704", "t": "Perform left and right shift on string", "k": ["perform left", "shift on string", "perform", "string", "left"]}
{"i": "5764491030560768", "t": "Find max sum of sub array.", "k": ["find max sum", "find max", "max sum", "find", "array"]}
{"i": "5662946326740992", "t": "Implement stack using a queue.", "k": ["implement stack", "implement", "queue", "stack"]}
{"i": "5098250871767040", "t": "Merge the overlapping intervals.", "k": ["merge the overlapping", "overlapping intervals", "merge", "intervals", "overlapping"]}
{"i": "5645125836341248", "t": "Reverse the words in string eg. 'The Sky is Blue'. then print 'Blue is Sky The'.", "k": ["reverse the words", "words in string", "sky", "blue", "reverse"]}
{"i": "5069872412229632", "t": "Find max sum of subarray", "k": ["find max sum", "find max", "sum of subarray", "max sum", "find"]}
{"i": "5680648437104640", "t": "You are given an old touch smartphone numbers having dial pad and calculator app. \r  Aim: The goal is to type a number on dialpad. \r But as phone is old, some of the numbers and some operations can't be touched. \rFor eg. 2,3,5,9 keys are not responding , i.e you cannot use them \rBut you can always make a number using other numbers and operations in Calculator. There could be multiple ways of making a number\r .Calculator have 1-9 and +,-,*,/,= as operations. Once you have made the number in Calculator you can copy the number and use it.\r You have to find minimum number to touches required to obtain a number.\r  #Input:#\rThere will be multiple Test cases .Each test case will consist of 4 lines \r1) First line will consist of N,M,O\rN: no of keys working in Dialpad (out of 0,1,2,3,4,5,6,7,8,9) \rM:types of operations supported (+,-,*,/)\rO: Max no of touches allowed\r 2) second line of input contains the digits that are working e.g 0,2,3,4,6. \r3) Third line contains the valued describing operations, 1(+),2(-),3(*),4(/)\r 4) fourth line contains the number that we want to make .\r #Output:#\rOutput contains 1 line printing the number of touches required to make the number\r  #Sample Test Case:#\r1 // No of test cases \r5 3 5 // N ,M, O\r1 2 4 6 0 // digits that are working (total number of digits = N),\r1 2 3 // describing operations allowed (1--> '+', 2--> '-', 3--> '*' , 4--> '/' )(total number is equals to M)\r5 // number we want to make\r  Answer 3 \rHow 4? 1+4= , \"=\" is also counted as a touch\r   2nd Sample Case\r3 // No of Test cases\r6 4 5 // N ,M, O\r1 2 4 6 9 8 // digits that are working (total number of digits = N),\r1 2 3 4 // describing operations allowed (1--> +, 2--> -, 3--> , 4-->/)\r91 // number we want to make\r6 2 4 // 2nd test case\r0 1 3 5 7 9\r1 2 4 // +, -, / allowed here\r28\r5 2 10\r1 2 6 7 8\r2 3 // -, allowed\r981\r #Output:#\r2 // 91 can be made by directly entering 91 as 1,9 digits are working, so only 2 operations\r5// 35-7=, other ways are 1+3*7=\r9//62*16-11=\r  Order for computation will be followed as symbols entered, if + comes, it will be computed first\r  One more example: lets say 1,4,6,7,8,9 works and +,-,* works.\r2,3,5 and / doesn't work.\rIf you have to type 18-> 2 operations. (Each touch is considered an operation),br> If you have to type 5 -> '1+4=' that requires 4 operations. There could be other ways to make '5'.", "k": ["number", "operations", "test", "test cases", "test case"]}
{"i": "5689887448629248", "t": "Given a n-nery tree and its deep copy, a node in the original tree,  return the corresponding node in the copy\rpublic TreeNode getCopyNode(TreeNode root, TreeNode copy, TreeNode node)", "k": ["public treenode getcopynode", "copy public treenode", "n-nery tree", "original tree", "treenode getcopynode"]}
