{"i": "5708698695499776", "t": "how to get the dynamic breadcrumb?\rWhen there is a longer breadcrumb, it should show three dots in the middle of root folder and the current folder.\r Ex:\rAlldata > Folder1 > folder2 > folder3\r It should display like\r Alldata > . . . > folder3\r Please give me code for this...", "k": ["dynamic breadcrumb", "alldata", "breadcrumb", "longer breadcrumb", "dynamic"]}
{"i": "5077069362888704", "t": "We have a file path as like this:\rwchar_t* pCompletePath = L\"\\\\?\\UNC\\10.1.3.23\\TOKEN$\\0x464564564576\\C\\FileDrive\\Testcase.doc\";\r Write a C++ function which will take input argument as above string and gives output as L\u201d\\\\?\\UNC\\10.1.3.23\\TOKEN$\\C\\FileDrive\\Testcase.doc\u201d  (Removing one token after the TOKEN$)\rConstraints: TOKEN$ will be there for all strings, so we can use that for search", "k": ["file path", "input argument", "unc", "testcase.doc", "token"]}
{"i": "5753561877053440", "t": "Write a C program to calculate multiplication between two numbers with repetitive additions", "k": ["repetitive additions", "program to calculate", "calculate multiplication", "numbers with repetitive", "write"]}
{"i": "5737601677918208", "t": "Write a C program to find given number is even or odd without using any control structures like conditional statements or loops.", "k": ["statements or loops", "program to find", "find given number", "control structures", "structures like conditional"]}
{"i": "5144651210162176", "t": "This was a javascript interview.\rThere are two arrays:\r var arr1 = [2,\"undefined\",7,\"undefined\", 10,\"undefined\",\"undefiend\"];\r    var arr2 = [5,8,12,14];\r They need to be merged such that arr1=[2,5,7,8,10,12,14]\r This needs to be done in place and in constant time.", "k": ["javascript interview", "undefined", "var", "interview", "javascript"]}
{"i": "5685801251766272", "t": "Find the highest time difference in the below log file Using single Unix command\r STARTTIME:2015-12-01 04:13:15\rENDTIME    :2015-12-01 04:14:16\r----------------------------------------------\r----------------------------------------------\rSTARTTIME:2015-12-01 04:11:15\rENDTIME    :2015-12-01 04:11:17\r----------------------------------------------\r----------------------------------------------\rSTARTTIME:2015-12-01 04:12:15\rENDTIME    :2015-12-01 04:15:15\r----------------------------------------------\r----------------------------------------------\rSTARTTIME:2015-12-01 04:10:10\rENDTIME    :2015-12-01 04:10:11\r----------------------------------------------\r----------------------------------------------", "k": ["unix command starttime", "single unix command", "highest time difference", "command starttime", "single unix"]}
{"i": "5659093534507008", "t": "Given a tree. \rEach node is of type:public class Node {\r\n       public IEnumerable<Node> Children { get; set; }\r\n}Write a function GetAllNodes which returns collection, containing all nodes from given tree. (Given only the root node), i.e.:IEnumerable<Node> allNodes = GetAllNodes( rootNode );(The task is given in C#, but this is not a restriction, you may use any language you want).", "k": ["node", "public class node", "write a function", "tree", "public ienumerable"]}
{"i": "5180871910883328", "t": "I was asked this question in an algorithm interview. Since my coding language was javascript I was asked to implement a hashmap n white board with collision detection.\rI guess they were looking for a hashing algorithm that will create a linked list in case of a collision and also an equals method", "k": ["algorithm interview", "asked this question", "interview", "asked", "question"]}
{"i": "5097145818415104", "t": "How do you create your own garbage collector? How do you find whether objects in memory are orphans in order to purge them?", "k": ["garbage collector", "collector", "create", "garbage", "find whether objects"]}
{"i": "5171736381227008", "t": "What is good or bad about \r<a href=\"javascript:void(0)\" onclick=\"doSomething()\"> Click me </a>\rDoes anybody have any idea on this?", "k": ["good or bad", "javascript", "void", "onclick", "dosomething"]}
{"i": "5640253559799808", "t": "You know result of a soccer match, print all the possible ways that this game ends up with this result.\r Example: final score 1 - 1:\r 0 - 0 \r0 - 1\r1 - 1\r 0 - 0\r1 - 0\r1 - 1\r Another example if the final score is 2 - 3 there are many possibilities for reaching to that score:\r 2 - 3\r 0 - 0\r1 - 0\r2 - 0\r2 - 1\r2 - 2\r2 - 3\r 0 - 0\r1 - 0\r1 - 1\r1 - 2\r2 - 2\r2 - 3\r 0 - 0\r0 - 1\r0 - 2\r0 - 3\r...", "k": ["soccer match", "game ends", "final score", "result", "score"]}
{"i": "5111734211706880", "t": "Using Javascript write code to detect and remove a loop from a cylic linked list", "k": ["javascript write code", "cylic linked list", "javascript write", "linked list", "write code"]}
{"i": "5715022497972224", "t": "A frog has to cross the river from one end to another end. river has stones in between randomly where frog can jump. frog can't jump into the river. problem is that will frog ever reach other end with following conditions?\r1. frog allow to do same jump as previous jump. or\r2. frog allow to jump 1 more as previous jump. or\r3. frog allow to jump 1 less as previous jump.\r consider river as Boolean Array. Stone is a element in array where value is true .", "k": ["frog", "jump", "river", "previous", "end"]}
{"i": "5650251169923072", "t": "A file is given which consists of  3 columns : date, city and temperature. For ex:\rDate                      City               Temperature\r09-11-2015\t     Delhi              45\r09-11-2015           Bangalore      24 \r09-11-2015           Ranchi            28\r and it should support following type of queries:\r1) What is the temperature of Bangalore on 9th November?\r2) Give 5 hottest/coldest cities name on 9th November\r You can preprocess the data and keep it in way that above query can be done in minimal time. \rWhich data structure will you use and how will you store the data?", "k": ["date city temperature", "date city", "city temperature", "date", "temperature"]}
{"i": "5133502985011200", "t": "There are two admins, trying to update product page at the same time. It happens like admin1 has updated just 2ms ago but admin2 is unaware of this and on his page he is having the previous data. Now how can we prevent admin 2 to update on description which is one step older?", "k": ["update product page", "product page", "update product", "time", "page"]}
{"i": "5638474235379712", "t": "You are given a rectangular grid with 2 rows and N columns. The top row is labeled 1 and the bottom row is labeled 2. The columns are labeled from 1 to N in increasing order. Each cell in the grid contains a single character.\rConsider a hamiltonian walk in this grid. Meaning, pick a starting cell, say (i,j), and consider a path that starts from (i,j) and goes through every cell in the grid exactly once. Note that you can only walk to adjacent cells, or cells that you share a common edge with. There may be several such paths. Let us concatenate the characters in the order in which the cells are visited during a walk. The string formed can be called the string for the walk.\rAmong all the possible walks, and their respective strings, find out the lexicographically smallest string. We know that the length of the strings are all the same - to be precise, 2N. Thus, the lexicographically smallest string is simply the alphabetically smallest string if you compare the characters from left to right.\rInput\rThe first line of input contains a number T, the number of test cases. Then follow T test cases. Each test case contains 3 lines. The first line contains the number N, the number of columns in the grid. It is well known of course that the grid contains 2 rows. The next two lines contain the description of the grid in the form of two strings; the string of N characters in row 1 from left to right and the string of N characters in row 2 from left to right, respectively. Each character will be a lowercase english letter.\rOutput\rOutput a single line for each test case. The line must contain a string with 2N characters. This string should be the lexicographically smallest string for some hamiltonian walk in the grid.\rConstraints\r1 \u2264 T \u2264 100\r1 \u2264 N \u2264 10\r   Sample Input\r2\r3\rabc\rdef\r10\rababaaabab\rbababababa\r   Sample Output\rabcfed\raaababababababababab\r   Explanation\rIn the first test the possible strings are { abcfed, adebcf, adefcb, badefc, bcfeda, cbadef, cfedab, cfebad, dabcfe, dabefc, defcba, edabcf, efcbad, fedabc, fcbade, fcbeda }. The smallest string is abcfed.", "k": ["string", "smallest string", "grid", "lexicographically smallest string", "walk"]}
{"i": "5768685966852096", "t": "You are given a grid with R rows and C columns. You are also given a robot which is very small and can be placed on the grid - to walk around in the grid. You will place the robot at some starting cell of your choosing. You will give the robot an initial direction. Then, when you start the robot, it will walk in the given direction till it gets out of the grid or encounters a \"turn\" cell in the grid.\rEach cell in the grid is either empty (depicted by '.') or a turn cell (depicted by 'r' or 'l'). When the robot encounters a turn cell with 'r', it will turn right on that cell. Note that this turn will be relative to the direction in which the robot is moving. Similarly, when the robot encounters a turn cell with 'l', it will turn left on that cell. The examples and explanations clarify this.\rThe robot will eventually leave the grid or enter a loop. You wish to choose a start point and direction for the robot such that it visits the maximum number of unique cells. Note that the start point you select must be an empty cell.\rPrint the maximum number of unique cells the robot will visit when you choose such a starting point.\rInput\rThe first line of input contains a number T, the number of test cases. Then follows the description of T test cases. The first line of each test case contains two integers R and C. On the next R lines are exactly C characters each. Each character is either '.', 'r' or 'l'.\rOutput\rFor each test case, output a single number on a line by itself. This number should be the maximum number of unique cells the robot can visit if you place it optimally.\rConstraints\r1 \u2264 T \u2264 20\r1 \u2264 R \u2264 20\r1 \u2264 C \u2264 20\r   Attention\rThe constraints are designed such that O(R*R*C*C) solutions will pass.\rSample Input\r3\r3 5\r.....\r...r.\r...r.\r2 2\r..\r..\r1 5\r.r...\r   Sample Output\r8\r2\r4\r   Explanation\rWe will assume that the rows are labeled from 1 to R from top to bottom and columns are labeled from 1 to C from left to right.\rIn the first test case the optimal choice is to keep the robot at 2,1 facing east. The robot will move as 2,1 - 2,2 - 2,3 - 2,4 and then turn right, facing south. The robot will then move as 2,4 - 3,4 and then turn right, facing west. The robot will then move as 3,4 - 3,3 - 3,2 - 3,1 and then leave the grid. The robot touched 8 unique cells.\rIn the second test case you cannot optimise robot placement. No matter what you do, you can only touch 2 different cells.\rIn the third test case the optimal choice is to place the robot on 1,5 facing west.", "k": ["robot", "cell", "turn", "grid", "turn cell"]}
{"i": "5760452782981120", "t": "Given a singly connected linked list, find the largest palindrome in the list in O(1) space.", "k": ["singly connected linked", "connected linked list", "find the largest", "singly connected", "connected linked"]}
{"i": "5759529096577024", "t": "Given a linked list consisting of String in each Node . Given just a pointer to the head Node find whether the resultant String formed by combining all the Nodes of the linked list is a palindrome or not in O(1) space and O(n) time.\r eg \u2013 Consider this linked List structure\r \u201caba\u201d -> \u201ccd\u201d -> \u201cefe\u201d -> \u201cd\u201d -> \u201ccaba\u201d\r Hence this structure is palindrome .", "k": ["resultant string formed", "head node find", "linked list consisting", "resultant string", "string formed"]}
{"i": "5669787097104384", "t": "2 process runs the following code. What will be the output// Assume this address is legal address for  both the process\r\n int *sharedmemoryaddress  = 0x1232;\r\n\r\nvoid SomeRunningFunction()\r\n{\r\n\tfor(int i = 1; i < 1000; ++i)\r\n\t{\r\n\t\t*sharedmemoryaddress  = i;\r\n\t\tsleep(2000);\r\n\t}\r\n}What does the 2 process print. Consider unicore and multicore processors. What is the significance of sleep here. What are we achieving from sleep.", "k": ["process runs", "sharedmemoryaddress", "process", "code", "process print"]}
{"i": "5741044362641408", "t": "WAP in java to find duplicate element in array in one scan.", "k": ["find duplicate element", "wap in java", "java to find", "find duplicate", "duplicate element"]}
{"i": "6211118064205824", "t": "Design Uber or Lyft like architecture keeping scale, latency and availability in mind. The design can be at macro level first, that is, major components like persistent store (SQL/NoSQL/redundant), cache, communication/messaging. The design and if time permits, details will then be discussed/challenged.", "k": ["architecture keeping scale", "uber or lyft", "lyft like architecture", "keeping scale", "latency and availability"]}
{"i": "5669919301566464", "t": "Face to Face \rQ4) two arrays given to you. First array contains number s. Second array contains key values.\r We need to find smallest window in first array which covers all second array elements.\re.g: \r Input= {6,7,1,3,2,4,5,2,3,1,2,5}\rKeys = {2,5,1}\r answer: from 9th index to 11th index is the smallest window.", "k": ["face", "face to face", "array", "smallest window", "index"]}
{"i": "5673066304634880", "t": "Face to face\r Q3) stream of numbers coming, get 'n' min elements at any point of time", "k": ["stream of numbers", "numbers coming", "min elements", "point of time", "stream"]}
{"i": "5660149190492160", "t": "Written test:\rQ2) in single linked list reverse alternative k nodes.\r e.g.  k=3 , 1->2->3->4->5->6->7->8->9->10\r3->2->1->4->5->6->9->8->7->10\r void reverseAlternativeKNodes(node *&head, int k);", "k": ["single linked list", "linked list reverse", "list reverse alternative", "written test", "single linked"]}
{"i": "5700622814806016", "t": "Written Test question:\r Q1) Given binary tree find largestPath size from one leaf to another leaf.\r int getLargestPathSize(node *root);", "k": ["written test question", "binary tree find", "tree find largestpath", "find largestpath size", "written test"]}
{"i": "5731212242976768", "t": "For typical word ladder problem to get the shortest path, BFS has complexity exponential to the word string length. How to optimize?", "k": ["word string length", "typical word ladder", "word ladder problem", "bfs has complexity", "shortest path"]}
{"i": "5638929904566272", "t": "Given an N-ary tree with thousands of nodes in it. Pair (Join) the Leaf nodes which do NOT SHARE the common path. i.e. Two Leaves can be Paired only if they do NOT have Intersecting path.\r For example,\r        A\r    /  |  \\\r   B   C   D\r /   / | \\\rE   F  G  H \rLeaf nodes: E, F, G, H & D\r Possible Pairs in O/Ps:\r                    a) (E-F), (G-H) or\r                    b) (E-G), (F-H) or\r                    c) (E-H), (F-G) or\r                    d) (E-D), (F-G) or\r                    e) (E-D), (G-H) or\r                    f) (E-D), (F-H) or\r                    g) (D-H), (F-G) or\r                    h) (D-G), (F-H) or\r                    i) (D-F), (G-H)\r Note: If we pair(join) say, (E-F) then we can NOT pair any of the (D-G) or (D-H) as they SHARE the COMMON path from A to C.\ri.e. E-B-A-C-F \u2014> (E-F) pair\r       D-A-C-G \u2014> (D-G) pair\r       D-A-C-H \u2014> (D-H) pair", "k": ["n-ary tree", "share the common", "leaf nodes", "tree with thousands", "common path"]}
{"i": "6326674964611072", "t": "Given a long string s and short strings t1, t2, t3 (which can have different length) find the shortest substring of s which contains t1, t2 and t3.", "k": ["find the shortest", "shortest substring", "long string", "short strings", "length"]}
{"i": "5769792860454912", "t": "Given a tree, and a pointer to some node in the tree, print the left most element in the same level as that node", "k": ["print the left", "left most element", "tree", "print", "node"]}
