{"i": "4727064687017984", "t": "A 2D matrix with +/- numbers , write a program to return Max sum of submatrix.", "k": ["return max sum", "return max", "max sum", "write a program", "sum of submatrix"]}
{"i": "5458196164509696", "t": "Write a program to return minimum number of swaps required to convert this binary tree into a BST.", "k": ["return minimum number", "write a program", "program to return", "return minimum", "minimum number"]}
{"i": "5940406101475328", "t": "R4 | Q2. Given a BST, find out the minimum length form root to leaf with sum S. Note that:\ra) Path from root to leaf node.\rb) Sum of node of the path is S.\rc) if multiple such path exist, print minimum length path.\rd) What is advantage of BST rather than BT used for this algorithm, how it improve the performance. in BST, is it required to explore both side ? \re) Write working codes for it.", "k": ["bst", "path", "root to leaf", "minimum length", "sum"]}
{"i": "6260119440457728", "t": "Round 4( 2h 30 min)\r===================\rQ1. You are given a Text, where all space, full stop and all punctuation mark is removed. You want to reconstruct the text by putting spaces between words.\rA dict is given and following API < bool isInDect(word) > is also given.\ra) Decide if the text can be converted a sentence with valid words or NOT.\rb) Find how many way you can do the reconstruction of the text\rc) Find what is the minimum number of space can be used for this reconstruction.\rd) For case (c)  find out the indexes where you suppose to put a space.\re) Now recover the text to sentence in place .\r Subsequent Question:\r1. Why Greedy technique will not work for this\r2. yes ! Backtracking will work, what is the problem of using backtracking\r3. Illustrate and explain how the solution is contracted from the Dynamic table.\r4. Write the correct working code for (c),(d),(e).", "k": ["text", "find", "round", "min", "space"]}
{"i": "5275764912029696", "t": "R3 | Q4. You have a file with million words in it. Find most frequent 10 word in that file. Node that you can store all word in memory.\r(Note : Min-Heap + List )", "k": ["word", "note", "list", "file", "find most frequent"]}
{"i": "6021146117931008", "t": "R3 | Q3. What the different issue in multi-threading ? What is the difference between mutex and semaphore.", "k": ["issue in multi-threading", "mutex and semaphore", "difference between mutex", "multi-threading", "semaphore"]}
{"i": "6093290461986816", "t": "R3 | Q2. Reverse a 32-bit integers. write code for it.", "k": ["integers", "reverse", "write", "code", "write code"]}
{"i": "6688314157432832", "t": "Round 3:(1.h 15min)\r===================\rQ1. In a plane n points (X and Y) is given. How will you find out maximum co-liner points. Extend this algorithms. it for point(x,y,z) in 3D plane.", "k": ["round", "points", "plane", "co-liner points", "point"]}
{"i": "6374765438697472", "t": "R2 | Q3. Design a Chip-Encryption system. Which will do following operation:\r1. Take a word from user\r2. Encrypt the word by some Private or public key cryptography or any other algo.\r3. Transmit the encrypted word by TCP or UDp or SSL.\r Design the class diagram using OOD. Which design pattern you are using to achieve this.", "k": ["word", "design", "chip-encryption system", "transmit the encrypted", "udp or ssl"]}
{"i": "5924102405619712", "t": "R2 | Q2. You have a dictionary of words. Given a word, print all anagram are in dictionary .  State the data structure to be used to solve this problem.", "k": ["state the data", "state", "dictionary", "words", "word"]}
{"i": "5838714865451008", "t": "Round 2:(1.h 15min)\r===================\rQ1. Given a sorted array having duplicate elements,how would you find first index of a given element in O(nlogn). \rWrite  code for it. Change the condition to find out last index of that elements.\r[ Hint Binary search]", "k": ["round", "hint binary", "hint binary search", "nlogn", "index"]}
{"i": "6152955443019776", "t": "R1 | Q2. Find an element in a sorted rotated array in O(nlogn ) complexity.", "k": ["nlogn", "complexity", "find an element", "sorted rotated array", "sorted rotated"]}
{"i": "4798202498777088", "t": "Round 1: (1 h)\r==============\rQ1. Design a Garbage collector like java. How would you detect depended reference loop ? \rHist : Class design, Cycle detection algorithms for disjoint graph( List of connected graph)", "k": ["round", "hist", "garbage collector", "class design", "cycle detection"]}
{"i": "5644874502111232", "t": "You have a rectangular chocolate bar that consists of width x height square tiles. You can split it into two rectangular pieces by creating a single vertical or horizontal break along tile edges. For example, a 2x2 chocolate bar can be divided into two 2x1 pieces, but it cannot be divided into two pieces, where one of them is 1x1. You can repeat the split operation as many times as you want, each time splitting a single rectangular piece into two rectangular pieces.\r Your goal is to create at least one piece which consists of exactly nTiles tiles. Return the minimal number of split operations necessary to reach this goal. If it is impossible, return -1.\r Complete the function getMinSplit, which takes in 3 integers as parameters. The first parameter is width of the chocolate, the second is height of the chocolate and third is nTiles, the number of tiles required. \r Constraints\r-    width will be between 1 and 109, inclusive.\r-    hight will be between 1 and 109, inclusive.\r-    nTiles will be between 1 and 109, inclusive.\r Example 0\r 5\r4\r12\r Returns: 1\rYou can split the chocolate bar into two rectangular pieces 3 x 4 and 2 x 4 by creating a single vertical break. Only one break is necessary.\rExample 1\r 12\r10\r120\r Returns: 0\rThe chocolate bar consists of exactly 120 tiles.\rExample 2\r 2\r2\r1\r Returns: 2\r Example 3\r 17\r19\r111\rReturns: -1\r Example 4\r226800000\r10000000\r938071715\r Returns: 2", "k": ["returns", "rectangular", "chocolate", "rectangular pieces", "chocolate bar"]}
{"i": "5101612141903872", "t": "Human gene consisting of four nucleotides, which are simply denoted by four letters, A, C, G, and T. \rYour job is to make a program that compares two genes and determines their similarity as explained below. \rGiven two genes AGTGATG and GTTAG, how similar are they? One of the methods to measure the similarity of two genes is called alignment. In an alignment, spaces are inserted, if necessary, in appropriate positions of the genes to make them equally long and score the resulting genes according to a scoring matrix. \rFor example, one space is inserted into AGTGATG to result in AGTGAT-G, and three spaces are inserted into GTTAG to result in -GT--TAG. A space is denoted by a minus sign (-). The two genes are now of equal length. These two strings are aligned: \r AGTGAT-G \r-GT--TAG \r In this alignment, there are four matches, namely, G in the second position, T in the third, T in the sixth, and G in the eighth. Each pair of aligned characters is assigned a score according to the following scoring matrix. \r  * denotes that a space-space match is not allowed.\rThe score of the alignment above is (-3)+5+5+(-2)+(-3)+5+(-3)+5=9. \rOf course, many other alignments are possible. One is shown below (a different number of spaces are inserted into different positions): \r AGTGATG \r-GTTA-G \r This alignment gives a score of (-3)+5+5+(-2)+5+(-1) +5=14. So, this one is better than the previous one. As a matter of fact, this one is optimal since no other alignment can have a higher score. So, it is said that the similarity of the two genes is 14. \rYou are expected to complete the function getDNAAlignment, which takes in two strings as argument.\r Constraints\rLength of both strings will not exceed 1000.\rBoth string will be non-empty strings.\rstrings will only consists of character from set {'A', 'C', 'G', 'T'}\r Sample Input 00\rAGTGATG\rGTTAG\rReturns: 14\r Sample Input 01\rAGCTATT\rAGCTTTAAA\rReturns: 21", "k": ["human gene consisting", "genes", "agtgatg gttag returns", "agtgatg", "human gene"]}
{"i": "5678799274377216", "t": "You are a coin collector in a country, where the silver coin denominations runs from 1 to 1000000. You have N coins with you with various denominations. \r Apart from the silver coins, the country also issues gold coins which can be used as any value. With the given silver and gold coins, find out the maximum continous denomination streak you can achieve. \r For example, if you have 4 silver coins of value 2, 3, 5 and 9 and 1 gold coin. You can have a maximum streak of 4 coins by using the gold coin as value 4. \r Input format. \rThe first line contains 2 integers, S and G. S is the number of silver coins you have and G is the number of gold coins you have. S lines follow, each line is the value of the corresponding silver coin\r Output format: \rOne integer, representing the maximum streak you can have using the coint. \r Sample Input 1\r 4 1\r2\r3\r5\r7\r Sample Output 1\r4", "k": ["coins", "silver", "silver coins", "coin", "gold"]}
{"i": "5138832865361920", "t": "Draw a graph as a graph. Assume there is graphics library to draw lines and all. Just tell how will you order the vertices such that the edges don't intersect and they seem ordered.", "k": ["graph", "draw", "draw a graph", "draw lines", "assume"]}
{"i": "5701782818783232", "t": "Need to implement something like pastebin wherein you paste some text, you are given an url. The url can be used anywhere to access the text.\rVarious problems, features and design of this architecture were discussed.", "k": ["text", "paste some text", "url", "implement", "pastebin"]}
{"i": "5709153519534080", "t": "There are N lanes, and the speed of each lane is given. There are many cars in all the lanes and the start position and the length of each car and its corresponding lane is given. There is a frog which an do 2 functions: wait() or jump().\rFind if there is a path for the frog to go from lane 1 to lane N without getting hit by any of the moving cars.", "k": ["lane", "speed", "lanes", "cars", "frog"]}
{"i": "6195668792115200", "t": "Write an algorithm to find the \u2018next\u2019 node (e.g., post-order successor) of a given node in a binary tree and binary search tree\ra.) where each node has a link to its parent.\rb.) without parent pointer\r implement 2 versions of the algorithm: 1.) binary tree 2.) BST", "k": ["parent pointer implement", "binary search tree", "post-order successor", "pointer implement", "binary tree"]}
{"i": "6492147700203520", "t": "Endian conversion little - big endian", "k": ["big endian", "endian conversion", "big", "endian", "conversion"]}
{"i": "5073177579356160", "t": "WAP , In SLL delete nth node from end.", "k": ["sll delete nth", "wap", "delete nth node", "sll delete", "node from end"]}
{"i": "5748271544795136", "t": "struct st{\r    int a;\r    char *ptr;\r}obj;\r assign : a=10;\r               ptr=\"Hello world\";", "k": ["ptr", "char", "obj", "assign", "struct"]}
{"i": "5069947227078656", "t": "Write a test case for the Amazon App store. \rSince there are so many functionality in Amazon App store, do I just make a smoke test or do I need to go all out and make testcase that will cover everything.", "k": ["amazon app store", "app store", "amazon app", "app", "store"]}
{"i": "5672848060317696", "t": "There is a byte array which contains the character of one byte and two bytes. One byte character has range 0 to 127 and first character of 2 byte character is 128 to 255 and second byte character has range 0 to 255. Now, two pointers are given, one points to the start of the and another points to somewhere else.\rTell which character 2nd pointers points to?", "k": ["byte character", "character", "byte", "byte array", "points"]}
{"i": "5177119042699264", "t": "You are given very huge file , with each line containing a single word. We have to give the count and word which is repeated most. I answer of using TRIE data structure to hold the word. I am reading a word at a time and incrementing the counter if i am getting the same word. I am keeping a global max count to keep the max count and the word. Complexity will be O(total letters in the file);", "k": ["word", "huge file", "single word", "count", "max count"]}
{"i": "6318655549734912", "t": "Given a binary search tree (BST) with each node having some value. You have to compute for each node the summation of all nodes whose value is greater than the current node.I have used the DFS kind of algorithm.Dictionary<node,bool> visited = new Dictionary<node,bool>();\r\nint Traverse(node n )\r\n{\r\n   if(node.Right == null)\r\n       if(node.Left != null && !visited(node.Left))\r\n          Traverse(node.Left);\r\n           return node.value;\r\nnode.Summation = Traverse(node.Right);\r\nif(node.Left != null && !visited(node.Left))\r\n     Traverse(node.Left);\r\nreturn node.Value + node.Summation;\r\n}", "k": ["binary search tree", "node.left", "search tree", "binary search", "traverse"]}
{"i": "5756589822705664", "t": "Given a self-balancing tree (AVL), code a method that returns the median.\r (Median: the numerical value separating the higher half of a data sample from the lower half. Example: if the series is\r 2, 7, 4, 9, 1, 5, 8, 3, 6\r then the median is 5.)", "k": ["self-balancing tree", "code a method", "method that returns", "avl", "returns the median"]}
{"i": "5717488440442880", "t": "Create the data structure for a component that will receive a series of numbers over the time and, when asked, returns the median of all received elements.\r (Median: the numerical value separating the higher half of a data sample from the lower half. Example: if the series is\r 2, 7, 4, 9, 1, 5, 8, 3, 6\r then the median is 5.)\r Model the data structure for a component that would have these two methods:@interface SampleHandler {\r\n- (void)addNumber:(NSNumber*)number;\r\n- (NSNumber*)median;\r\n}Justify your decisions. Calculate the complexity of each method.", "k": ["received elements", "data structure", "median", "create the data", "data"]}
{"i": "5187886659928064", "t": "i) Explain Polymorphism \r ii) Output of the below code snippet :-public class ParentTest {\r\n\r\n\tpublic int x = 0;\r\n\r\n    public void print() {\r\n        System.out.println(\"In Parent\");\r\n    }\r\n\r\n}\r\n\r\npublic class ChildTest extends ParentTest {\r\n\tpublic int x = 1;\r\n\r\n\tpublic void print() {\r\n        System.out.println(\"In Child\");\r\n    }\r\n\t\r\n\tpublic static void main( String args[] )\r\n\t{\r\n\t\tParentTest s = new ChildTest();\r\n\t\tSystem.out.println(s.x);\r\n\t\ts.print();   \r\n\t}\r\n}", "k": ["public void print", "public static void", "public class childtest", "static void main", "public class parenttest"]}
