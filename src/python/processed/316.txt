{"i": "15261663", "t": "An array of size N is given. Array is sub divided into sub array of size K. Find maximum value of each sub array.\r My ans-\rWhile traversing the array keep on adding values to max heap of size K and keeping a virtual window of size K on array.\rWhen element leaves the window then remove the leaving element from heap too and reheapify the heap. And max element of that window will be again on top in heap.\r Any better approach?", "k": ["size", "array", "heap", "array of size", "window"]}
{"i": "15199788", "t": "Suppose u have a square matrix of 0s and 1s only ... find the longest path of 1s available in the matrix and return that .. you can only move right and down ... For e.g.\r 0 0 0 1 1\r1 1 1 0 1\r0 1 1 1 0\r0 0 1 0 0\r1 1 1 1 1", "k": ["square matrix", "matrix", "find the longest", "suppose", "longest path"]}
{"i": "15190793", "t": "Given a node of Binary Tree . find all node's at distance k from it .", "k": ["binary tree", "node of binary", "tree", "find all node", "binary"]}
{"i": "15210763", "t": "You have a web server's log that records for each user the URL that he accessed.\rExample format:Time-stamp  User-id  URLHow to find the maximum common (sub)sequence of visited URLs from all users? Write code in java\rLog entries are ordered based on timestamp.\rExample log (omitting timestamp for clarity):\rJohn  URL1   \rJohn URL2\rJim URL2\rMary URL1\rJohn URL4\retc\rUpdate:\rExample:User-id    URL\r\n186           A\r\n187           B\r\n186           C\r\n188           B\r\n186           C\r\n187           A\r\n186           B\r\n188           A\r\n188           C\r\n189           A\r\n189           D\r\n187           C\r\n189           B\r\n186           A\r\n187           C\r\n189           A\r\n189           CSo the max common URL sequence is A,C,C (URL A followed by URL C, followed by URL C)", "k": ["web server log", "time-stamp user-id urlhow", "url", "web server", "time-stamp user-id"]}
{"i": "15194768", "t": "given a binary tree and a leaf node.\rholding that leaf node  and whole tree falls down such that it is the new root of the tree.\rreturn the modified  tree.", "k": ["leaf node", "tree", "binary tree", "leaf", "node"]}
{"i": "15194762", "t": "Find if the given two trees can be joined leaf to leaf?", "k": ["joined leaf", "find", "leaf", "trees", "joined"]}
{"i": "15202772", "t": "program to find all prime numbers in the range of \rthe input start/end numbers.\rstart number: 1,000,000,000,000\rend number: 1,000,000,000,000,000", "k": ["program to find", "find all prime", "input start", "end numbers", "prime numbers"]}
{"i": "15208757", "t": "suppose i m sitting on a server and several machines are pinging me with a word each and we are storing these words in a Queue.Now,the data stored in the queue is very large and we can process it once only.At the end of the day we are given 5 words and we have to find all the anagrams(for each of the 5 words) present in the queue.", "k": ["data stored", "machines are pinging", "only.at the end", "queue", "words"]}
{"i": "15199754", "t": "Design Online Movie Booking System.", "k": ["movie booking system", "online movie booking", "design online movie", "booking system", "online movie"]}
{"i": "15140844", "t": "Describe ACID properties in terms of a database transaction", "k": ["describe acid properties", "describe acid", "acid properties", "database transaction", "properties in terms"]}
{"i": "15203732", "t": "Database server is in US and web server is in India, how will you handle time zone conversion?", "k": ["time zone conversion", "handle time zone", "zone conversion", "database server", "handle time"]}
{"i": "15207726", "t": "Given two arrays of integer, print out the values from first array which are not present in second array. Time complexity should be O(n)", "k": ["arrays of integer", "integer", "print", "array", "present"]}
{"i": "15203729", "t": "Given a BST, how would you return the nth smallest element. The code had to cover all the edge cases and was expected to write a logn solution", "k": ["nth smallest element", "smallest element", "return the nth", "nth smallest", "bst"]}
{"i": "15208733", "t": "How does a site like Facebook store \"Likes\" ?\r Whats the best approach for Space complexity and Time complexity ? Can we do it in O(1) space or at least O(n) space ?", "k": ["facebook store", "site like facebook", "time complexity", "complexity and time", "space complexity"]}
{"i": "15203723", "t": "Given a Binary Tree (not BST) with integer values . 1) Find path from root to any node with max sum. 2) As there can be many path's find all of them. 3) Print all such paths.\r Do this in O(n) : n is number of node's in tree. he wanted an O(n) solution not O(n)+O(n) ie. u can't traverse tree twice .", "k": ["max sum", "binary tree", "bst", "binary", "find path"]}
{"i": "15206700", "t": "Classic 2-sum problem. \rHint, using hash table.", "k": ["classic", "problem", "hint", "hash table", "table"]}
{"i": "15199709", "t": "Implement atoi().", "k": ["implement atoi", "implement", "atoi"]}
{"i": "15208710", "t": "Select a random node data from a very long linked list whose length is not known such that the probability of each node is equal.", "k": ["long linked list", "random node data", "select a random", "long linked", "linked list"]}
{"i": "15225675", "t": "Large shared HDD is synced with Cloud Server. HDD contains same files multiple times by different users. How does the cloud server manage duplicates. It can't store all the duplicates. Duplicates may not be differ by file name. Discuss algorithm.", "k": ["large shared hdd", "large shared", "cloud server", "shared hdd", "hdd"]}
{"i": "15190680", "t": "Print all valid phone numbers of length n subject to following constraints:\r 1.If a number contains a 4, it should start with 4\r2.No two consecutive digits can be same\r3.Three digits (e.g. 7,2,9) will be entirely disallowed, take as input", "k": ["valid phone numbers", "print all valid", "valid phone", "length n subject", "phone numbers"]}
{"i": "15190678", "t": "The producers write elements to a ring buffer(fixed size) while the consumers access elements from it. Implement a write and a read function using a producer pointer and consumer pointer. The consumer pointer cannot surpass the producer pointer and when the producer pointer reaches where it starts again, it stops.", "k": ["consumers access elements", "fixed size", "producers write elements", "ring buffer", "access elements"]}
{"i": "15226662", "t": "Given a file, we have to replace a word with another word.", "k": ["file", "replace a word", "word", "replace"]}
{"i": "15209664", "t": "Design online movie ticket booking system.", "k": ["design online movie", "ticket booking system", "online movie ticket", "movie ticket booking", "design online"]}
{"i": "15208675", "t": "Given 2 arrays, with less complexity you have to tell me both the arrays contain same elements or not.\rarray 1 = {1,4,3,8,2,8}\rarray 2 = {}3,5,1,2,6,8,3,4}", "k": ["complexity", "elements", "arrays", "array"]}
{"i": "15192666", "t": "there are two arrays named A and B , both of them with k size, they are sorted in acsending order. could you find k-th  smallest combinations of ai, bj -->(ai+bj) . 0<=i,j <k. \rfor example: a = {1, 3, 6} b = {4, 5, 6} then we will get 1 + 4 = 5, 1 + 5 = 6, and 1 + 6 = 7,the result is 5,6,7. does it make you understood? and could anybody do it with less time and space complexity.\r Hi guys, thanks for all your suggestions and idea, and finally I get my answer and here are my c++ codes, time complexity is O(k*lgk), and space complexity is O(k):\r #include<iostream>\rusing namespace std;\r typedef struct node{\r\tint row;\r\tint col;\r\tint data;\r}Node, *PNode;\r void swap(PNode &a, PNode &b) {\r\tPNode temp = a;\r\ta = b;\r\tb = temp;\r}\rvoid adjust_min_heap(PNode *bin, int i, int k) {\r\tint left  = 2 * i + 1;\r\tint right = 2 * i + 2;\r\tint min_index;\r\tif(left < k && bin[left]->data < bin[i]->data) {\r\t\tmin_index = left;\r\t} else {\r\t\tmin_index = i;\r\t}\r\tif(right < k && bin[right]->data < bin[min_index]->data) {\r\t\tmin_index = right;\r\t}\r\tif(min_index != i) {\r\t\tswap(bin[i], bin[min_index]);\r\t\tadjust_min_heap(bin, min_index, k);\r\t}\r}\r void build_min_heap(PNode *bin, int k) {\r\tfor(int i = k / 2; i >= 0; i--) {\r\t\tadjust_min_heap(bin, i, k);\r\t}\r}\r int *get_k_th_minimum(int *a, int *b, int k) {\r\tPNode *bin = (PNode*)malloc(sizeof(PNode) * k);\r\tint *result = (int*)malloc(sizeof(int) * k);\r\tmemset(result, 0, sizeof(int) * k);\r\tint i;\r\tint count = 0;\r\tfor(i = 0; i < k; i++) {\r\t\tbin[i] = (Node*)malloc(sizeof(Node));\r\t\tbin[i]->row = i;\r\t\tbin[i]->col = 0;\r\t\tbin[i]->data = a[i] + b[0];\r\t}\r\tbuild_min_heap(bin, k);\r\twhile(count < k) {\r\t\tresult[count++] = bin[0]->data;\r\t\tbin[0]->col += 1;\r\t\tbin[0]->data = a[bin[0]->row] + b[bin[0]->col];\r\t\tadjust_min_heap(bin, 0, k);\r\t}\r\tfor(i = 0; i < k; i++) {\r\t\tfree(bin[i]);\r\t}\r\tfree(bin);\r\treturn result;\r}\r void main() {\r\tint a[] = {1, 2, 4};\r\tint b[] = {5, 9, 11};\r\tint k = 3;\r\tint *p = get_k_th_minimum(a, b, k);\r\tfor(int i = 0; i < k; i++) {\r\t\tcout << p[i] << \" \";\r\t}\r\tfree(p);\r\tgetchar();\r}", "k": ["bin", "int", "min", "index", "pnode"]}
{"i": "15152764", "t": "given an array [1,2,3,4,5]\rgive out all non repeating combinations of size 2. generalize it for any size", "k": ["repeating combinations", "size", "array", "give", "combinations of size"]}
{"i": "15174663", "t": "find least common ancestor in btree.\rNote:its btree not bst", "k": ["find least common", "common ancestor", "find", "note", "btree"]}
{"i": "15145724", "t": "find all broken links in a web page", "k": ["find all broken", "web page", "broken links", "find", "page"]}
{"i": "15147757", "t": "how to implement LRU for ecommerce site --> use linklist+map", "k": ["map", "implement lru", "lru for ecommerce", "ecommerce site", "lru"]}
{"i": "15147756", "t": "How will you store friend-to-friend relation of  facebook  in db", "k": ["relation of facebook", "store", "relation", "facebook"]}
