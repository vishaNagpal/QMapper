{"i": "3700841", "t": "How do we validate that a given doc is a well formed xml? which DS and algorithm? Write the test cases as well", "k": ["formed xml", "xml", "validate", "doc", "formed"]}
{"i": "3644819", "t": "Given a list of strings say N, how would you write a perfect hash function and ensure 0 collissions?", "k": ["perfect hash function", "function and ensure", "list of strings", "write a perfect", "perfect hash"]}
{"i": "3691807", "t": "Linked List with following structure..struct node\r\n{\r\n    int data;\r\n    struct node *next;\r\n    struct node *next_larger;\r\n}initially next_larger of every node is point to NULL.\rnow write a c code which set all node's next_larger pointer.\rwhere next_largest point to the next larger then its own value and largest value node's next_larger pointer points to NULL\r i.e.\rif LL is 3->1->5->6->4\rthen 3's next_larger points to 4 \rand 1's next_larger points to 3\rand 5's next_larger points to 6\rand 6's next_larger points to NULL\rand 4's next_larger points to 5", "k": ["struct node", "linked list", "larger points", "points to null", "int data"]}
{"i": "3713811", "t": "if u have a N steps staircase u standing at 1 step now you have options to step up to 2step or you can skip one step and go to 3rd step... so at ith step you have a option to go to i+1 step or i+2 step.. so how many ways you can climb the stairs...??", "k": ["staircase u standing", "step", "steps staircase", "staircase", "standing"]}
{"i": "3712813", "t": "Q) There is a document containing lots of information. You have a function char * getNextWord() which returns the next word from the document.\ra) which data structure should be used for maintaining the information about the frequency of words.\rb) Write an effective algo for maintaining the information about the frequency of each word in the document.\rc) what is the complexity of algorithm.", "k": ["document", "information", "maintaining the information", "document containing lots", "lots of information"]}
{"i": "3652798", "t": "Q. There is an array\r A[N][M] = \r1 2 3\r4 5 6\r The array is rotated so that \rA'[M][N] =\r3 6\r2 5\r1 4\r is obtained.\rEstablish the relation between A and A' by using i, j, M, N\r A[i][j] = A'[_][_]", "k": ["array is rotated", "array", "obtained", "establish the relation", "rotated"]}
{"i": "3679803", "t": "Q. There are two linked list that are sorted. We need to merge these lists so that the obtained list is also in sorted order. You should not prepare an extra list for merging the lists.\rThe next question was to write the test cases for testing the program.", "k": ["linked list", "sorted order", "list", "sorted", "linked"]}
{"i": "3686803", "t": "int main()\r\n{\r\n\tint i = 32242;\r\n\tint k = find(i);\r\n\treturn k;\r\n}\r\n\r\nint find (int j)\r\n{\r\n\tif (j > 0)\r\n\t{\r\n\tj = j%10 + find(j/10);\r\n\tprintf(\" %d \", j);\r\n\t}\r\n\treturn j;\r\n}Find the output of the program?\r Ans: 3 5 7 11 13", "k": ["int main", "int find", "int", "find", "return"]}
{"i": "3652797", "t": "you are given 2 arrays sorted in decreasing order of size m and n respectively.\r Input: a number k <= n*n and >= 1\r Output: the kth largest sum(a+b) possible. where\ra (any element from array 1)\rb (any element from array 2)\r The Brute force approach will take O(n*n). can anyone find a better logic. thnkx in advance.", "k": ["sorted in decreasing", "decreasing order", "order of size", "arrays sorted", "kth largest sum"]}
{"i": "3685743", "t": "What type of directory structure is generally used by operating systems?\r< As in single level, tree, acyclic etc >", "k": ["operating systems", "type of directory", "directory structure", "structure is generally", "tree"]}
{"i": "3655770", "t": "Given an input array of integers of size n, and a query array of integers of size k, find the smallest window of input array that contains all the elements of query array and also in the same order.", "k": ["integers of size", "input array", "query array", "find the smallest", "smallest window"]}
{"i": "3719711", "t": "In a sequence of integers, find the max length increasing order subsequence.", "k": ["increasing order subsequence", "max length increasing", "length increasing order", "sequence of integers", "find the max"]}
{"i": "3668752", "t": "Find palindrome of max size in a string", "k": ["find palindrome", "palindrome of max", "max size", "find", "string"]}
{"i": "3652752", "t": "Implement a stack which supports FindMin(),push() and pop(). The probability of the occurrence is equal.", "k": ["implement a stack", "supports findmin", "stack which supports", "push", "implement"]}
{"i": "3713758", "t": "find BST of max size in a binary tree", "k": ["find bst", "bst of max", "binary tree", "max size", "bst"]}
{"i": "3655768", "t": "Design parking lot", "k": ["design parking lot", "design parking", "parking lot", "design", "lot"]}
{"i": "3691749", "t": "find the number of occurrence of words at point of time (source is a infinite stream of chars with words separated by space as delimiter)", "k": ["find the number", "point of time", "space as delimiter", "number of occurrence", "infinite stream"]}
{"i": "3701752", "t": "Print a 2-dimensional array in spiral way(handle border cases)", "k": ["handle border cases", "array in spiral", "handle border", "border cases", "print"]}
{"i": "3644753", "t": "Given two n digit prime numbers, change the first number to the second by changing one digit at a time. The resulting intermediate numbers should also be prime.", "k": ["digit prime numbers", "digit prime", "changing one digit", "digit", "change"]}
{"i": "3700715", "t": "Write me a function that receives three integer inputs for the lengths of the sides of a triangle and returns one of four values to determine the triangle type (1=scalene, 2=isosceles, 3=equilateral, 4=error). Generate test cases for the function assuming another developer coded the function", "k": ["triangle type", "receives three integer", "integer inputs", "triangle and returns", "determine the triangle"]}
{"i": "3653734", "t": "I have a expression containing extra brackets  .Write an algo which can remove unwanted brackets like expression is (((a+d)*(a-2))) so we shuld be able to get (a+d)*(a-2)", "k": ["remove unwanted brackets", "write an algo", "remove unwanted", "extra brackets", "unwanted brackets"]}
{"i": "3697708", "t": "Say you need to design a web application which needs to support friends of \rfriends function(like in linked in, when you search a person, it will show \ryou if this person is linked with you, your connection or your connections' \rconection...), we expect to have millions of users and each user may have \rthousands of friends, how would you design/implement this function to make \rit scalable.", "k": ["connections' conection", "make it scalable", "web application", "support friends", "friends function"]}
{"i": "3649710", "t": "Given a matrix of integers where every row is sorted and every column is sorted. Print all elements in sorted order.\r Cannot use merging of arrays. Solution should be better than O(n2logn)", "k": ["matrix of integers", "sorted", "row is sorted", "column is sorted", "sorted order"]}
{"i": "3718705", "t": "Given a set of positive and negative integers, partition it into two subsets S1 and S2 such that  sum (S1) - sum (S2) = minimum (0 if possible)\r A little discussion revealed the problem is NP. But he wanted a solution O(kn) where k is max element in the array", "k": ["negative integers", "set of positive", "positive and negative", "discussion revealed", "revealed the problem"]}
{"i": "3675683", "t": "Given is an array of integers. Element is called an extreme if no other element's value is more distant from the average. Write a function\r int extreme(int[] A);\r that given an array of integers returns the index of an extreme (any one of them if there are many).\r If no extreme exists, the function should return -1.\r   A[0]=9, A[1]=4, A[2]=-3, A[3]=-10\r the index of an extreme is 3, because the average of the array is\r   (9 + 4 + (-3) + (-10)) / 4 = 0\r and in this array no value is further from 0 than -10", "k": ["extreme", "array", "integers", "array of integers", "index"]}
{"i": "3653690", "t": "Write a function\r int count_div(int a,int b,int k);\r that given three integer numbers a, b and k return number of integers from range [a..b] divisible by k, i.e.:\r     For example, for a=6, b=11, and k=2, your function should return 3, because there are 3 numbers divisible by 2 in the range [6..11], namely 6, 8 and 10.\r You can assume that , and k>0.", "k": ["function int count", "int a,int b,int", "int count", "a,int b,int", "numbers divisible"]}
{"i": "3714674", "t": "Every element in an array of integers points to a relative location from the current element. Precisely, if A[k] = m, the jump from k should land at k+A[k]=k+m.\r Write a function\r int arrayJmp(int[] A);\r that returns the number of jumps until the pointer jumps out of the array when starting from the firstelement.\r For example:\r   A[0]=2, A[1]=3, A[2]=1, A[3]=1, A[4]=3\r The pointer's 1st jump is from 0 to 2, 2nd jump from 2 to 3, 3rd jump from 3 to 4, 4th jump from 4 to 7, but 7 is out of the array. The number of jumps until the pointer jumps out of the array is 4.\r Return -1 if the sequence of jumps never ends.", "k": ["current element", "integers points", "relative location", "jump", "jumps"]}
{"i": "3603906", "t": "You are given an array of positive integers. Convert it to a sorted array with minimum cost. Only valid operation are\r1) Decrement -> cost = 1\r2) Delete an element completely from the array -> cost = value of element\r For example:\r4,3,5,6, -> cost 1\r10,3,11,12 -> cost 3", "k": ["positive integers", "cost", "array", "integers", "positive"]}
{"i": "3612862", "t": "What happens if TCP consistently gets timeouts for a given packet? What does it do to maintain reliability?", "k": ["tcp consistently", "consistently gets timeouts", "tcp", "packet", "maintain reliability"]}
{"i": "3568270", "t": "Lets say you are using UDP to show a live video. Which feature of TCP will you miss the most?", "k": ["udp to show", "live video", "show a live", "udp", "video"]}
